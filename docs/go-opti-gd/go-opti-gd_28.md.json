["```go\nstateDiagram-v2\n    [*] --> New : goroutine declared\n    New --> Runnable : go func() invoked\n    Runnable --> Running : scheduled on an available P\n    Running --> Waiting : blocking syscall, channel op, etc.\n    Waiting --> Runnable : event ready, rescheduled\n    Running --> Terminated : function exits or panics\n    Waiting --> Terminated : canceled or panicked\n    Terminated --> [*]\n\n    state \"Go Scheduler\\n(GOMAXPROCS = N)\" as Scheduler {\n        [*] --> P1\n        [*] --> P2\n        ...\n        [*] --> PN\n\n        P1 --> ScheduleGoroutine1 : pick from global/runq\n        P2 --> ScheduleGoroutine2\n        PN --> ScheduleGoroutineN\n    }\n\n    note right of Runnable\n        Ps (Processors) pick Runnable goroutines\n        based on availability up to GOMAXPROCS\n    end note\n\n    note right of Scheduler\n        GOMAXPROCS determines how many Ps\n        can execute goroutines in parallel.\n    end note\n```", "```go\nflowchart TD\n    A[\"Goroutine: conn.Read()\"] --> B[netpoller checks FD]\n    B --> C{FD ready?}\n    C -- No --> D[Park goroutine]\n    D --> E[FD registered with epoll]\n    E --> F[epoll_wait blocks]\n    F --> G[FD ready]\n    G --> H[Wake goroutine]\n    H --> I[Re-schedule]\n    C -- Yes --> H\n```", "```go\nflowchart TD\n    A[net.Listen] --> B[ListenTCP] --> C[listenFD]\n    C --> D[\"pollDesc (register with netpoll)\"]\n    D --> E[runtime-integrated non-blocking syscall wrappers]\n```", "```go\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"net\"\n    \"time\"\n)\n\nfunc main() {\n    // Start listening on TCP port 9000\n    listener, err := net.Listen(\"tcp\", \":9000\")\n    if err != nil {\n        panic(err) // Exit if the port can't be bound\n    }\n    fmt.Println(\"Echo server listening on :9000\")\n\n    // Accept incoming connections in a loop\n    for {\n        conn, err := listener.Accept() // Accept new client connection\n        if err != nil {\n            fmt.Printf(\"Accept error: %v\\n\", err)\n            continue // Skip this iteration on error\n        }\n\n        // Handle the connection in a new goroutine for concurrency\n        go handle(conn)\n    }\n}\n\n// handle echoes data back to the client line-by-line\nfunc handle(conn net.Conn) {\n    defer conn.Close() // Ensure connection is closed on exit\n\n    reader := bufio.NewReader(conn) // Wrap connection with buffered reader\n\n    for {\n        // Set a read deadline to avoid hanging goroutines if client disappears\n        conn.SetReadDeadline(time.Now().Add(5 * 60 * time.Second)) // 5 minutes timeout\n\n        // Read input until newline character\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            fmt.Printf(\"Connection closed: %v\\n\", err)\n            return // Exit on read error (e.g. client disconnect)\n        }\n\n        // Echo the received line back to the client\n        _, err = conn.Write([]byte(line))\n        if err != nil {\n            fmt.Printf(\"Write error: %v\\n\", err)\n            return // Exit on write error\n        }\n    }\n} \n```", "```go\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"net\"\n    \"time\"\n    \"sync/atomic\"\n) \n```", "```go\nlistener, err := net.Listen(\"tcp\", \":9000\")\nif err != nil {\n    panic(err)\n}\nfmt.Println(\"Echo server listening on :9000\") \n```", "```go\nfor {\n    conn, err := listener.Accept()\n    if err != nil {\n        fmt.Printf(\"Accept error: %v\\n\", err)\n        continue\n    }\n    go handle(conn)\n} \n```", "```go\nfunc handle(conn net.Conn) {\n    defer conn.Close()\n\n    reader := bufio.NewReader(conn)\n\n    for {\n        conn.SetReadDeadline(time.Now().Add(5 * 60 * time.Second))\n\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            fmt.Printf(\"Connection closed: %v\\n\", err)\n            return\n        }\n\n        _, err = conn.Write([]byte(line))\n        if err != nil {\n            fmt.Printf(\"Write error: %v\\n\", err)\n            return\n        }\n    }\n} \n```", "```go\nsequenceDiagram\n    participant L as Listener Goroutine\n    participant N as netFD\n    participant P as Go Poller\n    participant S as syscall layer\n    participant H as Handler Goroutine\n\n    L->>N: Accept()\n    N->>P: Wait for connection (runtime_pollWait)\n    P->>S: syscall.accept\n    S-->>L: Return net.Conn\n    L->>H: go handle(conn)\n\n    H->>N: Read()\n    N->>P: Wait for data (runtime_pollWait)\n    P->>S: syscall.read\n    S-->>H: Return data\n    H->>N: Write()\n    N->>P: Check readiness\n    P->>S: syscall.write\n    S-->>H: Confirm write\n```"]