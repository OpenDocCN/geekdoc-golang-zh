["```\nInput: [2, 3, 1, 1, 4]\nOutput: true\n\nInput: [3, 2, 1, 0, 4]\nOutput: false\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc canJump(nums []int) bool {\n\tlenNums := len(nums)\n\tcanJumpB := make([]bool, lenNums)\n\n\tcanJumpB[0] = true\n\n\tfor i := 0; i < lenNums; i++ {\n\n\t\tif canJumpB[i] {\n\t\t\tvalAtCurrIndex := nums[i]\n\t\t\tfor k := 1; k <= valAtCurrIndex && i+k < lenNums; k++ {\n\t\t\t\tcanJumpB[i+k] = true\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn canJumpB[lenNums-1]\n}\n\nfunc main() {\n\tinput := []int{2, 3, 1, 1, 4}\n\n\tcanJumpOrNot := canJump(input)\n\tfmt.Println(canJumpOrNot)\n\n\tinput = []int{3, 2, 1, 0, 4}\n\n\tcanJumpOrNot = canJump(input)\n\tfmt.Println(canJumpOrNot)\n\n}\n```", "```\ntrue\nfalse\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc jump(nums []int) int {\n\n\tlenJump := len(nums)\n\tminJumps := make([]int, lenJump)\n\tfor i := 0; i < lenJump; i++ {\n\t\tminJumps[i] = -1\n\t}\n\n\tminJumps[0] = 0\n\n\tfor i := 0; i < lenJump; i++ {\n\t\tcurrVal := nums[i]\n\n\t\tfor j := 1; j <= currVal && i+j < lenJump; j++ {\n\t\t\tif minJumps[i+j] == -1 || minJumps[i+j] > minJumps[i]+1 {\n\t\t\t\tminJumps[i+j] = minJumps[i] + 1\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minJumps[lenJump-1]\n\n}\n\nfunc main() {\n\tinput := []int{2, 3, 1, 1, 4}\n\n\tminJump := jump(input)\n\tfmt.Println(minJump)\n\n\tinput = []int{3, 2, 1, 0, 4}\n\n\tminJump = jump(input)\n\tfmt.Println(minJump)\n\n}\n```", "```\n2\n-1\n```"]