["```go\n[](#cb1-1)type KV struct {\n[](#cb1-2)    Path   string // file name\n[](#cb1-3)    // internals\n[](#cb1-4)    fd   int\n[](#cb1-5)    tree BTree\n[](#cb1-6)    // more ...\n[](#cb1-7)}\n[](#cb1-8)func (db *KV) Open() error\n[](#cb1-9)\n[](#cb1-10)func (db *KV) Get(key []byte) ([]byte, bool) {\n[](#cb1-11)    return db.tree.Get(key)\n[](#cb1-12)}\n[](#cb1-13)func (db *KV) Set(key []byte, val []byte) error {\n[](#cb1-14)    db.tree.Insert(key, val)\n[](#cb1-15)    return updateFile(db)\n[](#cb1-16)}\n[](#cb1-17)func (db *KV) Del(key []byte) (bool, error) {\n[](#cb1-18)    deleted := db.tree.Delete(key)\n[](#cb1-19)    return deleted, updateFile(db)\n[](#cb1-20)}\n```", "```go\n[](#cb2-1)type BTree struct {\n[](#cb2-2)    root uint64\n[](#cb2-3)    get func(uint64) []byte // read a page\n[](#cb2-4)    new func([]byte) uint64 // append a page\n[](#cb2-5)    del func(uint64)        // ignored in this chapter\n[](#cb2-6)}\n```", "```go\n[](#cb3-1)func updateFile(db *KV) error {\n[](#cb3-2)    // 1\\. Write new nodes.\n[](#cb3-3)    if err := writePages(db); err != nil {\n[](#cb3-4)        return err\n[](#cb3-5)    }\n[](#cb3-6)    // 2\\. `fsync` to enforce the order between 1 and 3.\n[](#cb3-7)    if err := syscall.Fsync(db.fd); err != nil {\n[](#cb3-8)        return err\n[](#cb3-9)    }\n[](#cb3-10)    // 3\\. Update the root pointer atomically.\n[](#cb3-11)    if err := updateRoot(db); err != nil {\n[](#cb3-12)        return err\n[](#cb3-13)    }\n[](#cb3-14)    // 4\\. `fsync` to make everything persistent.\n[](#cb3-15)    return syscall.Fsync(db.fd)\n[](#cb3-16)}\n```", "```go\n|     the_meta_page    | pages... | root_node | pages... | (end_of_file)\n| root_ptr | page_used |                ^                ^\n      |          |                      |                |\n      +----------|----------------------+                |\n                 |                                       |\n                 +---------------------------------------+\n```", "```go\n[](#cb5-1)func createFileSync(file string) (int, error) {\n[](#cb5-2)    // obtain the directory fd\n[](#cb5-3)    flags := os.O_RDONLY | syscall.O_DIRECTORY\n[](#cb5-4)    dirfd, err := syscall.Open(path.Dir(file), flags, 0o644)\n[](#cb5-5)    if err != nil {\n[](#cb5-6)        return -1, fmt.Errorf(\"open directory: %w\", err)\n[](#cb5-7)    }\n[](#cb5-8)    defer syscall.Close(dirfd)\n[](#cb5-9)    // open or create the file\n[](#cb5-10)    flags = os.O_RDWR | os.O_CREATE\n[](#cb5-11)    fd, err := syscall.Openat(dirfd, path.Base(file), flags, 0o644)\n[](#cb5-12)    if err != nil {\n[](#cb5-13)        return -1, fmt.Errorf(\"open file: %w\", err)\n[](#cb5-14)    }\n[](#cb5-15)    // fsync the directory\n[](#cb5-16)    if err = syscall.Fsync(dirfd); err != nil {\n[](#cb5-17)        _ = syscall.Close(fd)  // may leave an empty file\n[](#cb5-18)        return -1, fmt.Errorf(\"fsync directory: %w\", err)\n[](#cb5-19)    }\n[](#cb5-20)    return fd, nil\n[](#cb5-21)}\n```", "```go\n[](#cb6-1)func Mmap(fd int, offset int64, length int, ...) (data []byte, err error)\n```", "```go\n[](#cb7-1)func (db *KV) Open() error {\n[](#cb7-2)    db.tree.get = db.pageRead   // read a page\n[](#cb7-3)    db.tree.new = db.pageAppend // apppend a page\n[](#cb7-4)    db.tree.del = func(uint64) {}\n[](#cb7-5)    // ...\n[](#cb7-6)}\n```", "```go\n[](#cb8-1)syscall.Mmap(fd, offset, size, syscall.PROT_READ, syscall.MAP_SHARED)\n```", "```go\n[](#cb9-1)type KV struct {\n[](#cb9-2)    // ...\n[](#cb9-3)    mmap struct {\n[](#cb9-4)        total  int      // mmap size, can be larger than the file size\n[](#cb9-5)        chunks [][]byte // multiple mmaps, can be non-continuous\n[](#cb9-6)    }\n[](#cb9-7)}\n[](#cb9-8)\n[](#cb9-9)// `BTree.get`, read a page.\n[](#cb9-10)func (db *KV) pageRead(ptr uint64) []byte {\n[](#cb9-11)    start := uint64(0)\n[](#cb9-12)    for _, chunk := range db.mmap.chunks {\n[](#cb9-13)        end := start + uint64(len(chunk))/BTREE_PAGE_SIZE\n[](#cb9-14)        if ptr < end {\n[](#cb9-15)            offset := BTREE_PAGE_SIZE * (ptr - start)\n[](#cb9-16)            return chunk[offset : offset+BTREE_PAGE_SIZE]\n[](#cb9-17)        }\n[](#cb9-18)        start = end\n[](#cb9-19)    }\n[](#cb9-20)    panic(\"bad ptr\")\n[](#cb9-21)}\n```", "```go\n[](#cb10-1)func extendMmap(db *KV, size int) error {\n[](#cb10-2)    if size <= db.mmap.total {\n[](#cb10-3)        return nil // enough range\n[](#cb10-4)    }\n[](#cb10-5)    alloc := max(db.mmap.total, 64<<20) // double the current address space\n[](#cb10-6)    for db.mmap.total + alloc < size {\n[](#cb10-7)        alloc *= 2 // still not enough?\n[](#cb10-8)    }\n[](#cb10-9)    chunk, err := syscall.Mmap(\n[](#cb10-10)        db.fd, int64(db.mmap.total), alloc,\n[](#cb10-11)        syscall.PROT_READ, syscall.MAP_SHARED, // read-only\n[](#cb10-12)    )\n[](#cb10-13)    if err != nil {\n[](#cb10-14)        return fmt.Errorf(\"mmap: %w\", err)\n[](#cb10-15)    }\n[](#cb10-16)    db.mmap.total += alloc\n[](#cb10-17)    db.mmap.chunks = append(db.mmap.chunks, chunk)\n[](#cb10-18)    return nil\n[](#cb10-19)}\n```", "```go\n[](#cb11-1)type KV struct {\n[](#cb11-2)    // ...\n[](#cb11-3)    page struct {\n[](#cb11-4)        flushed uint64   // database size in number of pages\n[](#cb11-5)        temp    [][]byte // newly allocated pages\n[](#cb11-6)    }\n[](#cb11-7)}\n[](#cb11-8)\n[](#cb11-9)func (db *KV) pageAppend(node []byte) uint64 {\n[](#cb11-10)    ptr := db.page.flushed + uint64(len(db.page.temp)) // just append\n[](#cb11-11)    db.page.temp = append(db.page.temp, node)\n[](#cb11-12)    return ptr\n[](#cb11-13)}\n```", "```go\n[](#cb12-1)func writePages(db *KV) error {\n[](#cb12-2)    // extend the mmap if needed\n[](#cb12-3)    size := (int(db.page.flushed) + len(db.page.temp)) * BTREE_PAGE_SIZE\n[](#cb12-4)    if err := extendMmap(db, size); err != nil {\n[](#cb12-5)        return err\n[](#cb12-6)    }\n[](#cb12-7)    // write data pages to the file\n[](#cb12-8)    offset := int64(db.page.flushed * BTREE_PAGE_SIZE)\n[](#cb12-9)    if _, err := unix.Pwritev(db.fd, db.page.temp, offset); err != nil {\n[](#cb12-10)        return err\n[](#cb12-11)    }\n[](#cb12-12)    // discard in-memory data\n[](#cb12-13)    db.page.flushed += uint64(len(db.page.temp))\n[](#cb12-14)    db.page.temp = db.page.temp[:0]\n[](#cb12-15)    return nil\n[](#cb12-16)}\n```", "```go\n[](#cb13-1)const DB_SIG = \"BuildYourOwnDB06\" // not compatible between chapters\n[](#cb13-2)\n[](#cb13-3)// | sig | root_ptr | page_used |\n[](#cb13-4)// | 16B |    8B    |     8B    |\n[](#cb13-5)func saveMeta(db *KV) []byte {\n[](#cb13-6)    var data [32]byte\n[](#cb13-7)    copy(data[:16], []byte(DB_SIG))\n[](#cb13-8)    binary.LittleEndian.PutUint64(data[16:], db.tree.root)\n[](#cb13-9)    binary.LittleEndian.PutUint64(data[24:], db.page.flushed)\n[](#cb13-10)    return data[:]\n[](#cb13-11)}\n[](#cb13-12)\n[](#cb13-13)func loadMeta(db *KV, data []byte)\n```", "```go\n[](#cb14-1)func readRoot(db *KV, fileSize int64) error {\n[](#cb14-2)    if fileSize == 0 { // empty file\n[](#cb14-3)        db.page.flushed = 1 // the meta page is initialized on the 1st write\n[](#cb14-4)        return nil\n[](#cb14-5)    }\n[](#cb14-6)    // read the page\n[](#cb14-7)    data := db.mmap.chunks[0]\n[](#cb14-8)    loadMeta(db, data)\n[](#cb14-9)    // verify the page\n[](#cb14-10)    // ...\n[](#cb14-11)    return nil\n[](#cb14-12)}\n```", "```go\n[](#cb15-1)// 3\\. Update the meta page. it must be atomic.\n[](#cb15-2)func updateRoot(db *KV) error {\n[](#cb15-3)    if _, err := syscall.Pwrite(db.fd, saveMeta(db), 0); err != nil {\n[](#cb15-4)        return fmt.Errorf(\"write meta page: %w\", err)\n[](#cb15-5)    }\n[](#cb15-6)    return nil\n[](#cb15-7)}\n```", "```go\n[](#cb16-1)func (db *KV) Set(key []byte, val []byte) error {\n[](#cb16-2)    meta := saveMeta(db) // save the in-memory state (tree root)\n[](#cb16-3)    db.tree.Insert(key, val)\n[](#cb16-4)    return updateOrRevert(db, meta)\n[](#cb16-5)}\n[](#cb16-6)\n[](#cb16-7)func updateOrRevert(db *KV, meta []byte) error {\n[](#cb16-8)    // 2-phase update\n[](#cb16-9)    err := updateFile(db)\n[](#cb16-10)    // revert on error\n[](#cb16-11)    if err != nil {\n[](#cb16-12)        // the in-memory states can be reverted immediately to allow reads\n[](#cb16-13)        loadMeta(db, meta)\n[](#cb16-14)        // discard temporaries\n[](#cb16-15)        db.page.temp = db.page.temp[:0]\n[](#cb16-16)    }\n[](#cb16-17)    return err\n[](#cb16-18)}\n```", "```go\n[](#cb17-1)type KV struct {\n[](#cb17-2)    // ...\n[](#cb17-3)    failed bool // Did the last update fail?\n[](#cb17-4)}\n[](#cb17-5)\n[](#cb17-6)func updateOrRevert(db *KV, meta []byte) error {\n[](#cb17-7)    // ensure the on-disk meta page matches the in-memory one after an error\n[](#cb17-8)    if db.failed {\n[](#cb17-9)        // write and fsync the previous meta page\n[](#cb17-10)        // ...\n[](#cb17-11)        db.failed = false\n[](#cb17-12)    }\n[](#cb17-13)    err := updateFile(db)\n[](#cb17-14)    if err != nil {\n[](#cb17-15)        // the on-disk meta page is in an unknown state;\n[](#cb17-16)        // mark it to be rewritten on later recovery.\n[](#cb17-17)        db.failed = true\n[](#cb17-18)        // ...\n[](#cb17-19)    }\n[](#cb17-20)    return err\n[](#cb17-21)}\n```"]