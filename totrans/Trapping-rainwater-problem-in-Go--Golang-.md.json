["```\n[2, 0 , 2, 1, 3, 1]\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\toutput := trap([]int{2, 0, 2, 1, 3, 1})\n\tfmt.Println(output)\n\n\toutput = trap([]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1})\n\tfmt.Println(output)\n\n\toutput = trap([]int{4, 2, 0, 3, 2, 5})\n\tfmt.Println(output)\n}\n\nfunc trap(height []int) int {\n\n\toutput := 0\n\theightArrayLen := len(height)\n\tcustomStack := customStack{\n\t\tstack: make([]int, 0),\n\t}\n\n\tcustomStack.Push(0)\n\n\tfor i := 1; i < heightArrayLen; i++ {\n\n\t\tfor customStack.Size() != 0 {\n\t\t\tfront, _ := customStack.Front()\n\t\t\tif height[front] <= height[i] {\n\t\t\t\toutput = output + (i-front-1)*(height[front]-max(height, front+1, i-1))\n\t\t\t\tcustomStack.Pop()\n\t\t\t} else {\n\t\t\t\toutput = output + (i-front-1)*(height[i]-max(height, front+1, i-1))\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tcustomStack.Push(i)\n\t}\n\treturn output\n\n}\n\nfunc max(input []int, start, end int) int {\n\n\tif start > end {\n\t\treturn 0\n\t}\n\n\tmax := 0\n\n\tfor i := start; i <= end; i++ {\n\t\tif input[i] > max {\n\t\t\tmax = input[i]\n\t\t}\n\t}\n\treturn max\n}\n\ntype customStack struct {\n\tstack []int\n\tlock  sync.RWMutex\n}\n\nfunc (c *customStack) Push(name int) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tc.stack = append(c.stack, name)\n}\n\nfunc (c *customStack) Pop() error {\n\tlen := len(c.stack)\n\tif len > 0 {\n\t\tc.lock.Lock()\n\t\tdefer c.lock.Unlock()\n\t\tc.stack = c.stack[:len-1]\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"Pop Error: Stack is empty\")\n}\n\nfunc (c *customStack) Front() (int, error) {\n\tlen := len(c.stack)\n\tif len > 0 {\n\t\tc.lock.Lock()\n\t\tdefer c.lock.Unlock()\n\t\treturn c.stack[len-1], nil\n\t}\n\treturn 0, fmt.Errorf(\"Peep Error: Stack is empty\")\n}\n\nfunc (c *customStack) Size() int {\n\treturn len(c.stack)\n}\n\nfunc (c *customStack) Empty() bool {\n\treturn len(c.stack) == 0\n}\n```", "```\n3\n6\n9\n```"]