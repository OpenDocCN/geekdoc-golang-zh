["```\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\ntype customQueue struct {\n    queue *list.List\n}\n\nfunc (c *customQueue) Enqueue(value string) {\n    c.queue.PushBack(value)\n}\n\nfunc (c *customQueue) Dequeue() error {\n    if c.queue.Len() > 0 {\n        ele := c.queue.Front()\n        c.queue.Remove(ele)\n    }\n    return fmt.Errorf(\"Pop Error: Queue is empty\")\n}\n\nfunc (c *customQueue) Front() (string, error) {\n    if c.queue.Len() > 0 {\n        if val, ok := c.queue.Front().Value.(string); ok {\n            return val, nil\n        }\n        return \"\", fmt.Errorf(\"Peep Error: Queue Datatype is incorrect\")\n    }\n    return \"\", fmt.Errorf(\"Peep Error: Queue is empty\")\n}\n\nfunc (c *customQueue) Size() int {\n    return c.queue.Len()\n}\n\nfunc (c *customQueue) Empty() bool {\n    return c.queue.Len() == 0\n}\n\nfunc main() {\n    customQueue := &customQueue{\n        queue: list.New(),\n    }\n    fmt.Printf(\"Enqueue: A\\n\")\n    customQueue.Enqueue(\"A\")\n    fmt.Printf(\"Enqueue: B\\n\")\n    customQueue.Enqueue(\"B\")\n    fmt.Printf(\"Size: %d\\n\", customQueue.Size())\n    for customQueue.Size() > 0 {\n        frontVal, _ := customQueue.Front()\n        fmt.Printf(\"Front: %s\\n\", frontVal)\n        fmt.Printf(\"Dequeue: %s\\n\", frontVal)\n        customQueue.Dequeue()\n    }\n    fmt.Printf(\"Size: %d\\n\", customQueue.Size())\n}\n```", "```\nEnqueue: A\nEnqueue: B\nSize: 2\nFront: A\nDequeue: A\nFront: B\nDequeue: B\nSize: 0\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype customQueue struct {\n\tqueue []string\n\tlock  sync.RWMutex\n}\n\nfunc (c *customQueue) Enqueue(name string) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tc.queue = append(c.queue, name)\n}\n\nfunc (c *customQueue) Dequeue() error {\n\tif len(c.queue) > 0 {\n\t\tc.lock.Lock()\n\t\tdefer c.lock.Unlock()\n\t\tc.queue = c.queue[1:]\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"Pop Error: Queue is empty\")\n}\n\nfunc (c *customQueue) Front() (string, error) {\n\tif len(c.queue) > 0 {\n\t\tc.lock.Lock()\n\t\tdefer c.lock.Unlock()\n\t\treturn c.queue[0], nil\n\t}\n\treturn \"\", fmt.Errorf(\"Peep Error: Queue is empty\")\n}\n\nfunc (c *customQueue) Size() int {\n\treturn len(c.queue)\n}\n\nfunc (c *customQueue) Empty() bool {\n\treturn len(c.queue) == 0\n}\n\nfunc main() {\n\tcustomQueue := &customQueue{\n\t\tqueue: make([]string, 0),\n\t}\n\n\tfmt.Printf(\"Enqueue: A\\n\")\n\tcustomQueue.Enqueue(\"A\")\n\tfmt.Printf(\"Enqueue: B\\n\")\n\tcustomQueue.Enqueue(\"B\")\n\tfmt.Printf(\"Len: %d\\n\", customQueue.Size())\n\n\tfor customQueue.Size() > 0 {\n\t\tfrontVal, _ := customQueue.Front()\n\t\tfmt.Printf(\"Front: %s\\n\", frontVal)\n\t\tfmt.Printf(\"Dequeue: %s\\n\", frontVal)\n\t\tcustomQueue.Dequeue()\n\t}\n\tfmt.Printf(\"Len: %d\\n\", customQueue.Size())\n} \n```", "```\nEnqueue: A\nEnqueue: B\nSize: 2\nFront: A\nDequeue: A\nFront: B\nDequeue: B\nSize: 0\n```"]