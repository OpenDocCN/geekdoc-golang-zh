- en: 利用 Go 中的编译器优化标志
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/01-common-patterns/comp-flags/](https://goperf.dev/01-common-patterns/comp-flags/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 当调整 Go 应用程序以获得性能时，大部分注意力都集中在运行时行为上——分析热点路径、减少分配、提高并发性。但还有一个容易被忽视的层面：Go 编译器在代码运行之前对代码做了什么。构建过程包括几个优化步骤，了解如何揭示或影响它们可以为您提供更清晰的洞察，了解底层实际发生了什么。这不仅仅是调整晦涩的标志来挤出额外的指令——这是了解编译器如何处理您的代码，以便您不会与之作对。
  prefs: []
  type: TYPE_NORMAL
- en: 虽然 Go 没有像 C 或 Rust 那样暴露出相同粒度的编译器标志，但它仍然提供了有用的方法来影响代码的构建方式——尤其是在针对性能、二进制大小或特定环境时。
  prefs: []
  type: TYPE_NORMAL
- en: 为什么编译器标志很重要[¶](#why-compiler-flags-matter "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go 的编译器（特别是 `cmd/compile` 和 `cmd/link`）执行几个默认优化：内联、逃逸分析、死代码消除等。然而，在某些场景中，您可以使用正确的标志从构建中获得更多性能或控制。
  prefs: []
  type: TYPE_NORMAL
- en: 用例包括：
  prefs: []
  type: TYPE_NORMAL
- en: 减少二进制大小以适应最小容器或嵌入式系统
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 为特定架构或操作系统构建
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 删除发布构建中的调试信息
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 暂时禁用优化以简化调试
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 启用实验性或不安全的性能技巧（请谨慎操作）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 关键编译器和链接器标志[¶](#key-compiler-and-linker-flags "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`-ldflags="-s -w"` — 删除调试信息[¶](#-ldflags-s-w-strip-debug-info "永久链接")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 当您想要缩小二进制大小时，尤其是在生产或容器中：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: go build -ldflags="-s -w" -o app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`-s`：省略符号表'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`：省略 DWARF 调试信息'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 为什么这很重要：这可以减少二进制大小高达 30-40%，具体取决于您的代码库。这在 Docker 镜像或分发二进制文件时很有用。
  prefs: []
  type: TYPE_NORMAL
- en: '`-gcflags` — 控制编译器优化[¶](#-gcflags-control-compiler-optimizations "永久链接")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-gcflags` 标志允许您控制编译器如何处理特定的包。例如，您可以为调试禁用优化：'
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: go build -gcflags="all=-N -l" -o app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`-N`：禁用优化'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l`：禁用内联'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 何时使用：在 Delve 或类似工具的调试会话期间。关闭内联和优化可以使堆栈跟踪和断点更可靠。
  prefs: []
  type: TYPE_NORMAL
- en: 跨平台编译标志[¶](#cross-compilation-flags "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 需要为其他操作系统或架构进行构建？
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: GOOS=linux GOARCH=arm64 go build -o app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`GOOS`, `GOARCH`：设置目标操作系统和架构'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 常见值：`windows`, `darwin`, `linux`, `amd64`, `arm64`, `386`, `wasm`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 构建标签[¶](#build-tags "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 构建标签允许条件编译。在您的源代码中使用 `//go:build` 或 `// +build` 来控制要编译的内容。
  prefs: []
  type: TYPE_NORMAL
- en: 示例：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: //go:build debug
  prefs: []
  type: TYPE_NORMAL
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "log"
  prefs: []
  type: TYPE_NORMAL
- en: func debugLog(msg string) {
  prefs: []
  type: TYPE_NORMAL
- en: log.Println("[DEBUG]", msg)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 然后进行构建：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: go build -tags=debug -o app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ldflags="-X ..."` — 注入构建时变量[¶](#-ldflags-x-inject-build-time-variables "永久链接")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 你可以在构建时将版本号或元数据注入到你的二进制文件中：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: // main.go
  prefs: []
  type: TYPE_NORMAL
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: var version = "dev"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'fmt.Printf("App version: %s\n", version)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 然后使用以下命令进行构建：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: go build -ldflags="-s -w -X main.version=1.0.0" -o app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这将在链接时设置 `version` 变量，而不会修改你的源代码。这对于嵌入发布版本、提交哈希或构建日期很有用。
  prefs: []
  type: TYPE_NORMAL
- en: '`-extldflags=''-static''` — 构建完全静态的二进制文件[¶](#-extldflags-static-build-fully-static-binaries
    "永久链接")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`-extldflags ''-static''` 选项将 `-static` 标志传递给外部系统链接器，指示它生成一个**完全静态链接的二进制文件**。'
  prefs: []
  type: TYPE_NORMAL
- en: 这在您使用 CGO 并希望避免运行时动态库依赖时特别有用。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
  prefs: []
  type: TYPE_NORMAL
- en: CC=gcc \
  prefs: []
  type: TYPE_NORMAL
- en: go build -ldflags="-linkmode=external -extldflags '-static'" -o app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 它的作用：
  prefs: []
  type: TYPE_NORMAL
- en: 将所有 C 库静态链接到二进制文件中
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 生成一个便携式、自包含的可执行文件
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 适用于最小容器（如 `scratch` 或 `distroless`）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 为了进一步确保你的二进制文件不依赖于 C 库的 DNS 解析（如 `glibc` 的 `getaddrinfo`），你可以使用 `netgo` 构建标签。这强制
    Go 使用其纯 Go 实现的 DNS 解析器：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
  prefs: []
  type: TYPE_NORMAL
- en: CC=gcc \
  prefs: []
  type: TYPE_NORMAL
- en: go build -tags netgo -ldflags="-linkmode=external -extldflags '-static'" -o
    app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在构建针对最小容器环境时，这一步尤为重要，因为在这些环境中可能不可用动态 libc 依赖项。
  prefs: []
  type: TYPE_NORMAL
- en: 注意
  prefs: []
  type: TYPE_NORMAL
- en: 静态链接需要使用你使用的库的静态版本（`.a`），并且默认情况下可能不与所有 C 库兼容。
  prefs: []
  type: TYPE_NORMAL
- en: 示例：通过 CGO 使用 libcurl 进行静态构建[¶](#example-static-build-with-libcurl-via-cgo "永久链接")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 如果你正在通过 CGO 使用 libcurl，以下是创建静态链接 Go 二进制文件的方法：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: /*
  prefs: []
  type: TYPE_NORMAL
- en: '#cgo LDFLAGS: -lcurl'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <curl/curl.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: import "C"
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("libcurl version:", C.GoString(C.curl_version()))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 静态构建命令：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
  prefs: []
  type: TYPE_NORMAL
- en: CC=gcc \
  prefs: []
  type: TYPE_NORMAL
- en: go build -tags netgo -ldflags="-linkmode=external -extldflags '-static'" -o
    app main.go
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 确保系统上可用的 libcurl 的静态版本（`libcurl.a`）。你可能需要安装开发包或使用 `--enable-static` 选项从源代码构建
    libcurl。
  prefs: []
  type: TYPE_NORMAL
