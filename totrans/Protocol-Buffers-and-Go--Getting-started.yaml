- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:01:02'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocol Buffers and Go: Getting started'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/protocol-buffers-go/](https://golangbyexample.com/protocol-buffers-go/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this tutorial, we will see how protocol buffers can be used in the context
    of GO Language.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is Protocol Buffer**'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Buffers are data format which stores data in a structured format. Data
    in the protocol buffer format can be serialized and deserialized by multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds Confusing. You can think it on lines of JSON, XML but it has loads of
    advantages to offer. Still confusing? then don’t worry as we go along the tutorial
    we will understand why even a new data format is even needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see first with an example of the simplest protocol buffer file.
  prefs: []
  type: TYPE_NORMAL
- en: '**person.proto**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A couple of points to note about the above file.
  prefs: []
  type: TYPE_NORMAL
- en: This file is just a blueprint of how our Protocol Buffer structure is. There
    is no data associated yet. This is different from JSON/XML , in which file also
    represents the actual data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the above file there is a **person** message with a field **name** of type
    **string.  “proto3”** means that the message written is incompatible with Protocol
    Buffer version three.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the above example, there is one difference you can notice from JSON i.e,
    it has type information. This type of information will be useful in the auto-generation
    of code in different languages. Let’s see an example of  auto-generation in Golang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Generation of GO Code:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generate a corresponding Golang code using the above person.proto file.
    But to do that we need to do some installations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installations:**'
  prefs: []
  type: TYPE_NORMAL
- en: First install the C++ implementation of Protocol Buffers. Each platform has
    its own way of installation. See this link – [https://github.com/protocolbuffers/protobuf/blob/master/src/README.md](https://github.com/protocolbuffers/protobuf/blob/master/src/README.md)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Golang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install protoc-gen-go – **go get -u** [github.com/golang/protobuf/protoc-gen-go](http://github.com/golang/protobuf/protoc-gen-go)**.**
    This package will be used for auto generation of Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the installation is done then cd to the directory which contains the
    **person.proto** file. Run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It will generate a data access go file with name **person.pb.go ** in the same
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now the biggest question is what is this person.pb.go file which has been auto-generated
    by protoc using person.proto . The first couple of points to notice
  prefs: []
  type: TYPE_NORMAL
- en: '**Person** struct like below. See how type information of person.proto file
    is used to know what type of field **Name **is a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Person** struct also implements a couple of methods that make if of interface
    type **proto.Message.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So basically this autogenerated file generates data accessors for Person struct
    and it provides methods that allow marshaling/unmarshalling of Person struct type
    to/from actual bytes. Now let’s write a main.go program to actually create concrete
    objects of **Person** struct. Here we will see a couple of advantages which Protocol
    Buffer has to offer. The below program also shows the read and write of Person
    struct to file.
  prefs: []
  type: TYPE_NORMAL
- en: '**main.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To run this file first install protobuf/proto using “go get [github.com/golang/protobuf/prot](http://github.com/golang/protobuf/prot)o”
    and then run this file using the command “go run *.go”**Output:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the above program we
  prefs: []
  type: TYPE_NORMAL
- en: We write a concrete **person** struct to a file **“person.bin”.** It is a binary
    file and not human readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also we read from the file. It is able to successfully read and print “**Person2’s
    name is XXX”**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The astonishing thing about the **“person.bin” file** is that it is of only
    5 bytes as compared if you create a JSON file with the same data that will be
    of size more than 15 bytes.  Also Marshal and UnMarshal from bytes to concrete
    objects and vice versa are also very fast as compared to unmarshal and marshaling
    of JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have provided the theory. Let’s write once again the advantages of using
    Protocol Buffers
  prefs: []
  type: TYPE_NORMAL
- en: More clear and less ambiguous than corresponding JSON and XML as there is also
    type information stored with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data stored is relatively smaller in size of almost 2- 3 times smaller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is much faster. For example, serialization and deserialization is faster
    with protocol Buffers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automated Code Generation – You write a protocol buffer file and you automatically
    get a corresponding GO file generated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A protocol buffer is used in GRPC which is next-generation replacement of REST
    protocol – Watch space for here, we will add an article on it soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Conclusion:** Protocol Buffers have much to offer other than what we have
    discussed in the article. This provides a quick overview of what protocol buffers
    are and what are their advantages as compared to JSON/XML format.'
  prefs: []
  type: TYPE_NORMAL
- en: '[buffer](https://golangbyexample.com/tag/buffer/)*   [go](https://golangbyexample.com/tag/go/)*   [grpc](https://golangbyexample.com/tag/grpc/)*   [protocol](https://golangbyexample.com/tag/protocol/)*   [protocolbuffer](https://golangbyexample.com/tag/protocolbuffer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
