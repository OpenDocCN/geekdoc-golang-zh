- en: 'Connection Lifecycle Observability: From Dial to Close¶'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接生命周期可观察性：从拨号到关闭¶
- en: 原文：[https://goperf.dev/02-networking/connection_observability/](https://goperf.dev/02-networking/connection_observability/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/02-networking/connection_observability/](https://goperf.dev/02-networking/connection_observability/)
- en: Many observability systems expose only high-level HTTP metrics, but deeper insight
    comes from explicitly instrumenting each stage — DNS resolution, dialing, handshake,
    negotiation, reads/writes, and teardown. Observing the full lifecycle of a network
    connection provides the clarity needed to diagnose latency issues, identify failures,
    and relate resource usage to external behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多可观察性系统仅公开高级HTTP指标，但更深入的洞察来自于对每个阶段——DNS解析、拨号、握手、协商、读写和拆除——的显式仪表化。观察网络连接的完整生命周期，可以提供诊断延迟问题、识别故障以及将资源使用与外部行为相关联所需的清晰度。
- en: DNS Resolution[¶](#dns-resolution "Permanent link")
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS解析[¶](#dns-resolution "永久链接")
- en: Every outbound connection begins with a name resolution step unless an IP is
    already known. DNS latency and failures often dominate connection setup time and
    can vary significantly depending on caching and resolver performance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个出站连接都始于一个名称解析步骤，除非已知IP地址。DNS延迟和故障通常主导连接设置时间，并且可能因缓存和解析器性能而显著变化。
- en: 'Capturing DNS resolution duration, errors and resulting address provides visibility
    into one of the least predictable phases. At this stage, it is valuable to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获DNS解析持续时间、错误和结果地址，可以提供对最不可预测阶段之一的可见性。在这个阶段，以下做法是有价值的：
- en: measure the time from query issuance to receiving an answer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量从查询发出到收到答案的时间
- en: log the resolved IP addresses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录解析的IP地址
- en: surface transient and permanent failures distinctly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确区分短暂和永久性故障
- en: In Go, this can be achieved by wrapping the `net.Resolver`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，这可以通过包装`net.Resolver`来实现。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This explicit measurement avoids relying on opaque metrics exposed by the OS
    resolver or libraries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显式测量避免了依赖于操作系统解析器或库公开的模糊指标。
- en: Dialing[¶](#dialing "Permanent link")
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拨号[¶](#dialing "永久链接")
- en: After obtaining an address, the next phase is dialing — establishing a TCP (or
    other transport) connection. Here, round-trip latency to the target, route stability,
    and ephemeral port exhaustion can all surface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 获得地址后，下一个阶段是拨号——建立TCP（或其他传输）连接。在这里，往返延迟到目标、路由稳定性和临时端口的耗尽都可能显现。
- en: Observing the dial phase often involves intercepting `net.Dialer`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 观察拨号阶段通常涉及拦截`net.Dialer`。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why trace here? Dialing failures can indicate downstream unavailability, but
    also local issues like SYN flood protection(1) or bad routing. Without a per-dial
    timestamp and error trace, identifying the locus of failure is guesswork.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这里进行跟踪？拨号失败可能表明下游不可用，但也可能是由于本地的SYN洪水保护（1）或不良路由问题。没有每个拨号的时戳和错误跟踪，确定故障位置只能是猜测。
- en: When dialing fails, sometimes it’s not because of the network or the server
    being down, but because the local machine refuses to open more connections due
    to resource exhaustion or protective rate limiting.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当拨号失败时，有时并不是因为网络或服务器故障，而是因为本地机器由于资源耗尽或保护性速率限制拒绝打开更多连接。
- en: Handshake and Negotiation[¶](#handshake-and-negotiation "Permanent link")
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 握手和协商[¶](#handshake-and-negotiation "永久链接")
- en: For secure connections, the next stage — cryptographic handshake — dominates.
    TLS negotiation can involve multiple round-trips, certificate validation, and
    cipher negotiation. Measuring this stage separately is necessary because it isolates
    pure network latency (dial) from cryptographic and policy enforcement costs (handshake).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安全连接，下一个阶段——加密握手——占主导地位。TLS协商可能涉及多个往返、证书验证和加密套件协商。单独测量这一阶段是必要的，因为它将纯网络延迟（拨号）与加密和政策执行成本（握手）隔离开来。
- en: The `crypto/tls` library in Go allows instrumentation of the handshake explicitly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`crypto/tls`库允许显式地对握手进行仪表化。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A common misconception is that slow TLS handshakes always reflect bad network
    conditions; in practice, slow certificate validation or [OCSP](https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol)/[CRL](https://en.wikipedia.org/wiki/Certificate_revocation_list)
    checks are frequently to blame. Separating these phases helps pinpoint the cause.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是，缓慢的TLS握手总是反映不良的网络条件；在实践中，缓慢的证书验证或[OCSP](https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol)/[CRL](https://en.wikipedia.org/wiki/Certificate_revocation_list)检查通常是罪魁祸首。将这些阶段分开有助于确定原因。
- en: Application Reads and Writes[¶](#application-reads-and-writes "Permanent link")
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序读取和写入[¶](#application-reads-and-writes "永久链接")
- en: Once the connection is established and negotiated, application-level traffic
    proceeds as reads and writes. Observability at this stage is often the least precise
    yet most critical for correlating client-perceived latency to backend processing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接建立并协商，应用层流量就作为读取和写入进行。在这个阶段的可观察性通常是最不精确的，但对于将客户端感知的延迟与后端处理相关联来说却是最关键的。
- en: Instrumenting reads and writes directly yields fine-grained latency and throughput
    metrics. Wrapping a connection is a common strategy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 直接对读取和写入进行度量可以产生细粒度的延迟和吞吐量指标。包裹连接是一种常见策略。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Why measure at this granularity? Reads and writes can block for reasons unrelated
    to connection establishment — buffer backpressure, TCP window exhaustion, or application
    pauses. Tracing them reveals whether observed slowness is due to I/O contention
    or upstream latency.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在这种粒度上进行测量？读取和写入可能会因为与连接建立无关的原因而阻塞——缓冲区后压力、TCP窗口耗尽或应用程序暂停。追踪这些操作可以揭示观察到的缓慢是否由于I/O竞争或上游延迟。
- en: Warning
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Such a granularity level can affect your system performance. See [Why reduce
    logs?](#why-reduce-logs) for more details.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的粒度级别可能会影响您的系统性能。有关更多详细信息，请参阅[为什么减少日志？](#why-reduce-logs)。
- en: Teardown[¶](#teardown "Permanent link")
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆卸[¶](#teardown "永久链接")
- en: Finally, connection closure often receives little attention, yet it can affect
    resource usage and connection pool behavior. Observing how long a connection takes
    to close and whether any errors surface during `Close()` is also useful. For TCP,
    the closure can be delayed by the OS until all `FIN`/`ACK` sequences complete,
    and sockets can linger in `TIME_WAIT`(1). Explicitly logging teardown metrics
    helps identify resource leaks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接关闭通常很少受到关注，但它可能会影响资源使用和连接池的行为。观察连接关闭所需的时间以及`Close()`期间是否出现任何错误也是有用的。对于TCP，关闭可能会被操作系统延迟，直到所有`FIN`/`ACK`序列完成，并且套接字可能会在`TIME_WAIT`(1)中滞留。明确记录拆卸指标有助于识别资源泄漏。
- en: Waiting for enough time to pass to be sure that all remaining packets on the
    connection have expired.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待足够的时间以确保连接上所有剩余的包都已过期。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Correlating Spans and Errors[¶](#correlating-spans-and-errors "Permanent link")
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联跨度与错误[¶](#correlating-spans-and-errors "永久链接")
- en: Capturing individual phase durations is not enough unless correlated into a
    coherent trace. Using a context-aware tracing library allows attaching phase spans
    to a single logical transaction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除非将各个阶段的持续时间关联到一个连贯的跟踪中，否则捕获单个阶段持续时间是不够的。使用上下文感知的跟踪库可以将阶段跨度附加到单个逻辑事务上。
- en: 'For example, with [OpenTelemetry](https://opentelemetry.io/):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用[OpenTelemetry](https://opentelemetry.io/)：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wrapping each phase in a span enables stitching the timeline together and correlating
    specific errors with their originating stage. This level of detail is important
    when diagnosing production outages where symptoms often manifest far from their
    root cause.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个阶段包裹在跨度中可以拼接时间线，并将特定错误与其起源阶段相关联。在诊断生产中断时，症状往往远在根本原因之外，这种详细程度非常重要。
- en: Detecting and Explaining Hangs[¶](#detecting-and-explaining-hangs "Permanent
    link")
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测和解释挂起[¶](#detecting-and-explaining-hangs "永久链接")
- en: One of the more insidious problems in distributed systems is a hung connection
    — no forward progress but no immediate failure. Granular observability can distinguish
    between a hang during DNS, an unresponsive handshake, a blocked write due to full
    buffers, or a delayed FIN. For example, if the dial phase logs complete but handshake
    never finishes, attention should focus on certificate validation, MTU black holes,
    or middlebox interference. By maintaining per-phase timeouts and alerts based
    on historical baselines, such conditions can be detected and explained rather
    than simply categorized as "slow." This explains not just what failed, but why
    it failed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统中的一个更隐蔽的问题是挂起的连接——没有前进但也没有立即失败。细粒度的可观察性可以区分DNS期间的挂起、无响应的手势、由于缓冲区满而阻塞的写入或延迟的FIN。例如，如果拨号阶段日志已完整但握手从未完成，则应关注证书验证、MTU黑洞或中间盒干扰。通过维护每个阶段的超时和基于历史基线的警报，这些条件可以被检测和解释，而不仅仅是简单地归类为“慢”。这不仅能说明什么失败了，还能说明为什么失败了。
- en: 'Beyond Logs: Metrics and Structured Events[¶](#beyond-logs-metrics-and-structured-events
    "Permanent link")'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越日志：指标和结构化事件[¶](#beyond-logs-metrics-and-structured-events "永久链接")
- en: Most likely you will need to reduce the volume of logs without losing essential
    information is critical for operating at scale. High-frequency, detailed logging
    of connection lifecycle events incurs I/O, CPU, and storage overhead. Without
    control mechanisms, it can overwhelm log aggregation systems, inflate costs, and
    even obscure the signal with noise. Log verbosity must therefore be managed carefully
    — keeping enough detail for diagnosis but avoiding excessive volume.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你需要减少日志量，同时不丢失对规模运营至关重要的关键信息。高频、详细的连接生命周期事件记录会产生I/O、CPU和存储开销。如果没有控制机制，它可能会压倒日志聚合系统，增加成本，甚至用噪声掩盖信号。因此，必须谨慎管理日志详细程度——保持足够的细节以供诊断，但避免过多的体积。
- en: '[Zap](https://github.com/uber-go/zap) is used in these examples to demonstrate
    strategies for runtime configurability and structured logging, but the same principles
    apply to any capable logging library. The ability to change levels dynamically,
    emit structured data, and sample events makes it easier to implement these strategies.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[Zap](https://github.com/uber-go/zap)在这些示例中用于演示运行时可配置性和结构化日志记录的策略，但相同的原理适用于任何有能力的日志库。能够动态更改级别、发出结构化数据和采样事件使得实现这些策略变得更容易。'
- en: Why reduce logs?[¶](#why-reduce-logs "Permanent link")
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么减少日志量？[¶](#why-reduce-logs "永久链接")
- en: Logging at fine granularity across thousands of connections per second can quickly
    generate terabytes of data, with much of it being repetitive and low-value. High
    log throughput can also cause contention with the application’s main execution
    paths, affecting latency. Furthermore, unbounded log growth burdens operators,
    complicates incident triage, and increases retention costs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每秒数千个连接上以细粒度进行日志记录可以迅速生成数以兆字节的数据，其中大部分是重复的且价值较低。高日志吞吐量也可能与应用程序的主要执行路径产生竞争，影响延迟。此外，无限制的日志增长会给操作员带来负担，复杂化事件分类，并增加保留成本。
- en: Techniques to control log volume[¶](#techniques-to-control-log-volume "Permanent
    link")
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制日志量的技术[¶](#techniques-to-control-log-volume "永久链接")
- en: '**Configurable log levels**: adjust verbosity at runtime depending on the situation
    — keeping production at `INFO` or `WARN` by default, switching to `DEBUG` or `TRACE`
    during investigation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置的日志级别**：根据情况在运行时调整详细程度——默认情况下将生产环境保持在`INFO`或`WARN`，在调查期间切换到`DEBUG`或`TRACE`。'
- en: '**Sampling**: log only a subset of events under high load or log every Nth
    connection. Zap supports samplers that enforce rate limits and randomness.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样**：在高负载下仅记录事件的一部分或每N个连接记录一次。Zap支持强制执行速率限制和随机性的采样器。'
- en: '**Metrics-first, logs-for-anomalies**: promote phase durations and counters
    to metrics (e.g., Prometheus) and emit logs only when thresholds or percentiles
    are breached.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标优先，日志用于异常**：将阶段持续时间和计数器提升到指标（例如，Prometheus）中，并且仅在阈值或百分位数被突破时发出日志。'
- en: '**Aggregate phase data**: collect all phase timings and results per connection,
    then emit a single structured log event at the end instead of logging each phase
    as a separate line.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合阶段数据**：收集每个连接的所有阶段时间和结果，然后在结束时发出一个单独的结构化日志事件，而不是将每个阶段作为单独的行进行记录。'
- en: By combining these approaches, it is possible to retain meaningful observability
    with manageable overhead. Zap’s API simply illustrates how to implement these
    patterns effectively — **the key takeaway is that the design itself, not the library
    choice**, determines observability quality and cost.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些方法，可以在可管理的开销下保留有意义的可观察性。Zap的API简单地说明了如何有效地实现这些模式——**关键要点是设计本身，而不是库的选择**，决定了可观察性的质量和成本。
- en: 'Here are a few illustrative code snippets for these techniques:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些这些技术的示例代码片段：
- en: Configurable log level[¶](#configurable-log-level "Permanent link")
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可配置的日志级别[¶](#configurable-log-level "永久链接")
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sampling logs[¶](#sampling-logs "Permanent link")
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 采样日志[¶](#sampling-logs "永久链接")
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Aggregate per-connection log[¶](#aggregate-per-connection-log "Permanent link")
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个连接的聚合日志[¶](#aggregate-per-connection-log "永久链接")
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While log statements and spans provide valuable information, a production-grade
    observability system benefits greatly from structured metrics collection and structured
    logging.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志语句和跨度提供了有价值的信息，但生产级可观察性系统从结构化指标收集和结构化日志记录中获益良多。
- en: Prometheus is well-suited for collecting and querying time-series metrics from
    each phase, exposing them to dashboards and alerting rules. Instead of embedding
    phase durations in unstructured logs, it is advisable to design and expose clearly
    named metrics like `connection_dns_duration_seconds`, `connection_dial_errors_total`,
    and similar counters. These names are proposed examples that follow Prometheus
    naming conventions and should be defined explicitly in the implementation to ensure
    clarity and consistency.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus非常适合从每个阶段收集和查询时间序列指标，并将它们暴露在仪表板和警报规则中。与其将阶段持续时间嵌入到非结构化日志中，不如设计并暴露清晰命名的指标，例如`connection_dns_duration_seconds`、`connection_dial_errors_total`以及类似的计数器。这些名称是遵循Prometheus命名约定的示例，应在实现中明确定义，以确保清晰和一致性。
- en: 'For structured logging, libraries such as Uber’s `zap` offer fast, JSON-encoded
    logs that integrate cleanly with log aggregation systems like ELK or Splunk. Rather
    than free-form `Printf`, one can emit structured key-value pairs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构化日志，如Uber的`zap`库提供快速、JSON编码的日志，可以干净地与ELK或Splunk等日志聚合系统集成。而不是使用自由形式的`Printf`，可以发出结构化的键值对：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Structured logs reduce the burden on downstream parsers and make correlating
    events between services more reliable. Combining these techniques — phase-level
    instrumentation, Prometheus metrics, and structured logs — transforms opaque failures
    into actionable insight. With this level of granularity and consistency, ambiguous
    symptoms become precise diagnoses, ensuring that both developers and operators
    can pinpoint not just that something is wrong, but exactly where and why.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化日志减轻了下游解析器的负担，并使在服务之间关联事件更加可靠。结合这些技术——阶段级仪表、Prometheus指标和结构化日志——将模糊的故障转化为可操作的见解。在这个粒度和一致性的水平上，模糊的症状变成了精确的诊断，确保开发人员和运维人员不仅可以确定有问题，而且可以精确地确定问题所在以及原因。
