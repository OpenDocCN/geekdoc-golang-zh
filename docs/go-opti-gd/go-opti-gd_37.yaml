- en: Comparing TCP, HTTP/2, and gRPC Performance in Go¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中比较TCP、HTTP/2和gRPC性能¶
- en: 原文：[https://goperf.dev/02-networking/tcp-http2-grpc/](https://goperf.dev/02-networking/tcp-http2-grpc/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://goperf.dev/02-networking/tcp-http2-grpc/](https://goperf.dev/02-networking/tcp-http2-grpc/)'
- en: In distributed systems, the choice of communication protocol shapes how services
    interact under real-world load. It influences not just raw throughput and latency,
    but also how well the system scales, how much CPU and memory it consumes, and
    how predictable its behavior remains under pressure. In this article, we dissect
    three prominent options—raw TCP with custom framing, HTTP/2 via Go's built-in
    `net/http` package, and gRPC—and explore their performance characteristics through
    detailed benchmarks and practical scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，通信协议的选择决定了服务在现实负载下的交互方式。它不仅影响原始吞吐量和延迟，还影响系统的扩展性、CPU和内存消耗量，以及系统在压力下的行为预测性。在本文中，我们剖析了三种突出的选项——原始TCP与自定义帧结构、通过Go的内置`net/http`包实现的HTTP/2以及gRPC——并通过详细的基准测试和实际场景来探索它们的性能特征。
- en: Raw TCP with Custom Framing[¶](#raw-tcp-with-custom-framing "Permanent link")
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始TCP与自定义帧结构[¶](#raw-tcp-with-custom-framing "永久链接")
- en: 'Raw TCP provides maximum flexibility with virtually no protocol overhead, but
    that comes at a cost: all message boundaries, framing logic, and error handling
    must be implemented manually. Since TCP delivers a continuous byte stream with
    no inherent notion of messages, applications must explicitly define how to separate
    and interpret those bytes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 原始TCP提供了最大灵活性，几乎没有任何协议开销，但这需要付出代价：所有消息边界、帧逻辑和错误处理都必须手动实现。由于TCP交付的是一个连续的字节流，没有固有的消息概念，应用程序必须明确定义如何分离和解释这些字节。
- en: Custom Framing Protocol[¶](#custom-framing-protocol "Permanent link")
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义帧协议[¶](#custom-framing-protocol "永久链接")
- en: 'A common way to handle message boundaries over TCP is to use length-prefix
    framing: each message starts with a 4-byte header that tells the receiver how
    many bytes to read next. The length is encoded in big-endian format, following
    the standard network byte order, so it behaves consistently across different systems.
    This setup solves a core issue with TCP—while it guarantees reliable delivery,
    it doesn’t preserve message boundaries. Without knowing the size upfront, the
    receiver has no way to tell where one message ends and the next begins.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP上处理消息边界的一种常见方式是使用长度前缀帧：每个消息都以一个4字节的头部开始，告诉接收者下一个要读取多少字节。长度以大端格式编码，遵循标准网络字节顺序，因此在不同系统之间表现一致。这种设置解决了TCP的一个核心问题——虽然它保证了可靠交付，但它不保留消息边界。如果事先不知道大小，接收者就没有办法知道一个消息在哪里结束，下一个消息在哪里开始。
- en: 'TCP guarantees reliable, in-order delivery of bytes, but it does not preserve
    or indicate message boundaries. For example, if a client sends three logical messages:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TCP保证了字节可靠、有序的交付，但它不保留或指示消息边界。例如，如果客户端发送三个逻辑消息：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'the server may receive them as a continuous byte stream with arbitrary segmentations,
    such as:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能会将它们作为一个连续的字节流接收，具有任意分段，例如：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: TCP delivers a continuous stream of bytes with no built-in concept of where
    one message stops and another starts. This means the receiver can’t rely on read
    boundaries to infer message boundaries—what arrives might be a partial message,
    multiple messages concatenated, or an arbitrary slice of both. To make sense of
    structured data over such a stream, the application needs a framing strategy.
    Length-prefixing does this by including the size of the message up front, so the
    receiver knows exactly how many bytes to expect before starting to parse the payload.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TCP交付的是一个没有内置概念的消息开始和结束的连续字节流。这意味着接收者不能依赖于读取边界来推断消息边界——到达的可能是一个部分消息、多个消息连接在一起，或者任意两者的片段。为了在这样一个流上理解结构化数据，应用程序需要一个帧策略。长度前缀通过在前面包含消息的大小来实现这一点，这样接收者就知道在开始解析有效载荷之前应该期待多少字节。
- en: Protocol Structure[¶](#protocol-structure "Permanent link")
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协议结构[¶](#protocol-structure "永久链接")
- en: While length-prefixing is the most common and efficient framing strategy, there
    are other options depending on the use case. Other framing strategies exist, each
    with its own trade-offs in terms of simplicity, robustness, and flexibility. Delimiter-based
    framing uses a specific byte or sequence—like `\n` or `\0` to signal the end of
    a message. It’s easy to implement but fragile if the delimiter can appear in the
    payload. Fixed-size framing avoids ambiguity by making every message the same
    length, which simplifies parsing and memory allocation but doesn’t work well when
    message sizes vary. Self-describing formats like Protobuf or ASN.1 embed length
    and type information inside the payload itself, allowing for richer structure
    and evolution over time, but require more sophisticated parsing logic and schema
    awareness on both ends. Choosing the right approach depends on how much control
    you need, how predictable your data is, and how much complexity you’re willing
    to absorb.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然长度前缀是常见且高效的帧定界策略，但根据用例的不同，还有其他选项。存在其他帧定界策略，每种策略在简单性、健壮性和灵活性方面都有其自身的权衡。基于分隔符的帧定界使用特定的字节或序列（如
    `\n` 或 `\0`）来表示消息的结束。它易于实现，但如果分隔符可以出现在有效载荷中，则可能很脆弱。固定大小帧通过使每个消息具有相同的长度来避免歧义，从而简化了解析和内存分配，但当消息大小变化时则不太适用。像
    Protobuf 或 ASN.1 这样的自描述格式将长度和类型信息嵌入到有效载荷本身中，允许结构更丰富且随着时间的推移而演变，但需要在两端都具备更复杂的解析逻辑和模式意识。选择正确的方法取决于你需要多少控制，你的数据有多可预测，以及你愿意吸收多少复杂性。
- en: 'Each frame of length-prefixing implementation consists of:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀实现中的每个帧由以下部分组成：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Length:** A 4-byte unsigned integer encoded in big-endian format (network
    byte order), representing the number of bytes in the payload.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度：** 以大端格式（网络字节序）编码的4字节无符号整数，表示有效载荷中的字节数。'
- en: '**Payload:** Raw binary data of arbitrary length.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷：** 长度任意的原始二进制数据。'
- en: The use of `binary.BigEndian.PutUint32` ensures the frame length is encoded
    in a standardized format—most significant byte first. This is consistent with
    Internet protocol standards (1) , allowing for predictable decoding and reliable
    interoperation between heterogeneous systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `binary.BigEndian.PutUint32` 确保帧长度以标准格式编码——最高有效字节优先。这与互联网协议标准（1）一致，允许进行可预测的解码和异构系统之间的可靠互操作。
- en: Following the established convention of network byte order, which is defined
    as big-endian in [RFC 791, Section 3.1](https://datatracker.ietf.org/doc/html/rfc791#section-3.1)
    and used consistently in transport and application protocols such as TCP ([RFC
    793](https://datatracker.ietf.org/doc/html/rfc793)).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循定义在 [RFC 791，第3.1节](https://datatracker.ietf.org/doc/html/rfc791#section-3.1)
    并在TCP（[RFC 793](https://datatracker.ietf.org/doc/html/rfc793)）等传输和应用协议中一致使用的网络字节序惯例。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This approach is straightforward, performant, and predictable, yet it provides
    no built-in concurrency management, request multiplexing, or flow control—these
    must be explicitly managed by the developer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单、高效且可预测，但它不提供内置的并发管理、请求多路复用或流量控制——这些必须由开发者显式管理。
- en: Disadvantages[¶](#disadvantages "Permanent link")
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不利因素[¶](#disadvantages "永久链接")
- en: While the protocol is efficient and minimal, it lacks several features commonly
    found in more complex transport protocols. The lack of built-in framing features
    in raw TCP means that key responsibilities shift entirely to the application layer.
    There’s no support for multiplexing, so only one logical message can be in flight
    per connection unless additional coordination is built manually—pushing clients
    to open multiple connections to achieve parallelism. Flow control is also absent;
    unlike HTTP/2 or gRPC, there’s no way to signal backpressure, making it easy for
    a fast sender to overwhelm a slow receiver, potentially exhausting memory or triggering
    a crash. There’s no space for structured metadata like message types, compression
    flags, or trace context unless you embed them yourself into the payload format.
    And error handling is purely ad hoc—there’s no protocol-level mechanism for communicating
    faults, so malformed frames or incorrect lengths often lead to abrupt connection
    resets or inconsistent state.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该协议高效且最小化，但它缺少了更复杂传输协议中常见的几个功能。原始TCP中缺少内置的帧定界功能意味着关键责任完全转移到应用层。没有支持多路复用，所以每个连接只能有一个逻辑消息在传输，除非手动建立额外的协调——这促使客户端打开多个连接以实现并行性。流量控制也不存在；与HTTP/2或gRPC不同，没有信号反馈压力的方法，这使得快速发送者很容易压倒慢速接收者，可能耗尽内存或引发崩溃。除非你自己将它们嵌入到有效载荷格式中，否则没有空间用于结构化元数据，如消息类型、压缩标志或跟踪上下文。错误处理也是临时的——没有协议级别的机制来传达故障，因此格式错误的帧或长度不正确的帧通常会导致突然的连接重置或不一致的状态。
- en: These limitations might be manageable in tightly scoped, high-performance systems
    where both ends of the connection are under full control and the protocol behavior
    is well understood. In such environments, the minimal overhead and direct access
    to the wire can justify the trade-offs. But in broader production contexts—especially
    those involving multiple teams, evolving requirements, or untrusted clients—they
    introduce significant risk. Without strict validation, clear framing, and robust
    error handling, even small inconsistencies can lead to silent corruption, resource
    leaks, or hard-to-diagnose failures. Building on raw TCP demands both precise
    engineering and long-term maintenance discipline.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围紧密、性能高的系统中，这些限制可能是可管理的，因为连接的两端都完全受控，且对协议行为有很好的理解。在这样的环境中，最小化开销和直接访问网络线可以证明权衡是合理的。但在更广泛的生产环境中——特别是涉及多个团队、不断变化的需求或不可信客户端的情况下——它们会引入重大风险。如果没有严格的验证、清晰的框架和健壮的错误处理，即使是微小的不一致也可能导致无声的损坏、资源泄露或难以诊断的故障。基于原始TCP需要精确的工程和长期维护纪律。
- en: Performance Insights[¶](#performance-insights "Permanent link")
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能洞察[¶](#performance-insights "永久链接")
- en: '**Latency:** Lowest achievable due to minimal overhead; ideal for latency-critical
    scenarios like financial trading systems.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟:** 由于最小化开销，可达到最低可实现的延迟；非常适合对延迟敏感的场景，如金融交易系统。'
- en: '**Throughput:** Excellent, constrained only by network and application-layer
    handling.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量:** 极佳，仅受网络和应用层处理限制。'
- en: '**CPU/Memory Cost:** Very low, with negligible overhead from protocol management.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU/内存成本:** 非常低，协议管理的开销可以忽略不计。'
- en: HTTP/2 via net/http[¶](#http2-via-nethttp "Permanent link")
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过net/http使用HTTP/2[¶](#http2-via-nethttp "永久链接")
- en: 'HTTP/2 brought several protocol-level improvements over HTTP/1.1, including
    multiplexed streams over a single connection, header compression via HPACK, and
    support for server push. In Go, these features are integrated directly into the
    `net/http` standard library, which handles connection reuse, stream multiplexing,
    and concurrency without requiring manual intervention. Unlike raw TCP, where applications
    must explicitly define message boundaries, HTTP/2 defines them at the protocol
    level: each request and response is framed using structured `HEADERS` and `DATA`
    frames and explicitly closed with an `END_STREAM` flag. These frames are handled
    entirely within Go’s HTTP/2 implementation, so developers interact with complete,
    logically isolated messages using the standard `http.Request` and `http.ResponseWriter`
    interfaces. You don’t have to deal with byte streams or worry about where a message
    starts or ends—by the time a request hits your handler, it’s already been framed
    and parsed. When you write a response, the runtime takes care of wrapping it up
    and signaling completion. That frees you up to focus on the logic, not the plumbing,
    while still getting the performance benefits of HTTP/2 like multiplexing and connection
    reuse.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相比 HTTP/1.1，HTTP/2 在协议层面带来了多项改进，包括单个连接上的复用流、通过 HPACK 进行头部压缩以及支持服务器推送。在 Go 中，这些功能直接集成到
    `net/http` 标准库中，该库处理连接重用、流复用和并发，无需手动干预。与必须显式定义消息边界的原始 TCP 不同，HTTP/2 在协议层面定义了这些边界：每个请求和响应都使用结构化的
    `HEADERS` 和 `DATA` 帧进行封装，并使用 `END_STREAM` 标志显式关闭。这些帧完全由 Go 的 HTTP/2 实现处理，因此开发者可以使用标准的
    `http.Request` 和 `http.ResponseWriter` 接口与完整、逻辑上隔离的消息交互。你无需处理字节流或担心消息的起始或结束位置——当请求到达你的处理器时，它已经被封装并解析。当你编写响应时，运行时会负责将其封装并发出完成信号。这让你可以专注于逻辑，而不是管道，同时仍然获得
    HTTP/2 的性能优势，如复用和连接重用。
- en: Server Implementation[¶](#server-implementation "Permanent link")
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器实现[¶](#server-implementation "永久链接")
- en: Beyond framing and multiplexing, HTTP/2 brings a handful of practical advantages
    that make server code easier to write and faster to run. It handles connection
    reuse out of the box, applies flow control to avoid overwhelming either side,
    and compresses headers using `HPACK` to cut down on overhead. Go’s `net/http`
    stack takes care of all of this behind the scenes, so you get the benefits without
    needing to wire it up yourself. As a result, developers can build concurrent,
    efficient servers without managing low-level connection or stream state manually.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了框架和复用之外，HTTP/2 还带来了一系列实用的优势，这些优势使得服务器代码更容易编写和运行更快。它默认处理连接重用，应用流量控制以避免任何一方过载，并使用
    `HPACK` 压缩头部以减少开销。Go 的 `net/http` 栈在幕后处理所有这些，因此你无需自己配置即可获得这些好处。结果，开发者可以构建并发、高效的服务器，而无需手动管理低级别的连接或流状态。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Info
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Even this is not mentioned explisitly, this code serves HTTP/2 because it uses
    `ListenAndServeTLS`, which enables TLS-based communication. Go's `net/http` package
    automatically upgrades connections to HTTP/2 when a client supports it via ALPN
    (Application-Layer Protocol Negotiation) during the TLS handshake. Since Go 1.6,
    this upgrade is implicit—no extra configuration is required. The server transparently
    handles HTTP/2 requests while remaining compatible with HTTP/1.1 clients.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有明确提及，此代码也支持 HTTP/2，因为它使用了 `ListenAndServeTLS`，这启用了基于 TLS 的通信。Go 的 `net/http`
    包在 TLS 握手期间，如果客户端通过 ALPN（应用层协议协商）支持 HTTP/2，则会自动将连接升级到 HTTP/2。自 Go 1.6 以来，这种升级是隐式的——无需额外配置。服务器透明地处理
    HTTP/2 请求，同时保持与 HTTP/1.1 客户端的兼容性。
- en: HTTP/2’s multiplexing capability allows multiple independent streams to share
    a single TCP connection without blocking each other, which significantly improves
    connection reuse. This reduces the overhead of establishing and managing parallel
    connections, especially under high concurrency. As a result, latency is lower
    and throughput more consistent, even when multiple requests are in flight. These
    traits make HTTP/2 well-suited for general-purpose web services and internal APIs—places
    where predictable latency, efficient connection reuse, and solid concurrency handling
    carry more weight than raw protocol minimalism.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 的复用能力允许多个独立的流共享单个 TCP 连接而不相互阻塞，这显著提高了连接重用率。这减少了建立和管理并行连接的开销，尤其是在高并发情况下。因此，延迟更低，吞吐量更稳定，即使有多个请求正在传输也是如此。这些特性使
    HTTP/2 非常适合通用型网络服务和内部 API——在这些地方，可预测的延迟、高效的连接重用和良好的并发处理比原始协议的简约性更重要。
- en: Performance Insights[¶](#performance-insights_1 "Permanent link")
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能洞察[¶](#performance-insights_1 "永久链接")
- en: '**Latency:** Slightly higher than raw TCP because of framing and compression
    overhead, but stable and consistent thanks to multiplexing and persistent connections.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟：** 由于帧和压缩开销，略高于原始TCP，但得益于多路复用和持久连接，稳定且一致。'
- en: '**Throughput:** High under concurrent load; stream multiplexing and header
    compression help sustain performance without opening more sockets.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量：** 在并发负载下吞吐量高；流多路复用和头部压缩有助于维持性能，而无需打开更多套接字。'
- en: '**CPU/Memory Cost:** Moderate overhead, mostly due to header processing, TLS
    encryption, and flow control mechanisms.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU/内存开销：** 由于头部处理、TLS加密和流量控制机制，开销适中。'
- en: gRPC[¶](#grpc "Permanent link")
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC[¶](#grpc "永久链接")
- en: gRPC is a high-performance, contract-first RPC framework built on top of HTTP/2,
    designed for low-latency, cross-language communication between services. It combines
    streaming-capable transport with strongly typed APIs defined using Protocol Buffers
    (Protobuf), enabling compact, efficient message serialization and seamless interoperability
    across platforms. Unlike traditional HTTP APIs, where endpoints are loosely defined
    by URL patterns and free-form JSON, gRPC enforces strict interface contracts through
    `.proto` definitions, which serve as both schema and implementation spec. The
    gRPC toolchain generates client and server code for multiple languages, eliminating
    manual serialization, improving safety, and standardizing interactions across
    heterogeneous systems.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是一个基于HTTP/2构建的高性能、契约优先的RPC框架，旨在实现服务之间低延迟、跨语言的通信。它结合了具有流能力的传输和通过协议缓冲区（Protobuf）定义的强类型API，实现了紧凑、高效的消息序列化以及跨平台的无缝互操作性。与传统的HTTP
    API不同，后者通过URL模式和自由形式的JSON松散定义端点，gRPC通过`.proto`定义强制执行严格的接口契约，这些定义既作为模式也作为实现规范。gRPC工具链为多种语言生成客户端和服务器代码，消除了手动序列化，提高了安全性，并在异构系统之间标准化了交互。
- en: gRPC takes advantage of HTTP/2’s core features—stream multiplexing, flow control,
    and binary framing—to support both one-off RPC calls and full-duplex streaming,
    all with built-in backpressure. But it goes further than just transport. It bakes
    in support for deadlines, cancellation, structured metadata, and standardized
    error reporting, all of which help services communicate clearly and fail predictably.
    This makes gRPC a solid choice for internal APIs, service meshes, and performance-critical
    systems where you need efficiency, strong contracts, and reliable behavior under
    load.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC利用HTTP/2的核心特性——流多路复用、流量控制和二进制帧——来支持一次性RPC调用和全双工流，所有这些都有内置的背压。但它不仅仅局限于传输。它内置了对截止日期、取消、结构化元数据和标准化错误报告的支持，所有这些都有助于服务清晰沟通并可预测地失败。这使得gRPC成为内部API、服务网格和需要效率、强契约和负载下的可靠行为的性能关键系统的可靠选择。
- en: gRPC Service Definition[¶](#grpc-service-definition "Permanent link")
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC服务定义[¶](#grpc-service-definition "永久链接")
- en: 'A minimal `.proto` file example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化的`.proto`文件示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Generated Go stubs allow developers to easily implement the service:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Go存根允许开发者轻松实现服务：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Performance Insights[¶](#performance-insights_2 "Permanent link")
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能洞察[¶](#performance-insights_2 "永久链接")
- en: '**Latency:** Slightly higher than raw HTTP/2 due to additional serialization/deserialization
    steps, yet still performant for most scenarios.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟：** 由于额外的序列化和反序列化步骤，略高于原始HTTP/2，但在大多数场景下仍然表现良好。'
- en: '**Throughput:** High throughput thanks to efficient payload serialization (protobuf)
    and inherent HTTP/2 multiplexing capabilities.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量：** 由于有效的有效载荷序列化（protobuf）和内建的HTTP/2多路复用能力，吞吐量高。'
- en: '**CPU/Memory Cost:** Higher than HTTP/2 due to protobuf encoding overhead;
    memory consumption slightly increased due to temporary object allocations.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU/内存开销：** 由于protobuf编码开销，高于HTTP/2；由于临时对象分配，内存消耗略有增加。'
- en: Choosing the Right Protocol[¶](#choosing-the-right-protocol "Permanent link")
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的协议[¶](#choosing-the-right-protocol "永久链接")
- en: '**Internal APIs and microservices**: gRPC usually hits the sweet spot—it’s
    fast, strongly typed, and easy to work with once the tooling is in place.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部API和微服务：** 一旦工具就绪，gRPC通常能击中最佳平衡点——它快速、强类型，易于使用。'
- en: '**Low-latency systems and trading platforms:** Raw TCP with custom framing
    gives you the lowest overhead, but you’re on your own for everything else.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低延迟系统和交易平台：** 使用原始TCP和自定义帧提供最低的开销，但其他所有事情都需要你自己处理。'
- en: '**Public APIs or general web services:** HTTP/2 via net/http is a solid choice.
    You get connection reuse, multiplexing, and good performance without needing to
    pull in a full RPC stack.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共API或通用网络服务：** 通过net/http使用HTTP/2是一个可靠的选择。你将获得连接重用、多路复用和良好的性能，而无需引入完整的RPC堆栈。'
- en: 'Raw TCP gives you maximum control and the best performance on paper—but it
    also means building everything yourself: framing, flow control, error handling.
    HTTP/2 and gRPC trade some of that raw speed for built-in structure, better connection
    handling, and less code to maintain. What’s right depends entirely on where performance
    matters and how much complexity you want to own.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 原始TCP提供了最大的控制和纸面上的最佳性能——但这同时也意味着你需要自己构建一切：帧定界、流量控制、错误处理。HTTP/2和gRPC则牺牲了一些原始速度，以换取内置的结构、更好的连接处理和更少的维护代码。正确的选择完全取决于性能的重要性以及你愿意承担的复杂性。
