- en: 实际示例：使用 pprof 分析网络化 Go 应用程序¶
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/02-networking/gc-endpoint-profiling/](https://goperf.dev/02-networking/gc-endpoint-profiling/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 本节通过一个使用基准测试工具和运行时分析进行配置的演示应用程序，将分析概念应用于实际场景。它涵盖了识别性能瓶颈、解释火焰图以及在各种模拟网络条件下的系统行为分析。
  prefs: []
  type: TYPE_NORMAL
- en: 网络应用程序中的 CPU 分析[¶](#cpu-profiling-in-networked-apps "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 演示应用程序被有意设计得尽可能简单，以突出关键分析概念，而不引入不必要的复杂性。虽然演示中使用的代码和模式很基础，但在这里获得的分析见解高度适用于更复杂、生产级的应用程序。
  prefs: []
  type: TYPE_NORMAL
- en: 为了在负载下启用连续分析，我们通过专用 HTTP 端点公开 `pprof`：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: _ "net/http/pprof"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: // Start pprof in a separate goroutine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: go func() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Println("pprof listening on :6060")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err := http.ListenAndServe("localhost:6060", nil); err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Fatalf("pprof server error: %v", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="example"><summary>`net-app` 的完整源代码</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: // pprof-start
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: // pprof-end
  prefs: []
  type: TYPE_NORMAL
- en: '"flag"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"log"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"math/rand/v2"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"net/http"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // pprof-start
  prefs: []
  type: TYPE_NORMAL
- en: _ "net/http/pprof"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // pprof-end
  prefs: []
  type: TYPE_NORMAL
- en: '"os"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"os/signal"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"time"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // pprof-start
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: // pprof-end
  prefs: []
  type: TYPE_NORMAL
- en: var (
  prefs: []
  type: TYPE_NORMAL
- en: fastDelay   = flag.Duration("fast-delay", 0, "Fixed delay for fast handler (if
    any)")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: slowMin     = flag.Duration("slow-min", 1*time.Millisecond, "Minimum delay for
    slow handler")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: slowMax     = flag.Duration("slow-max", 300*time.Millisecond, "Maximum delay
    for slow handler")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: gcMinAlloc  = flag.Int("gc-min-alloc", 50, "Minimum number of allocations in
    GC heavy handler")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: gcMaxAlloc  = flag.Int("gc-max-alloc", 1000, "Maximum number of allocations
    in GC heavy handler")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func randRange(min, max int) int {
  prefs: []
  type: TYPE_NORMAL
- en: return rand.IntN(max-min) + min
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func fastHandler(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: if *fastDelay > 0 {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: time.Sleep(*fastDelay)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Fprintln(w, "fast response")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func slowHandler(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: delayRange := int((*slowMax - *slowMin) / time.Millisecond)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: delay := time.Duration(randRange(1, delayRange)) * time.Millisecond
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: time.Sleep(delay)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Fprintf(w, "slow response with delay %d ms\n", delay.Milliseconds())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // heavy-start
  prefs: []
  type: TYPE_NORMAL
- en: var longLivedData [][]byte
  prefs: []
  type: TYPE_NORMAL
- en: func gcHeavyHandler(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: numAllocs := randRange(*gcMinAlloc, *gcMaxAlloc)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var data [][]byte
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for i := 0; i < numAllocs; i++ {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Allocate 10KB slices. Occasionally retain a reference to simulate long-lived
    objects.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b := make([]byte, 1024*10)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: data = append(data, b)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if i%100 == 0 { // every 100 allocations, keep the data alive
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: longLivedData = append(longLivedData, b)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Fprintf(w, "allocated %d KB\n", len(data)*10)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // heavy-end
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: flag.Parse()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: http.HandleFunc("/fast", fastHandler)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: http.HandleFunc("/slow", slowHandler)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: http.HandleFunc("/gc", gcHeavyHandler)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // pprof-start
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: // Start pprof in a separate goroutine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: go func() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Println("pprof listening on :6060")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err := http.ListenAndServe("localhost:6060", nil); err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Fatalf("pprof server error: %v", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // pprof-end
  prefs: []
  type: TYPE_NORMAL
- en: // Create a server to allow for graceful shutdown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server := &http.Server{Addr: ":8080"}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: go func() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Println("HTTP server listening on :8080")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed
    {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Fatalf("HTTP server error: %v", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Graceful shutdown on interrupt signal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sigCh := make(chan os.Signal, 1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: signal.Notify(sigCh, os.Interrupt)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <-sigCh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Println("Shutting down server...")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if err := server.Shutdown(nil); err != nil {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Fatalf("Server Shutdown Failed:%+v", err)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Println("Server exited")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```</details>'
  prefs: []
  type: TYPE_NORMAL
- en: 下一步将是与被分析的应用程序建立连接并收集样本：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 交互式查看结果：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: 'go tool pprof -http=:7070 cpu.prof # (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 实际的 `cpu.prof` 路径可能类似于 `$HOME/pprof/pprof.net-app.samples.cpu.004.pb.gz`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 或者你可以将分析图保存为 `svg` 图像。
  prefs: []
  type: TYPE_NORMAL
- en: CPU 分析流程：在 `/gc` 端点上的负载[¶](#cpu-profiling-walkthrough-load-on-the-gc-endpoint
    "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 我们在针对 `/gc` 端点的 30 秒负载测试期间分析了应用程序，以查看在内存压力下的情况。这个处理程序被有意设计成触发分配并强制进行垃圾收集，这使得它成为观察压力下运行时行为的理想候选者。
  prefs: []
  type: TYPE_NORMAL
- en: 我们使用了 Go 的内置分析器来捕获 CPU 跟踪：
  prefs: []
  type: TYPE_NORMAL
- en: <details class="example"><summary>`/gc` 端点的 CPU 分析跟踪</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '![图片](../Images/7a6a813e3f186af7e41a21bebb8a53e9.png)(../img/cpu.prof.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: 这为我们提供了 3.02 秒的样本 CPU 活动，占 30 秒墙钟时间的 10.07%——这是一个有用的窗口，可以看到在压力下运行时和应用程序都在做什么。
  prefs: []
  type: TYPE_NORMAL
- en: 时间都花在哪里了[¶](#where-the-time-went "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP 栈占据表面[¶](#http-stack-dominates-the-surface "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 如预期，大部分 CPU 时间都花在了请求处理上：
  prefs: []
  type: TYPE_NORMAL
- en: '`http.(*conn).serve` 占了样本时间的近 58%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.serverHandler.ServeHTTP` 也非常突出'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这与我们持续保持稳定的流量是一致的。Go HTTP 栈正在做大部分工作，管理连接和分发请求。
  prefs: []
  type: TYPE_NORMAL
- en: 垃圾收集开销明显可见[¶](#garbage-collection-overhead-is-clearly-visible "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 大部分 CPU 时间都花在了垃圾收集器内部：
  prefs: []
  type: TYPE_NORMAL
- en: '`runtime.gcDrain`、`runtime.scanobject` 和 `runtime.gcBgMarkWorker` 都处于活动状态'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 结合内存相关函数如 `runtime.mallocgc`，这些大约占用了总 CPU 时间的 20%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这证实了 `gcHeavyHandler` 达到了其目标。我们关心的是这种类型的分配压力是否会泄漏到实际的处理程序中。如果它确实泄漏了，我们将在延迟和
    CPU 旋转中付出代价。
  prefs: []
  type: TYPE_NORMAL
- en: I/O 和系统调用占据很大一部分[¶](#i-o-和系统调用占据很大一部分 "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 我们还看到了高系统调用活动——特别是来自：
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall.syscall`（与 `poll`、`Read` 和 `Write` 链接）'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bufio.Writer.Flush` 和 `http.response.finishRequest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这些函数反映了将响应写回客户端的成本。对于简单的处理器，这是预期的。但如果你的处理器逻辑很轻量级，大部分时间都花在通过 TCP 刷新数据上，那么优化有效载荷或缓冲区策略是值得考虑的。
  prefs: []
  type: TYPE_NORMAL
- en: 调度器活动非平凡[¶](#调度器活动非平凡 "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 函数如 `runtime.schedule`、`mcall` 和 `findRunnable` 也出现在列表中。这些是 Go 运行时内部函数，负责管理
    goroutines。在高并发测试期间看到它们并不罕见——但如果它们占主导地位，通常表明存在过多的 goroutine 旋转或阻塞行为。
  prefs: []
  type: TYPE_NORMAL
- en: 内存分析：从 `/gc` 端点获取保留堆[¶](#内存分析：从-gc-端点获取保留堆 "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 我们还捕获了一个内存分析，以补充在猛击 `/gc` 端点时的 CPU 视图。此分析使用了 `inuse_space` 指标，它显示了在捕获时每个函数实际保留的堆内存量。
  prefs: []
  type: TYPE_NORMAL
- en: 我们通过以下方式触发了分析：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: go tool pprof -http=:7070 http://localhost:6060/debug/pprof/heap
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="example"><summary>对 `/gc` 端点的内存分析</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/8077552e3f37816c102f22210cddd49b.png)](../img/mem.prof.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: 在捕获时，应用程序保留了 649MB 的堆内存，其中几乎全部——99.46%——归因于单个函数：`gcHeavyHandler`。这是预期的。处理器通过在紧密循环中创建
    10KB 的切片来模拟分配压力。每 100 个切片被添加到一个全局变量中，以模拟长期内存。
  prefs: []
  type: TYPE_NORMAL
- en: 下面是处理器的操作：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: var longLivedData [][]byte
  prefs: []
  type: TYPE_NORMAL
- en: func gcHeavyHandler(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: numAllocs := randRange(*gcMinAlloc, *gcMaxAlloc)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var data [][]byte
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for i := 0; i < numAllocs; i++ {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Allocate 10KB slices. Occasionally retain a reference to simulate long-lived
    objects.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: b := make([]byte, 1024*10)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: data = append(data, b)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if i%100 == 0 { // every 100 allocations, keep the data alive
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: longLivedData = append(longLivedData, b)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Fprintf(w, "allocated %d KB\n", len(data)*10)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 火焰图证实了我们的预期：
  prefs: []
  type: TYPE_NORMAL
- en: '`gcHeavyHandler` 占用了几乎所有使用的内存。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 跟踪路径从 HTTP 连接开始，穿过 Go 路由堆栈，进入处理器逻辑。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 没有显著的分配来自其他地方——这是一个专注的、受控的内存压力场景。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这种类型的分析非常有价值，因为它揭示了内存中仍然保留的内容，而不仅仅是已分配的内容。这种视图通常对于诊断泄漏、保留缓冲区或遗忘的引用最为揭示。
  prefs: []
  type: TYPE_NORMAL
- en: 摘要：`/gc` 端点的 CPU 和内存分析[¶](#摘要：-gc-端点的-cpu-和内存分析 "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`/gc`端点是故意构建来模拟高分配压力和GC活动的。在负载下对处理程序进行性能分析，让我们对Go运行时在内存极限被推到时的行为有了清晰、专注的观察。'
  prefs: []
  type: TYPE_NORMAL
- en: 从**CPU分析**中，我们看到：
  prefs: []
  type: TYPE_NORMAL
- en: 如预期的那样，在持续负载的大部分时间都花在了HTTP处理程序路径上。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 几乎20%的CPU样本归因于内存分配和垃圾回收。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 系统调用活动很高，主要来自写入响应。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go调度器适度活跃，管理处理流量的并发goroutine。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 从**内存分析**中，我们捕捉到了649MB的活跃堆使用量，其中**99.46%由`gcHeavyHandler`保留**。这符合我们的预期：处理程序故意保留每100个10KB的分配来模拟长期数据。
  prefs: []
  type: TYPE_NORMAL
- en: 一起，这些分析让我们有信心，在合成压力下`/gc`端点表现如预期：
  prefs: []
  type: TYPE_NORMAL
- en: 它产生了有意义的CPU和内存负载。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 它揭示了持续分配和GC周期的成本。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 它提供了一个可预测的环境来测试优化或GC调整策略。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
