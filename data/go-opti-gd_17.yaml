- en: 高效的上下文管理
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/01-common-patterns/context/](https://goperf.dev/01-common-patterns/context/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 不论是处理 HTTP 请求、协调工作协程还是查询外部服务，通常都需要取消正在进行的操作或强制执行执行截止时间。Go 的 `context` 包正是为此而设计的——它提供了一种一致且线程安全的方式来管理操作生命周期、传播元数据和确保资源及时清理。
  prefs: []
  type: TYPE_NORMAL
- en: 为什么上下文很重要[¶](#why-context-matters "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go 提供了两个基本上下文构造函数：`context.Background()` 和 `context.TODO()`。
  prefs: []
  type: TYPE_NORMAL
- en: '`context.Background()` 是通常用于应用程序顶层（如 `main`、`init` 或服务器设置）的根上下文，其中没有可用的现有上下文。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.TODO()` 是当不清楚使用哪个上下文或周围代码尚未完全配置上下文传播时使用的占位符。它作为提醒，表明上下文逻辑需要在以后填充。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go 中的 `context` 包旨在携带截止时间、取消信号和其他请求范围值跨越 API 边界。它在需要协调和干净取消操作的同时并发的程序中特别有用。
  prefs: []
  type: TYPE_NORMAL
- en: 典型的上下文工作流程从程序的入口点或请求点开始——例如 HTTP 处理程序、主函数或 RPC 服务器。从那里，使用 `context.Background()`
    或 `context.TODO()` 创建一个基本上下文。然后可以使用以下构造函数扩展此上下文：
  prefs: []
  type: TYPE_NORMAL
- en: '`context.WithCancel(parent)` 用于创建可取消的上下文。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.WithTimeout(parent, duration)` 用于在指定时间后自动取消。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.WithDeadline(parent, time)` 用于在固定时间取消。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 使用 `context.WithValue(parent, key, value)` 来附加请求范围数据。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这些函数中的每一个都返回一个新的上下文，该上下文包装其父上下文。取消信号、截止时间和值会自动传播到调用堆栈。当一个上下文被取消——无论是手动还是超时——任何监听
    `<-ctx.Done()` 的 goroutine 或函数都会立即得到通知。
  prefs: []
  type: TYPE_NORMAL
- en: 通过显式通过函数参数传递上下文，可以避免隐藏依赖并获取对并发操作执行生命周期的细粒度控制。
  prefs: []
  type: TYPE_NORMAL
- en: 上下文使用的实际示例[¶](#practical-examples-of-context-usage "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 以下示例展示了 `context.Context` 如何在各种实际场景中实现更好的控制、可观察性和资源管理。
  prefs: []
  type: TYPE_NORMAL
- en: HTTP 服务器请求取消[¶](#http-server-request-cancellation "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 上下文帮助优雅地处理客户端提前断开连接时的取消操作。Go 中每个传入的 HTTP 请求都携带一个上下文，如果客户端关闭连接，则该上下文会被取消。通过检查
    `<-ctx.Done()`，可以提前退出而不是进行不必要的操作：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func handler(w http.ResponseWriter, req *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: ctx := req.Context()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: select {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case <-time.After(5 * time.Second):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Fprintln(w, "Response after delay")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case <-ctx.Done():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: log.Println("Client disconnected")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在这个例子中，处理程序等待模拟的延迟或取消。如果客户端在超时之前关闭连接，`ctx.Done()` 会被触发，允许处理程序在不写入响应的情况下进行清理。
  prefs: []
  type: TYPE_NORMAL
- en: 带超时的数据库操作[¶](#database-operations-with-timeouts "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 上下文提供了一种简单直接的方式来强制执行数据库查询的超时。许多驱动程序支持 `QueryContext` 或类似方法，这些方法尊重取消：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
  prefs: []
  type: TYPE_NORMAL
- en: defer cancel()
  prefs: []
  type: TYPE_NORMAL
- en: rows, err := db.QueryContext(ctx, "SELECT * FROM users")
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: log.Fatal(err)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: defer rows.Close()
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在这种情况下，如果数据库在两秒内没有响应，上下文会自动取消。查询会被终止，应用程序不会无限期地挂起。这有助于管理资源，并在高负载环境中避免级联故障。
  prefs: []
  type: TYPE_NORMAL
- en: 分布式跟踪中的请求 ID 传播[¶](#propagating-request-ids-for-distributed-tracing "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 上下文允许在不同层级的分布式系统中传递跟踪信息。例如，在边缘生成的请求 ID 可以附加到上下文中，并在整个应用程序中进行记录或使用。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: ctx := context.WithValue(context.Background(), "requestID", "12345")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: handleRequest(ctx)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func handleRequest(ctx context.Context) {
  prefs: []
  type: TYPE_NORMAL
- en: 'log.Printf("Handling request with ID: %v", ctx.Value("requestID"))'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在这个例子中，`WithValue` 将请求 ID 附加到上下文中。`handleRequest` 函数使用 `ctx.Value` 获取它，从而在不修改函数签名的情况下实现一致的日志记录和可观察性。这种方法在中间件、日志记录和跟踪管道中很常见。
  prefs: []
  type: TYPE_NORMAL
- en: 并发工作管理[¶](#concurrent-worker-management "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 上下文提供了对多个工作 goroutine 的控制。通过使用 `WithCancel`，您可以从一个中心点向所有工作进程传播停止信号。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: ctx, cancel := context.WithCancel(context.Background())
  prefs: []
  type: TYPE_NORMAL
- en: for i := 0; i < 10; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: go worker(ctx, i)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Cancel workers after some condition or signal
  prefs: []
  type: TYPE_NORMAL
- en: cancel()
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 每个工作函数都应该检查 `<-ctx.Done()`，并在上下文被取消时立即返回。这保持了系统的响应性，避免了悬挂的 goroutine，并允许并行工作的优雅终止。
  prefs: []
  type: TYPE_NORMAL
- en: CLI 工具中的优雅关闭[¶](#graceful-shutdown-in-cli-tools "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 在命令行应用程序或长时间运行的后台进程中，上下文简化了操作系统信号处理和优雅关闭。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
  prefs: []
  type: TYPE_NORMAL
- en: defer stop()
  prefs: []
  type: TYPE_NORMAL
- en: <-ctx.Done()
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Shutting down...")
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在这个模式中，`signal.NotifyContext` 返回一个在接收到中断信号（例如，Ctrl+C）时自动取消的上下文。监听 `<-ctx.Done()`
    允许应用程序执行清理并优雅地退出，而不是突然终止。
  prefs: []
  type: TYPE_NORMAL
- en: 流式传输和实时数据处理管道[¶](#streaming-and-real-time-data-pipelines "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 上下文非常适合协调像 Kafka 消费者、WebSocket 读取器或自定义 pub/sub 管道等流式系统中的读取器。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func streamData(ctx context.Context, ch <-chan Data) {
  prefs: []
  type: TYPE_NORMAL
- en: for {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: select {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case <-ctx.Done():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case data := <-ch:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: process(data)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在这里，该函数处理来自通道的传入数据。如果上下文被取消（例如，在关闭或超时期间），循环会中断，goroutine 会干净地退出。这使得系统对控制信号的反应更加灵敏，并且在负载下更容易管理。
  prefs: []
  type: TYPE_NORMAL
- en: 中间件和速率限制[¶](#middleware-and-rate-limiting "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 上下文通常用于中间件链中，以强制执行配额、跟踪请求或在层之间携带速率限制决策。在一个典型的HTTP堆栈中，中间件可以根据自定义逻辑（例如基于IP的速率限制或用户配额检查）确定是否允许请求，并将该决策附加到上下文中，以便下游处理器可以检查它。
  prefs: []
  type: TYPE_NORMAL
- en: 这里有一个简化的例子说明这可能如何工作：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func rateLimitMiddleware(next http.Handler) http.Handler {
  prefs: []
  type: TYPE_NORMAL
- en: return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Suppose this is the result of some rate-limiting logic
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: rateLimited := true // or false depending on logic
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Embed the result into the context
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ctx := context.WithValue(r.Context(), "rateLimited", rateLimited)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Pass the updated context to the next handler
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: next.ServeHTTP(w, r.WithContext(ctx))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 在下游处理器中，你可能可以这样检查该值：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func handler(w http.ResponseWriter, r *http.Request) {
  prefs: []
  type: TYPE_NORMAL
- en: ctx := r.Context()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if limited, ok := ctx.Value("rateLimited").(bool); ok && limited {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: http.Error(w, "Too many requests", http.StatusTooManyRequests)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Fprintln(w, "Request accepted")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这种模式避免了在中间件和处理器之间共享状态的需求。相反，上下文充当一个轻量级的通道，以安全且可组合的方式在请求管道的各个层之间传递元数据。
  prefs: []
  type: TYPE_NORMAL
- en: 基准测试影响[¶](#benchmarking-impact "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 当使用 `context.Context` 时，通常没有直接针对原始性能进行基准测试的内容。它的真正好处在于提高响应速度、避免不必要的计算，并实现干净的取消。影响体现在减少内存泄漏、减少卡住的goroutine以及更可预测的资源生命周期——这些指标最好通过实际的剖析和可观察性工具来观察。
  prefs: []
  type: TYPE_NORMAL
- en: 上下文使用最佳实践[¶](#best-practices-for-context-usage "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 总是显式传递 `context.Context`，通常作为函数的第一个参数。这使得上下文传播透明且可追踪，尤其是在API边界或服务层之间。不要在结构体字段或全局变量中存储上下文。这样做可能导致无意中重复使用过时的上下文，并使取消逻辑更难推理。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 仅使用1来传递请求范围元数据，而不是传递业务逻辑或应用程序状态。过度使用上下文进行通用数据存储会导致紧密耦合，并使测试和跟踪更困难。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 当需要时，检查 `ctx.Err()` 以区分 `context.Canceled` 和 `context.DeadlineExceeded`。这允许你的应用程序做出适当的响应——例如，区分用户发起的取消和超时。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 遵循这些实践有助于保持上下文使用可预测且符合惯例。
  prefs: []
  type: TYPE_NORMAL
