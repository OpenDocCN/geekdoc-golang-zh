- en: Go 网络内部结构
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/02-networking/networking-internals/](https://goperf.dev/02-networking/networking-internals/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go 的网络模型表面上看似简单——启动一个协程，接受连接，从中读取，并写入响应。但在这看似简单的背后，是一个高度优化和精细调校的运行时，它以最小的操作系统开销处理成千上万的连接。在这篇深入探讨中，我们将了解使这一切成为可能的各种机制：从协程和调度器到
    Go 如何与操作系统级别的轮询器（如 `epoll`、`kqueue` 和 IOCP）交互。
  prefs: []
  type: TYPE_NORMAL
- en: 协程和运行时调度器[¶](#goroutines-and-the-runtime-scheduler "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 协程是由 Go 运行时管理的轻量级用户空间线程。它们易于创建（只有几KB的堆栈），可以扩展到数百万。但它们并非魔法——它们依赖于运行时调度器来在有限的操作系统线程之间多路复用执行。
  prefs: []
  type: TYPE_NORMAL
- en: Go 的调度器基于 M:N 模型：
  prefs: []
  type: TYPE_NORMAL
- en: '**M (机器)**: 代表操作系统线程。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**G (协程)**: 代表实际的任务或协程。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P (处理器)**: 代表调度上下文（持有运行队列、缓存）。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 每个 P 可以使用一个 M 同时执行一个 G。P 的数量与 GOMAXPROCS 相等。如果一个协程在 I/O 上阻塞，另一个可运行的 G 可能会挂起并重用线程。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: stateDiagram-v2
  prefs: []
  type: TYPE_NORMAL
- en: '[*] --> New : goroutine declared'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New --> Runnable : go func() invoked'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Runnable --> Running : scheduled on an available P'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Running --> Waiting : blocking syscall, channel op, etc.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Waiting --> Runnable : event ready, rescheduled'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Running --> Terminated : function exits or panics'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Waiting --> Terminated : canceled or panicked'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Terminated --> [*]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: state "Go Scheduler\n(GOMAXPROCS = N)" as Scheduler {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*] --> P1'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*] --> P2'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*] --> PN'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P1 --> ScheduleGoroutine1 : pick from global/runq'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P2 --> ScheduleGoroutine2
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: PN --> ScheduleGoroutineN
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: note right of Runnable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ps (Processors) pick Runnable goroutines
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: based on availability up to GOMAXPROCS
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: end note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: note right of Scheduler
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GOMAXPROCS determines how many Ps
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: can execute goroutines in parallel.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: end note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 协程中的阻塞 I/O：实际发生了什么？[¶](#blocking-io-in-goroutines-what-really-happens "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 假设一个协程调用 `conn.Read()`。这看起来是阻塞的——但仅从协程的角度来看。内部，Go 的运行时拦截调用并使用一种称为 [netpoller](https://go.dev/src/runtime/netpoll.go)
    的机制。
  prefs: []
  type: TYPE_NORMAL
- en: 在基于 Unix 的系统上，Go 使用基于就绪的轮询（Linux 上的 `epoll`，macOS/BSD 上的 `kqueue`）。当一个协程执行 `read(fd)`
    这样的系统调用时，运行时会检查文件描述符是否就绪。如果不是：
  prefs: []
  type: TYPE_NORMAL
- en: 协程被挂起。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 文件描述符注册到轮询器。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 操作系统线程被释放以运行其他工作。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 当文件描述符准备好时，轮询器唤醒，运行时将协程标记为可运行。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: flowchart TD
  prefs: []
  type: TYPE_NORMAL
- en: 'A["Goroutine: conn.Read()"] --> B[netpoller checks FD]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B --> C{FD ready?}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C -- No --> D[Park goroutine]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D --> E[FD registered with epoll]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E --> F[epoll_wait blocks]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: F --> G[FD ready]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: G --> H[Wake goroutine]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: H --> I[Re-schedule]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C -- Yes --> H
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这个系统使 Go 能够使用少量线程并发地服务大量客户端，避免了传统线程-连接模型的开销。
  prefs: []
  type: TYPE_NORMAL
- en: '`net` 包的内部结构[¶](#internals-of-the-net-package "永久链接")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 让我们看看在 `net.Listen("tcp", ":8080")` 和 `conn.Read()` 后面发生了什么。
  prefs: []
  type: TYPE_NORMAL
- en: '`net.Listen` 调用 `net.ListenTCP`，它构建一个包装套接字的 `netFD` 结构体。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 通过 `syscall.SetNonblock(fd, true)` 将套接字标记为非阻塞。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netFD` 上的 `Accept` 和 `Read` 方法是在系统调用之上分层，但通过内部轮询器路由，并用逻辑包装以产生和恢复协程。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这里是一个调用链的大致图：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: flowchart TD
  prefs: []
  type: TYPE_NORMAL
- en: A[net.Listen] --> B[ListenTCP] --> C[listenFD]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C --> D["pollDesc (register with netpoll)"]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D --> E[runtime-integrated non-blocking syscall wrappers]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这种架构使得从开发者的角度来看，阻塞调用转换为与内核的非阻塞交互。
  prefs: []
  type: TYPE_NORMAL
- en: Netpoller：使用 Epoll/Kqueue/IOCP 进行轮询[¶](#the-netpoller-polling-with-epollkqueueiocp
    "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**netpoller** 是一个运行时子系统，它将低级轮询机制与 Go 的调度系统集成。每个 fd 都有一个相关的 `pollDesc`，这有助于协调
    goroutine 的挂起和恢复。'
  prefs: []
  type: TYPE_NORMAL
- en: 轮询器在一个专用的线程（或线程）中运行，该线程循环遍历 OS 等待原语：
  prefs: []
  type: TYPE_NORMAL
- en: '[epoll_wait](https://man7.org/linux/man-pages/man2/epoll_wait.2.html)（Linux）'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[kqueue](https://en.wikipedia.org/wiki/Kqueue)（macOS/BSD）'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IOCP](https://learn.microsoft.com/en-gb/windows/win32/fileio/i-o-completion-ports)（Windows）'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 当一个 I/O 事件触发时，轮询器找到相关的 `pollDesc`，识别出挂起的 goroutine，并将其放回运行队列中。
  prefs: []
  type: TYPE_NORMAL
- en: 在 Go 源代码中，相关文件包括：
  prefs: []
  type: TYPE_NORMAL
- en: '[runtime/netpoll_epoll.go](https://go.dev/src/runtime/netpoll_epoll.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[runtime/netpoll_kqueue.go](https://go.dev/src/runtime/netpoll_kqueue.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[runtime/netpoll_windows.go](https://go.dev/src/runtime/netpoll_windows.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go 轮询器基于就绪状态（不是基于完成状态，除了 Windows IOCP）。它处理：
  prefs: []
  type: TYPE_NORMAL
- en: fd 注册
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 在就绪时唤醒 goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 与运行队列的集成（P-局部或全局）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 示例：高性能 TCP Echo 服务器[¶](#example-high-performance-tcp-echo-server "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 让我们分解一个简单的 Go TCP Echo 服务器，并将每个部分映射到 Go 的内部网络和调度机制——包括 `netFD`、`poll.FD` 和 goroutine。
  prefs: []
  type: TYPE_NORMAL
- en: <details class="example"><summary>简单的 Echo 服务器源代码</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"bufio"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"net"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"time"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Start listening on TCP port 9000
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: listener, err := net.Listen("tcp", ":9000")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: panic(err) // Exit if the port can't be bound
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Println("Echo server listening on :9000")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Accept incoming connections in a loop
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conn, err := listener.Accept() // Accept new client connection
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt.Printf("Accept error: %v\n", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue // Skip this iteration on error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Handle the connection in a new goroutine for concurrency
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: go handle(conn)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // handle echoes data back to the client line-by-line
  prefs: []
  type: TYPE_NORMAL
- en: func handle(conn net.Conn) {
  prefs: []
  type: TYPE_NORMAL
- en: defer conn.Close() // Ensure connection is closed on exit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reader := bufio.NewReader(conn) // Wrap connection with buffered reader
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Set a read deadline to avoid hanging goroutines if client disappears
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: conn.SetReadDeadline(time.Now().Add(5 * 60 * time.Second)) // 5 minutes timeout
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Read input until newline character
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line, err := reader.ReadString('\n')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt.Printf("Connection closed: %v\n", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return // Exit on read error (e.g. client disconnect)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Echo the received line back to the client
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _, err = conn.Write([]byte(line))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt.Printf("Write error: %v\n", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return // Exit on write error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```</details>'
  prefs: []
  type: TYPE_NORMAL
- en: 导入和设置[¶](#imports-and-setup "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"bufio"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"net"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"time"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"sync/atomic"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**涉及的内部机制**：'
  prefs: []
  type: TYPE_NORMAL
- en: '`net` 包抽象了系统级网络。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 在底层：
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 使用 `netFD`（内部，私有结构）
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 使用 `poll.FD` 包装非阻塞 I/O
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 使用 OS 功能，如 `epoll`、`kqueue` 或 `IOCP` 进行事件通知
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 监听器设置[¶](#listener-setup "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: listener, err := net.Listen("tcp", ":9000")
  prefs: []
  type: TYPE_NORMAL
- en: if err != nil {
  prefs: []
  type: TYPE_NORMAL
- en: panic(err)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println("Echo server listening on :9000")
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**涉及的内部机制**：'
  prefs: []
  type: TYPE_NORMAL
- en: '`net.Listen()` 返回一个 `TCPListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 内部调用 `syscall.socket`、`bind`、`listen`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 将 `netFD` 与套接字关联
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 监听器使用 Go 的内部轮询器来启用非阻塞 `Accept`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 接受循环和 goroutine 调度[¶](#accept-loop-and-goroutine-scheduling "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: for {
  prefs: []
  type: TYPE_NORMAL
- en: conn, err := listener.Accept()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt.Printf("Accept error: %v\n", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: go handle(conn)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**涉及的内部机制**：'
  prefs: []
  type: TYPE_NORMAL
- en: '`listener.Accept()` → `netFD.Accept()` → `poll.FD.Accept()` → `syscall.accept`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 非阻塞，通过 Go 的轮询器 (`runtime_pollWait`) 等待
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go handle(conn)` 启动一个 **goroutine (G**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 调度到 **P**（处理器）
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P` 是 Go 的 M:N 调度器的一部分，由 `GOMAXPROCS` 管理'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 连接处理器[¶](#connection-handler "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func handle(conn net.Conn) {
  prefs: []
  type: TYPE_NORMAL
- en: defer conn.Close()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reader := bufio.NewReader(conn)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conn.SetReadDeadline(time.Now().Add(5 * 60 * time.Second))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: line, err := reader.ReadString('\n')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt.Printf("Connection closed: %v\n", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _, err = conn.Write([]byte(line))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if err != nil {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt.Printf("Write error: %v\n", err)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**涉及的内部机制**：'
  prefs: []
  type: TYPE_NORMAL
- en: '`bufio.NewReader(conn)` 包装 `net.Conn`，它由 `*TCPConn` 和 `netFD` 支持。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadString()` 在底层调用 `conn.Read()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netFD.Read()` → `poll.FD.Read()` → `syscall.Read()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 使用 `runtime_pollWait` 在数据未准备好时让goroutine让出
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetReadDeadline` 通过与运行时的网络轮询器集成来设置超时，以防止无限期阻塞。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conn.Write()` → `netFD.Write()` → `poll.FD.Write()` → `syscall.write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 内部流程图[¶](#internal-flow-diagram "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: sequenceDiagram
  prefs: []
  type: TYPE_NORMAL
- en: participant L as Listener Goroutine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: participant N as netFD
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: participant P as Go Poller
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: participant S as syscall layer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: participant H as Handler Goroutine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'L->>N: Accept()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'N->>P: Wait for connection (runtime_pollWait)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P->>S: syscall.accept'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'S-->>L: Return net.Conn'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'L->>H: go handle(conn)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'H->>N: Read()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'N->>P: Wait for data (runtime_pollWait)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P->>S: syscall.read'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'S-->>H: Return data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'H->>N: Write()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'N->>P: Check readiness'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P->>S: syscall.write'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'S-->>H: Confirm write'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 只要你这样做，这个模型就能很好地扩展：
  prefs: []
  type: TYPE_NORMAL
- en: 确保你的 `ulimit -n` 足够高
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 避免共享状态和竞争
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 为你的工作负载调整 `GOMAXPROCS`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 规模观察[¶](#observations-at-scale "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 随着连接的扩展（[在此处查看可能的样子](../gc-endpoint-profiling/))）：
  prefs: []
  type: TYPE_NORMAL
- en: 每个连接的内存和GC压力增加
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 频繁的goroutine上下文切换可能会引入延迟
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 协调通道、超时和背压增加了复杂性
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 一些缓解策略：
  prefs: []
  type: TYPE_NORMAL
- en: 使用 `sync.Pool` 进行缓冲区重用
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 最小化GC暂停（避免每个请求的分配）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 优先选择 `netpoll` 友好的设计（避免长时间CPU密集型goroutine）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Go的模型以操作系统级别的多路复用交换为用户空间调度和事件驱动的I/O协调。它不是万能的银弹——但使用得当，它提供了一个健壮的平台，用于构建可扩展的网络服务。理解这些内部机制有助于你避免常见陷阱，在正确的层进行优化，并构建在负载下表现可预测的系统。
  prefs: []
  type: TYPE_NORMAL
