["```go\n`func  handleWS(conn  *websocket.Conn)  {   for  {   _,  message,  err  :=  conn.ReadMessage()   if  err  !=  nil  {   break   }   process(message)   } }  http.HandleFunc(\"/ws\",  func(w  http.ResponseWriter,  r  *http.Request)  {   ws,  err  :=  upgrader.Upgrade(w,  r,  nil)   if  err  !=  nil  {   return   }   go  handleWS(ws) })` \n```", "```go\n`var  bufferPool  =  sync.Pool{   New:  func()  interface{}  {  return  make([]byte,  4096)  }, }  func  handle(conn  net.Conn)  {   buf  :=  bufferPool.Get().([]byte)   defer  bufferPool.Put(buf)    for  {   n,  err  :=  conn.Read(buf)   if  err  !=  nil  {   return   }    data  :=  make([]byte,  n)   copy(data,  buf[:n])   go  process(data)   } }` \n```", "```go\n`data  :=  buf[:n] go  process(data)` \n```", "```go\n`const  timeout  =  30  *  time.Second  func  handle(conn  net.Conn)  {   defer  conn.Close()    buffer  :=  make([]byte,  4096)  // 4 KB buffer; size depends on protocol and usage    for  {   conn.SetReadDeadline(time.Now().Add(timeout))   n,  err  :=  conn.Read(buffer)   if  err  !=  nil  {   if  netErr,  ok  :=  err.(net.Error);  ok  &&  netErr.Timeout()  {   return   }   return   }    conn.SetWriteDeadline(time.Now().Add(timeout))   _,  err  =  conn.Write(buffer[:n])   if  err  !=  nil  {   return   }   } }` \n```", "```go\n`func  handle(ctx  context.Context,  conn  net.Conn)  {   defer  conn.Close()    ctx,  cancel  :=  context.WithTimeout(ctx,  30*time.Second)   defer  cancel()    done  :=  make(chan  struct{})   go  func()  {   select  {   case  <-ctx.Done():   conn.Close()   case  <-done:   }   }()    // perform read/write as before   close(done) }` \n```", "```go\n`type  RateLimiter  struct  {   tokens  chan  struct{} }  func  NewRateLimiter(rate  int)  *RateLimiter  {   rl  :=  &RateLimiter{tokens:  make(chan  struct{},  rate)}   for  i  :=  0;  i  <  rate;  i++  {   rl.tokens  <-  struct{}{}   }   go  func()  {   ticker  :=  time.NewTicker(time.Second)   for  range  ticker.C  {   select  {   case  rl.tokens  <-  struct{}{}:   default:   }   }   }()   return  rl }  func  (rl  *RateLimiter)  Acquire()  {   <-rl.tokens }` \n```", "```go\n`rl  :=  NewRateLimiter(100) for  {   rl.Acquire()   // read/process/send }` \n```", "```go\n`type  framedConn  struct  {   net.Conn   mw  *bufio.Writer }  func  (f  *framedConn)  WriteFrame(data  []byte)  error  {   if  err  :=  binary.Write(f.mw,  binary.BigEndian,  uint32(len(data)));  err  !=  nil  {   return  err   }   if  _,  err  :=  f.mw.Write(data);  err  !=  nil  {   return  err   }   return  f.mw.Flush() }` \n```"]