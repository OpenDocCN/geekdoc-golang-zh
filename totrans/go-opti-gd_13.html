<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Immutable Data Sharing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Immutable Data Sharing</h1>
<blockquote>原文：<a href="https://goperf.dev/01-common-patterns/immutable-data/">https://goperf.dev/01-common-patterns/immutable-data/</a></blockquote>
                
                  


  
  



<p>One common source of slowdown in high-performance Go programs is the way shared data is accessed under concurrency. The usual tools—mutexes and channels—work well, but they’re not free. Mutexes can become choke points if many goroutines try to grab the same lock. Channels, while elegant for coordination, can introduce blocking and make control flow harder to reason about. Both require careful use: it’s easy to introduce subtle bugs or unexpected performance issues if synchronization isn’t tight.</p>
<p>A powerful alternative is immutable data sharing. Instead of protecting data with locks, you design your system so that shared data is never mutated after it's created. This minimizes contention and simplifies reasoning about your program.</p>
<h2 id="why-immutable-data">Why Immutable Data?</h2>
<p>Immutability brings several advantages to concurrent programs:</p>
<ul>
<li>No locks needed: Multiple goroutines can safely read immutable data without synchronization.</li>
<li>Easier reasoning: If data can't change, you avoid entire classes of race conditions.</li>
<li>Copy-on-write optimizations: You can create new versions of a structure without altering the original, which is useful for config reloading or versioning a state.</li>
</ul>
<h2 id="practical-example-shared-config">Practical Example: Shared Config</h2>
<p>Imagine you have a long-running service that periodically reloads its configuration from a disk or a remote source. Multiple goroutines read this configuration to make decisions.</p>
<p>Here's how immutable data helps:</p>
<h3 id="step-1-define-the-config-struct">Step 1: Define the Config Struct</h3>
<div class="highlight"><pre><span/><code><span class="c1">// config.go</span>
<span class="kd">type</span><span class="w"> </span><span class="nx">Config</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">LogLevel</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">Timeout</span><span class="w">  </span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="w">    </span><span class="nx">Features</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="w"> </span><span class="c1">// This needs attention!</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="step-2-ensure-deep-immutability">Step 2: Ensure Deep Immutability</h3>
<p>Maps and slices in Go are reference types. Even if the Config struct isn't changed, someone could accidentally mutate a shared map. To prevent this, we make defensive copies:</p>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">NewConfig</span><span class="p">(</span><span class="nx">logLevel</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">timeout</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span><span class="w"> </span><span class="nx">features</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">Config</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">copiedFeatures</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">features</span><span class="p">))</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">k</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">features</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">copiedFeatures</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">v</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">        </span><span class="nx">LogLevel</span><span class="p">:</span><span class="w"> </span><span class="nx">logLevel</span><span class="p">,</span>
<span class="w">        </span><span class="nx">Timeout</span><span class="p">:</span><span class="w">  </span><span class="nx">timeout</span><span class="p">,</span>
<span class="w">        </span><span class="nx">Features</span><span class="p">:</span><span class="w"> </span><span class="nx">copiedFeatures</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Now, every config instance is self-contained and safe to share.</p>
<h3 id="step-3-atomic-swapping">Step 3: Atomic Swapping</h3>
<p>Use <code>atomic.Value</code> to store and safely update the current config.</p>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">currentConfig</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">Config</span><span class="p">]</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">LoadInitialConfig</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cfg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">NewConfig</span><span class="p">(</span><span class="s">"info"</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">{</span><span class="s">"beta"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">})</span>
<span class="w">    </span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">GetConfig</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">Config</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Load</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>Now all goroutines can safely call <code>GetConfig()</code> with no locks. When the config is reloaded, you just <code>Store</code> a new immutable copy.</p>
<h3 id="step-4-using-it-in-handlers">Step 4: Using It in Handlers</h3>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">handler</span><span class="p">(</span><span class="nx">w</span><span class="w"> </span><span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">cfg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">GetConfig</span><span class="p">()</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">cfg</span><span class="p">.</span><span class="nx">Features</span><span class="p">[</span><span class="s">"beta"</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Enable beta path</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Use cfg.Timeout, cfg.LogLevel, etc.</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="practical-example-immutable-routing-table">Practical Example: Immutable Routing Table</h2>
<p>Suppose you're building a lightweight reverse proxy or API gateway and must route incoming requests based on path or host. The routing table is read thousands of times per second and updated only occasionally (e.g., from a config file or service discovery).</p>
<h3 id="step-1-define-route-structs">Step 1: Define Route Structs</h3>
<div class="highlight"><pre><span/><code><span class="kd">type</span><span class="w"> </span><span class="nx">Route</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">Path</span><span class="w">    </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">Backend</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">RoutingTable</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">Routes</span><span class="w"> </span><span class="p">[]</span><span class="nx">Route</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="step-2-build-immutable-version">Step 2: Build Immutable Version</h3>
<p>To ensure immutability, we deep-copy the slice of routes when constructing a new routing table.</p>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">NewRoutingTable</span><span class="p">(</span><span class="nx">routes</span><span class="w"> </span><span class="p">[]</span><span class="nx">Route</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">RoutingTable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">copied</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="nx">Route</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">routes</span><span class="p">))</span>
<span class="w">    </span><span class="nb">copy</span><span class="p">(</span><span class="nx">copied</span><span class="p">,</span><span class="w"> </span><span class="nx">routes</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">RoutingTable</span><span class="p">{</span><span class="nx">Routes</span><span class="p">:</span><span class="w"> </span><span class="nx">copied</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="step-3-store-it-atomically">Step 3: Store It Atomically</h3>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">currentRoutes</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">RoutingTable</span><span class="p">]</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">LoadInitialRoutes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">table</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">NewRoutingTable</span><span class="p">([]</span><span class="nx">Route</span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="nx">Path</span><span class="p">:</span><span class="w"> </span><span class="s">"/api"</span><span class="p">,</span><span class="w"> </span><span class="nx">Backend</span><span class="p">:</span><span class="w"> </span><span class="s">"http://api.internal"</span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="nx">Path</span><span class="p">:</span><span class="w"> </span><span class="s">"/admin"</span><span class="p">,</span><span class="w"> </span><span class="nx">Backend</span><span class="p">:</span><span class="w"> </span><span class="s">"http://admin.internal"</span><span class="p">},</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="nx">currentRoutes</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">table</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">GetRoutingTable</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">RoutingTable</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">currentRoutes</span><span class="p">.</span><span class="nx">Load</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="step-4-route-requests-concurrently">Step 4: Route Requests Concurrently</h3>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">routeRequest</span><span class="p">(</span><span class="nx">path</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">table</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">GetRoutingTable</span><span class="p">()</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">route</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">table</span><span class="p">.</span><span class="nx">Routes</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="w"> </span><span class="nx">route</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">route</span><span class="p">.</span><span class="nx">Backend</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">""</span>
<span class="p">}</span>
</code></pre></div>
<p>Now, your routing logic can scale safely under load with zero locking overhead.</p>
<h2 id="scaling-immutable-routing-tables">Scaling Immutable Routing Tables</h2>
<p>As systems grow, routing tables can expand to hundreds or even thousands of entries. While immutability brings clear benefits—safe concurrent access, predictable behavior—it becomes costly if every update means copying the entire structure. At some point, rebuilding the whole table for each minor change doesn’t scale.</p>
<p>To keep immutability without paying for full reconstruction on every update, the design needs to evolve. There are several ways to do this—each preserving the core benefits while reducing overhead.</p>
<h3 id="scenario-1-segmented-routing">Scenario 1: Segmented Routing</h3>
<p>Imagine a multi-tenant system where each customer has their own set of routing rules. Instead of one giant slice of routes, you can split them into a map:</p>
<div class="highlight"><pre><span/><code><span class="kd">type</span><span class="w"> </span><span class="nx">MultiTable</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">Tables</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">RoutingTable</span><span class="w"> </span><span class="c1">// key = tenant ID</span>
<span class="p">}</span>
</code></pre></div>
<p>If only customer "acme" updates their rules, you clone just that slice and update the map. Then you atomically swap in a new version of the full map. All other tenants continue using their existing, untouched routing tables.</p>
<p>This approach reduces memory pressure and speeds up updates without losing immutability. It also isolates blast radius: a broken rule set in one segment doesn’t affect others.</p>
<h3 id="scenario-2-indexed-routing-table">Scenario 2: Indexed Routing Table</h3>
<p>Let’s say your router matches by exact path, and lookup speed is critical. You can use a <code>map[string]RouteHandler</code> as an index:</p>
<div class="highlight"><pre><span/><code><span class="kd">type</span><span class="w"> </span><span class="nx">RouteIndex</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">RouteHandler</span>
</code></pre></div>
<p>When a new path is added, clone the current map, add the new route, and publish the new version. Because maps are shallow, this is fast for moderate numbers of routes. Reads are constant time, and updates are efficient because only a small part of the structure changes.</p>
<h3 id="scenario-3-hybrid-staging-and-publishing">Scenario 3: Hybrid Staging and Publishing</h3>
<p>Suppose you’re doing a batch update — maybe reading hundreds of routes from a database. Instead of rebuilding live, you keep a mutable staging area:</p>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">mu</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">stagingRoutes</span><span class="w"> </span><span class="p">[]</span><span class="nx">Route</span>
</code></pre></div>
<p>You load and manipulate data in staging under a mutex, then convert to an immutable <code>RoutingTable</code> and store it atomically. This lets you safely prepare complex changes without locking readers or affecting live traffic.</p>
<h2 id="benchmarking-impact">Benchmarking Impact</h2>
<p>Benchmarking immutable data sharing in real-world systems is difficult to do in a generic, meaningful way. Factors like structure size, read/write ratio, and memory layout all heavily influence results.</p>
<p>Rather than presenting artificial benchmarks here, we recommend reviewing the results in the <a href="../atomic-ops/#benchmarking-impact">Atomic Operations and Synchronization Primitives</a> article. Those benchmarks clearly illustrate the potential performance benefits of using atomic.Value over traditional synchronization primitives like sync.RWMutex, especially in highly concurrent read scenarios.</p>
<h2 id="when-to-use-this-pattern">When to Use This Pattern</h2>
<p><span class="twemoji"><svg viewbox="0 0 24 24"><path d="M20 12a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8c.76 0 1.5.11 2.2.31l1.57-1.57A9.8 9.8 0 0 0 12 2 10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10M7.91 10.08 6.5 11.5 11 16 21 6l-1.41-1.42L11 13.17z"/></svg></span> Immutable data sharing is ideal when:</p>
<ul>
<li>
<p>The data is read-heavy and write-light (e.g., configuration, feature flags, global mappings). This works well because the cost of creating new immutable versions is amortized over many reads, and avoiding locks provides a performance boost.</p>
</li>
<li>
<p>You want to minimize locking without sacrificing safety. By sharing read-only data, you remove the need for mutexes or coordination, reducing the chances of deadlocks or race conditions.</p>
</li>
<li>
<p>You can tolerate minor delays between update and read (eventual consistency). Since data updates are not coordinated with readers, there might be a small delay before all goroutines see the new version. If exact timing isn't critical, this tradeoff simplifies your concurrency model.</p>
</li>
</ul>
<p><span class="twemoji"><svg viewbox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M448 128H270.4c1 5.2 1.6 10.5 1.6 16v16h176c8.8 0 16-7.2 16-16s-7.2-16-16-16m-224 16c0-17.7-14.3-32-32-32h-24c-66.3 0-120 53.7-120 120v48c0 52.5 33.7 97.1 80.7 113.4-.5-3.1-.7-6.2-.7-9.4 0-20 9.2-37.9 23.6-49.7-4.9-9-7.6-19.4-7.6-30.3 0-15.1 5.3-29 14-40-8.8-11-14-24.9-14-40v-40c0-13.3 10.7-24 24-24s24 10.7 24 24v40c0 8.8 7.2 16 16 16s16-7.2 16-16zm-32-80c18 0 34.6 6 48 16h208c35.3 0 64 28.7 64 64s-28.7 64-64 64h-82c1.3 5.1 2 10.5 2 16 0 25.3-14.7 47.2-36 57.6 2.6 7 4 14.5 4 22.4 0 20-9.2 37.9-23.6 49.7 4.9 9 7.6 19.4 7.6 30.3 0 35.3-28.7 64-64 64h-88C75.2 448 0 372.8 0 280v-48C0 139.2 75.2 64 168 64zm64 336c8.8 0 16-7.2 16-16s-7.2-16-16-16h-64c-8.8 0-16 7.2-16 16s7.2 16 16 16zm16-176c0 5.5-.7 10.9-2 16h34c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zm-24 64h-40c-8.8 0-16 7.2-16 16s7.2 16 16 16h64c8.8 0 16-7.2 16-16s-7.2-16-16-16z"/></svg></span> It’s less suitable when updates must be transactional across multiple pieces of data or happen frequently. In those cases, the cost of repeated copying or lack of coordination can outweigh the benefits.</p>









  




                
                  
</body>
</html>