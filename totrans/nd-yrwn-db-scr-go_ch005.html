<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch005.xhtml</title>
  <style>
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #fffadf; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #008080; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #556622; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #008080; font-style: italic; } /* Comment */
    code span.cv { color: #008080; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #008080; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #008080; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="btree-node-and-insertion" class="level1">
<h1>04. B+Tree Node and Insertion</h1>
<section id="design-btree-nodes" class="level2">
<h2>4.1 Design B+tree nodes</h2>
<section id="what-we-will-do" class="level3">
<h3>What we will do</h3>
<p>The first big step is just the B+tree data structures, other DB concerns will be covered in later chapters. We’ll do it from the bottom up.</p>
<ol type="1">
<li>Design a node format that contains all the necessary bits.</li>
<li>Manipulate nodes in a copy-on-write fashion (insert and delete keys).</li>
<li>Split and merge nodes.</li>
<li>Tree insertion and deletion.</li>
</ol>
</section>
<section id="the-node-format" class="level3">
<h3>The node format</h3>
<p>All B+tree nodes are the same size for later use of the free list. Although we won’t deal with disk data at this point, a concrete node format is needed because it decides the node size in bytes and <em>when to split a node</em>.</p>
<p>A node includes:</p>
<ol type="1">
<li>A fixed-size header, which contains:
<ul>
<li>The type of node (leaf or internal).</li>
<li>The number of keys.</li>
</ul></li>
<li>A list of pointers to child nodes for internal nodes.</li>
<li>A list of KV pairs.</li>
<li>A list of offsets to KVs, which can be used to binary search KVs.</li>
</ol>
<pre><code>| type | nkeys |  pointers  |   offsets  | key-values | unused |
|  2B  |   2B  | nkeys * 8B | nkeys * 2B |     ...    |        |</code></pre>
<p>This is the format of each KV pair. Lengths followed by data.</p>
<pre><code>| klen | vlen | key | val |
|  2B  |  2B  | ... | ... |</code></pre>
</section>
<section id="simplifications-and-limits" class="level3">
<h3>Simplifications and limits</h3>
<p>Our goal is to learn the basics, not to create a real DB. So some simplifications are made.</p>
<p>The same format is used for both leaf nodes and internal nodes. This wastes some space: leaf nodes don’t need pointers and internal nodes don’t need values.</p>
<p>An internal node of <span class="math inline"><em>n</em></span> branches contains <span class="math inline"><em>n</em></span> keys, each key is duplicated from the minimum key of the corresponding subtree. However, only <span class="math inline"><em>n</em> − 1</span> keys are needed for <span class="math inline"><em>n</em></span> branches, as you’ll see in other B-tree introductions. The extra key makes the visualization easier.</p>
<p>We’ll set the node size to 4K, which is the typical OS page size. However, keys and values can be arbitrarily large, exceeding a single node. There should be a way to store large KVs outside of nodes, or to make the node size variable. This problem is solvable, but not fundamental. So we’ll skip it by limiting the KV size so that they always fit inside a node.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> HEADER <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> BTREE_PAGE_SIZE <span class="op">=</span> <span class="dv">4096</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> BTREE_MAX_KEY_SIZE <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> BTREE_MAX_VAL_SIZE <span class="op">=</span> <span class="dv">3000</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    node1max <span class="op">:=</span> HEADER <span class="op">+</span> <span class="dv">8</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">+</span> BTREE_MAX_KEY_SIZE <span class="op">+</span> BTREE_MAX_VAL_SIZE</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>node1max <span class="op">&lt;=</span> BTREE_PAGE_SIZE<span class="op">)</span> <span class="co">// maximum KV</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The key size limit also ensures that an internal node can always host 2 keys.</p>
</section>
<section id="in-memory-data-types" class="level3">
<h3>In-memory data types</h3>
<p>In our code, a node is just a chunk of bytes interpreted by this format. Moving data from memory to disk is simpler without a serialization step.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> BNode <span class="op">[]</span><span class="dt">byte</span> <span class="co">// can be dumped to the disk</span></span></code></pre></div>
</section>
<section id="decouple-data-structure-from-io" class="level3">
<h3>Decouple data structure from IO</h3>
<p>Space allocation/deallocation is required for both in-memory and on-disk data structures. We can abstract this away with callbacks, which is a boundary between the data structure and the rest of the DB.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> BTree <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// pointer (a nonzero page number)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    root <span class="dt">uint64</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// callbacks for managing on-disk pages</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    get <span class="kw">func</span><span class="op">(</span><span class="dt">uint64</span><span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span> <span class="co">// dereference a pointer</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span> <span class="kw">func</span><span class="op">([]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">uint64</span> <span class="co">// allocate a new page</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    del <span class="kw">func</span><span class="op">(</span><span class="dt">uint64</span><span class="op">)</span>        <span class="co">// deallocate a page</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For an on-disk B+tree, the database file is an array of pages (nodes) referenced by page numbers (pointers). We’ll implement these callbacks as follows:</p>
<ul>
<li><code>get</code> reads a page from disk.</li>
<li><code>new</code> allocates and writes a new page (copy-on-write).</li>
<li><code>del</code> deallocates a page.</li>
</ul>
<p>We can use fake callbacks (mocks) to test the data structure in memory without the rest of the DB.</p>
</section>
</section>
<section id="decode-the-node-format" class="level2">
<h2>4.2 Decode the node format</h2>
<p>Since the node type is just a chunk of bytes, we’ll define some helper functions to access it.</p>
<pre><code>| type | nkeys |  pointers  |   offsets  | key-values | unused |
|  2B  |   2B  | nkeys * 8B | nkeys * 2B |     ...    |        |

| klen | vlen | key | val |
|  2B  |  2B  | ... | ... |</code></pre>
<section id="header" class="level3">
<h3>Header</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="op">(</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    BNODE_NODE <span class="op">=</span> <span class="dv">1</span> <span class="co">// internal nodes without values</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    BNODE_LEAF <span class="op">=</span> <span class="dv">2</span> <span class="co">// leaf nodes with values</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> btype<span class="op">()</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> binary<span class="op">.</span>LittleEndian<span class="op">.</span>Uint16<span class="op">(</span>node<span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">2</span><span class="op">])</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> nkeys<span class="op">()</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> binary<span class="op">.</span>LittleEndian<span class="op">.</span>Uint16<span class="op">(</span>node<span class="op">[</span><span class="dv">2</span><span class="op">:</span><span class="dv">4</span><span class="op">])</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> setHeader<span class="op">(</span>btype <span class="dt">uint16</span><span class="op">,</span> nkeys <span class="dt">uint16</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>LittleEndian<span class="op">.</span>PutUint16<span class="op">(</span>node<span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">2</span><span class="op">],</span> btype<span class="op">)</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>LittleEndian<span class="op">.</span>PutUint16<span class="op">(</span>node<span class="op">[</span><span class="dv">2</span><span class="op">:</span><span class="dv">4</span><span class="op">],</span> nkeys<span class="op">)</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="child-pointers" class="level3">
<h3>Child pointers</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// pointers</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> getPtr<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">)</span> <span class="dt">uint64</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>idx <span class="op">&lt;</span> node<span class="op">.</span>nkeys<span class="op">())</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">:=</span> HEADER <span class="op">+</span> <span class="dv">8</span><span class="op">*</span>idx</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> binary<span class="op">.</span>LittleEndian<span class="op">.</span>Uint64<span class="op">(</span>node<span class="op">[</span>pos<span class="op">:])</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> setPtr<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">,</span> val <span class="dt">uint64</span><span class="op">)</span></span></code></pre></div>
</section>
<section id="kv-offsets-and-pairs" class="level3">
<h3>KV offsets and pairs</h3>
<p>The format packs everything back to back. Finding the nth KV can be done by reading each KV pair one by one. To make it easier, we have included an offset list to locate the nth KV in <span class="math inline"><em>O</em>(1)</span>. This also allows binary searches within a node.</p>
<p>Each offset is the <em>end</em> of the KV pair relative to the start of the 1st KV. The start offset of the 1st KV is just 0, so we use the end offset instead, which is the start offset of the next KV.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// offset list</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> offsetPos<span class="op">(</span>node BNode<span class="op">,</span> idx <span class="dt">uint16</span><span class="op">)</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span><span class="dv">1</span> <span class="op">&lt;=</span> idx <span class="op">&amp;&amp;</span> idx <span class="op">&lt;=</span> node<span class="op">.</span>nkeys<span class="op">())</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> HEADER <span class="op">+</span> <span class="dv">8</span><span class="op">*</span>node<span class="op">.</span>nkeys<span class="op">()</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*(</span>idx<span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> getOffset<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">)</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> binary<span class="op">.</span>LittleEndian<span class="op">.</span>Uint16<span class="op">(</span>node<span class="op">[</span>offsetPos<span class="op">(</span>node<span class="op">,</span> idx<span class="op">):])</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> setOffset<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">,</span> offset <span class="dt">uint16</span><span class="op">)</span></span></code></pre></div>
<p><code>kvPos</code> returns the position of the nth KV pair relative to the whole node.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// key-values</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> kvPos<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">)</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>idx <span class="op">&lt;=</span> node<span class="op">.</span>nkeys<span class="op">())</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> HEADER <span class="op">+</span> <span class="dv">8</span><span class="op">*</span>node<span class="op">.</span>nkeys<span class="op">()</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>node<span class="op">.</span>nkeys<span class="op">()</span> <span class="op">+</span> node<span class="op">.</span>getOffset<span class="op">(</span>idx<span class="op">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> getKey<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>idx <span class="op">&lt;</span> node<span class="op">.</span>nkeys<span class="op">())</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">:=</span> node<span class="op">.</span>kvPos<span class="op">(</span>idx<span class="op">)</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    klen <span class="op">:=</span> binary<span class="op">.</span>LittleEndian<span class="op">.</span>Uint16<span class="op">(</span>node<span class="op">[</span>pos<span class="op">:])</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node<span class="op">[</span>pos<span class="op">+</span><span class="dv">4</span><span class="op">:][:</span>klen<span class="op">]</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> getVal<span class="op">(</span>idx <span class="dt">uint16</span><span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span></span></code></pre></div>
<p>It also conveniently returns the node size (used space) with an off-by-one lookup.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// node size in bytes</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>node BNode<span class="op">)</span> nbytes<span class="op">()</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node<span class="op">.</span>kvPos<span class="op">(</span>node<span class="op">.</span>nkeys<span class="op">())</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="kv-lookups-within-a-node" class="level3">
<h3>KV lookups within a node</h3>
<p>The “seek” operation is used for both range and point queries. So they are fundamentally the same.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// returns the first kid node whose range intersects the key. (kid[i] &lt;= key)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">TODO</span><span class="co">: binary search</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeLookupLE<span class="op">(</span>node BNode<span class="op">,</span> key <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">uint16</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    nkeys <span class="op">:=</span> node<span class="op">.</span>nkeys<span class="op">()</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    found <span class="op">:=</span> <span class="dt">uint16</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the first key is a copy from the parent node,</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// thus it&#39;s always less than or equal to the key.</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dt">uint16</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span> i <span class="op">&lt;</span> nkeys<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        cmp <span class="op">:=</span> bytes<span class="op">.</span>Compare<span class="op">(</span>node<span class="op">.</span>getKey<span class="op">(</span>i<span class="op">),</span> key<span class="op">)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cmp <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            found <span class="op">=</span> i</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cmp <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> found</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function is called <code>nodeLookupLE</code> because it uses the <strong>L</strong>ess-than-or-<strong>E</strong>qual operator. For point queries, we should use the equal operator instead, which is a step we can add later.</p>
</section>
</section>
<section id="update-btree-nodes" class="level2">
<h2>4.2 Update B+tree nodes</h2>
<section id="insert-into-leaf-nodes" class="level3">
<h3>Insert into leaf nodes</h3>
<p>Let’s consider inserting a key into a leaf node. The 1st step is to use <code>nodeLookupLE</code> to get the insert position. Then copy everything to a new node with the extra key. That’s copy-on-write.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// add a new key to a leaf node</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> leafInsert<span class="op">(</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span> BNode<span class="op">,</span> old BNode<span class="op">,</span> idx <span class="dt">uint16</span><span class="op">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    key <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> val <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span><span class="op">.</span>setHeader<span class="op">(</span>BNODE_LEAF<span class="op">,</span> old<span class="op">.</span>nkeys<span class="op">()+</span><span class="dv">1</span><span class="op">)</span> <span class="co">// setup the header</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    nodeAppendRange<span class="op">(</span><span class="bu">new</span><span class="op">,</span> old<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> idx<span class="op">)</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    nodeAppendKV<span class="op">(</span><span class="bu">new</span><span class="op">,</span> idx<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    nodeAppendRange<span class="op">(</span><span class="bu">new</span><span class="op">,</span> old<span class="op">,</span> idx<span class="op">+</span><span class="dv">1</span><span class="op">,</span> idx<span class="op">,</span> old<span class="op">.</span>nkeys<span class="op">()-</span>idx<span class="op">)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="node-copying-functions" class="level3">
<h3>Node copying functions</h3>
<p><code>nodeAppendRange</code> copies a range of KVs and <code>nodeAppendKV</code> copies a KV pair. This must be done in order because these functions rely on the previous offset.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// copy a KV into the position</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeAppendKV<span class="op">(</span><span class="bu">new</span> BNode<span class="op">,</span> idx <span class="dt">uint16</span><span class="op">,</span> ptr <span class="dt">uint64</span><span class="op">,</span> key <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> val <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ptrs</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span><span class="op">.</span>setPtr<span class="op">(</span>idx<span class="op">,</span> ptr<span class="op">)</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// KVs</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">:=</span> <span class="bu">new</span><span class="op">.</span>kvPos<span class="op">(</span>idx<span class="op">)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>LittleEndian<span class="op">.</span>PutUint16<span class="op">(</span><span class="bu">new</span><span class="op">[</span>pos<span class="op">+</span><span class="dv">0</span><span class="op">:],</span> <span class="dt">uint16</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>key<span class="op">)))</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>LittleEndian<span class="op">.</span>PutUint16<span class="op">(</span><span class="bu">new</span><span class="op">[</span>pos<span class="op">+</span><span class="dv">2</span><span class="op">:],</span> <span class="dt">uint16</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>val<span class="op">)))</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">copy</span><span class="op">(</span><span class="bu">new</span><span class="op">[</span>pos<span class="op">+</span><span class="dv">4</span><span class="op">:],</span> key<span class="op">)</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">copy</span><span class="op">(</span><span class="bu">new</span><span class="op">[</span>pos<span class="op">+</span><span class="dv">4</span><span class="op">+</span><span class="dt">uint16</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>key<span class="op">)):],</span> val<span class="op">)</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the offset of the next key</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span><span class="op">.</span>setOffset<span class="op">(</span>idx<span class="op">+</span><span class="dv">1</span><span class="op">,</span> <span class="bu">new</span><span class="op">.</span>getOffset<span class="op">(</span>idx<span class="op">)+</span><span class="dv">4</span><span class="op">+</span><span class="dt">uint16</span><span class="op">((</span><span class="bu">len</span><span class="op">(</span>key<span class="op">)+</span><span class="bu">len</span><span class="op">(</span>val<span class="op">))))</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">// copy multiple KVs into the position from the old node</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeAppendRange<span class="op">(</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span> BNode<span class="op">,</span> old BNode<span class="op">,</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    dstNew <span class="dt">uint16</span><span class="op">,</span> srcOld <span class="dt">uint16</span><span class="op">,</span> n <span class="dt">uint16</span><span class="op">,</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
</section>
<section id="update-internal-nodes" class="level3">
<h3>Update internal nodes</h3>
<p>For internal nodes, the link to the child node is always updated with the copy-on-write scheme, which can become multiple links if the child node is split.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// replace a link with one or multiple links</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeReplaceKidN<span class="op">(</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">*</span>BTree<span class="op">,</span> <span class="bu">new</span> BNode<span class="op">,</span> old BNode<span class="op">,</span> idx <span class="dt">uint16</span><span class="op">,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    kids <span class="op">...</span>BNode<span class="op">,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    inc <span class="op">:=</span> <span class="dt">uint16</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>kids<span class="op">))</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span><span class="op">.</span>setHeader<span class="op">(</span>BNODE_NODE<span class="op">,</span> old<span class="op">.</span>nkeys<span class="op">()+</span>inc<span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    nodeAppendRange<span class="op">(</span><span class="bu">new</span><span class="op">,</span> old<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> idx<span class="op">)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i<span class="op">,</span> node <span class="op">:=</span> <span class="kw">range</span> kids <span class="op">{</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        nodeAppendKV<span class="op">(</span><span class="bu">new</span><span class="op">,</span> idx<span class="op">+</span><span class="dt">uint16</span><span class="op">(</span>i<span class="op">),</span> tree<span class="op">.</span><span class="bu">new</span><span class="op">(</span>node<span class="op">),</span> node<span class="op">.</span>getKey<span class="op">(</span><span class="dv">0</span><span class="op">),</span> <span class="ot">nil</span><span class="op">)</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                ^position      ^pointer        ^key            ^val</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    nodeAppendRange<span class="op">(</span><span class="bu">new</span><span class="op">,</span> old<span class="op">,</span> idx<span class="op">+</span>inc<span class="op">,</span> idx<span class="op">+</span><span class="dv">1</span><span class="op">,</span> old<span class="op">.</span>nkeys<span class="op">()-(</span>idx<span class="op">+</span><span class="dv">1</span><span class="op">))</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the <code>tree.new</code> callback is used to allocate the child nodes.</p>
</section>
</section>
<section id="split-btree-nodes" class="level2">
<h2>4.3 Split B+tree nodes</h2>
<p>Due to the size limits we imposed, a node can host at least 1 KV pair. In the worst case, an oversized node will be split into 3 nodes, with a large KV in the middle. So we may have to split it 2 times.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// split a oversized node into 2 so that the 2nd node always fits on a page</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeSplit2<span class="op">(</span>left BNode<span class="op">,</span> right BNode<span class="op">,</span> old BNode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// code omitted...</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">// split a node if it&#39;s too big. the results are 1~3 nodes.</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeSplit3<span class="op">(</span>old BNode<span class="op">)</span> <span class="op">(</span><span class="dt">uint16</span><span class="op">,</span> <span class="op">[</span><span class="dv">3</span><span class="op">]</span>BNode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> old<span class="op">.</span>nbytes<span class="op">()</span> <span class="op">&lt;=</span> BTREE_PAGE_SIZE <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        old <span class="op">=</span> old<span class="op">[:</span>BTREE_PAGE_SIZE<span class="op">]</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">,</span> <span class="op">[</span><span class="dv">3</span><span class="op">]</span>BNode<span class="op">{</span>old<span class="op">}</span> <span class="co">// not split</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    left <span class="op">:=</span> BNode<span class="op">(</span><span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> <span class="dv">2</span><span class="op">*</span>BTREE_PAGE_SIZE<span class="op">))</span> <span class="co">// might be split later</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    right <span class="op">:=</span> BNode<span class="op">(</span><span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> BTREE_PAGE_SIZE<span class="op">))</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    nodeSplit2<span class="op">(</span>left<span class="op">,</span> right<span class="op">,</span> old<span class="op">)</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> left<span class="op">.</span>nbytes<span class="op">()</span> <span class="op">&lt;=</span> BTREE_PAGE_SIZE <span class="op">{</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> left<span class="op">[:</span>BTREE_PAGE_SIZE<span class="op">]</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span><span class="op">,</span> <span class="op">[</span><span class="dv">3</span><span class="op">]</span>BNode<span class="op">{</span>left<span class="op">,</span> right<span class="op">}</span> <span class="co">// 2 nodes</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    leftleft <span class="op">:=</span> BNode<span class="op">(</span><span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> BTREE_PAGE_SIZE<span class="op">))</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    middle <span class="op">:=</span> BNode<span class="op">(</span><span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> BTREE_PAGE_SIZE<span class="op">))</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    nodeSplit2<span class="op">(</span>leftleft<span class="op">,</span> middle<span class="op">,</span> left<span class="op">)</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>leftleft<span class="op">.</span>nbytes<span class="op">()</span> <span class="op">&lt;=</span> BTREE_PAGE_SIZE<span class="op">)</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">3</span><span class="op">,</span> <span class="op">[</span><span class="dv">3</span><span class="op">]</span>BNode<span class="op">{</span>leftleft<span class="op">,</span> middle<span class="op">,</span> right<span class="op">}</span> <span class="co">// 3 nodes</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the returned nodes are allocated from memory; they are just temporary data until <code>nodeReplaceKidN</code> actually allocates them.</p>
</section>
<section id="btree-insertion" class="level2">
<h2>4.4 B+tree insertion</h2>
<p>We’ve implemented 3 node operations:</p>
<ul>
<li><code>leafInsert</code> updates a leaf node.</li>
<li><code>nodeReplaceKidN</code> updates an internal node.</li>
<li><code>nodeSplit3</code> splits an oversized node.</li>
</ul>
<p>Let’s put them together for a full B+tree insertion, which starts with key lookups in the root node until it reaches a leaf.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// insert a KV into a node, the result might be split.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">// the caller is responsible for deallocating the input node</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">// and splitting and allocating result nodes.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> treeInsert<span class="op">(</span>tree <span class="op">*</span>BTree<span class="op">,</span> node BNode<span class="op">,</span> key <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> val <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> BNode <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the result node.</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it&#39;s allowed to be bigger than 1 page and will be split if so</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span> <span class="op">:=</span> BNode<span class="op">{</span>data<span class="op">:</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> <span class="dv">2</span><span class="op">*</span>BTREE_PAGE_SIZE<span class="op">)}</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// where to insert the key?</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">:=</span> nodeLookupLE<span class="op">(</span>node<span class="op">,</span> key<span class="op">)</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// act depending on the node type</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> node<span class="op">.</span>btype<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> BNODE_LEAF<span class="op">:</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// leaf, node.getKey(idx) &lt;= key</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> bytes<span class="op">.</span>Equal<span class="op">(</span>key<span class="op">,</span> node<span class="op">.</span>getKey<span class="op">(</span>idx<span class="op">))</span> <span class="op">{</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// found the key, update it.</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>            leafUpdate<span class="op">(</span><span class="bu">new</span><span class="op">,</span> node<span class="op">,</span> idx<span class="op">,</span> key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// insert it after the position.</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            leafInsert<span class="op">(</span><span class="bu">new</span><span class="op">,</span> node<span class="op">,</span> idx<span class="op">+</span><span class="dv">1</span><span class="op">,</span> key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> BNODE_NODE<span class="op">:</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// internal node, insert it to a kid node.</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>        nodeInsert<span class="op">(</span>tree<span class="op">,</span> <span class="bu">new</span><span class="op">,</span> node<span class="op">,</span> idx<span class="op">,</span> key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">panic</span><span class="op">(</span><span class="st">&quot;bad node!&quot;</span><span class="op">)</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">new</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>leafUpdate</code> is similar to <code>leafInsert</code>; it updates an existing key instead of inserting a duplicate key.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// part of the treeInsert(): KV insertion to an internal node</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> nodeInsert<span class="op">(</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">*</span>BTree<span class="op">,</span> <span class="bu">new</span> BNode<span class="op">,</span> node BNode<span class="op">,</span> idx <span class="dt">uint16</span><span class="op">,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    key <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> val <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    kptr <span class="op">:=</span> node<span class="op">.</span>getPtr<span class="op">(</span>idx<span class="op">)</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// recursive insertion to the kid node</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    knode <span class="op">:=</span> treeInsert<span class="op">(</span>tree<span class="op">,</span> tree<span class="op">.</span>get<span class="op">(</span>kptr<span class="op">),</span> key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// split the result</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    nsplit<span class="op">,</span> split <span class="op">:=</span> nodeSplit3<span class="op">(</span>knode<span class="op">)</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// deallocate the kid node</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    tree<span class="op">.</span>del<span class="op">(</span>kptr<span class="op">)</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// update the kid links</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    nodeReplaceKidN<span class="op">(</span>tree<span class="op">,</span> <span class="bu">new</span><span class="op">,</span> node<span class="op">,</span> idx<span class="op">,</span> split<span class="op">[:</span>nsplit<span class="op">]...)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Internal nodes are handled recursively, each call returns an updated node, and the caller will split it if it’s oversized and handle the allocation/deallocation.</p>
</section>
<section id="whats-next" class="level2">
<h2>4.5 What’s next?</h2>
<p>The work is almost done. We just need to add these in the next chapter:</p>
<ol type="1">
<li>Node merging and tree deletion.</li>
<li>A high-level interface.</li>
<li>Fake node callbacks for tests.</li>
</ol>
</section>
</section>
</body>
</html>
