["```go\nfunc logLine(line string) {\n    f.WriteString(line + \"\\n\")\n} \n```", "```go\nvar batch []string\n\nfunc logBatch(line string) {\n    batch = append(batch, line)\n    if len(batch) >= 100 {\n        f.WriteString(strings.Join(batch, \"\\n\") + \"\\n\")\n        batch = batch[:0]\n    }\n} \n```", "```go\ntype Batcher[T any] struct {\n    mu     sync.Mutex\n    buffer []T\n    size   int\n    flush  func([]T)\n}\n\nfunc NewBatcher[T any](size int, flush func([]T)) *Batcher[T] {\n    return &Batcher[T]{\n        buffer: make([]T, 0, size),\n        size:   size,\n        flush:  flush,\n    }\n}\n\nfunc (b *Batcher[T]) Add(item T) {\n    b.mu.Lock()\n    defer b.mu.Unlock()\n    b.buffer = append(b.buffer, item)\n    if len(b.buffer) >= b.size {\n        b.flushNow()\n    }\n}\n\nfunc (b *Batcher[T]) flushNow() {\n    if len(b.buffer) == 0 {\n        return\n    }\n    b.flush(b.buffer)\n    b.buffer = b.buffer[:0]\n} \n```", "```go\npackage perf\n\nimport (\n    \"crypto/sha256\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n    \"testing\"\n)\n\nvar lines = make([]string, 10000)\n\nfunc init() {\n    for i := range lines {\n        lines[i] = fmt.Sprintf(\"log entry %d %s\", i, strings.Repeat(\"x\", 100))\n    }\n}\n\n// --- 1\\. No I/O ---\n\nfunc BenchmarkUnbatchedProcessing(b *testing.B) {\n    for b.Loop() {\n        for _, line := range lines {\n            strings.ToUpper(line)\n        }\n    }\n}\n\nfunc BenchmarkBatchedProcessing(b *testing.B) {\n    batchSize := 100\n    for b.Loop() {\n        for i := 0; i < len(lines); i += batchSize {\n            end := i + batchSize\n            if end > len(lines) {\n                end = len(lines)\n            }\n            batch := strings.Join(lines[i:end], \"|\")\n            strings.ToUpper(batch)\n        }\n    }\n}\n\n// --- 2\\. With I/O ---\n\nfunc BenchmarkUnbatchedIO(b *testing.B) {\n    for b.Loop() {\n        f, err := os.CreateTemp(\"\", \"unbatched\")\n        if err != nil {\n            b.Fatal(err)\n        }\n        for _, line := range lines {\n            _, _ = f.WriteString(line + \"\\n\")\n        }\n        f.Close()\n        os.Remove(f.Name())\n    }\n}\n\nfunc BenchmarkBatchedIO(b *testing.B) {\n    batchSize := 100\n    for b.Loop() {\n        f, err := os.CreateTemp(\"\", \"batched\")\n        if err != nil {\n            b.Fatal(err)\n        }\n        for i := 0; i < len(lines); i += batchSize {\n            end := i + batchSize\n            if end > len(lines) {\n                end = len(lines)\n            }\n            batch := strings.Join(lines[i:end], \"\\n\") + \"\\n\"\n            _, _ = f.WriteString(batch)\n        }\n        f.Close()\n        os.Remove(f.Name())\n    }\n}\n\n// --- 3\\. With Crypto ---\n\nfunc hash(s string) string {\n    h := sha256.Sum256([]byte(s))\n    return hex.EncodeToString(h[:])\n}\n\nfunc BenchmarkUnbatchedCrypto(b *testing.B) {\n    for b.Loop() {\n        for _, line := range lines {\n            hash(line)\n        }\n    }\n}\n\nfunc BenchmarkBatchedCrypto(b *testing.B) {\n    batchSize := 100\n    for b.Loop() {\n        for i := 0; i < len(lines); i += batchSize {\n            end := i + batchSize\n            if end > len(lines) {\n                end = len(lines)\n            }\n            joined := strings.Join(lines[i:end], \"\")\n            hash(joined)\n        }\n    }\n} \n```"]