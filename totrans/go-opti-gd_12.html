<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lazy Initialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lazy Initialization</h1>
<blockquote>原文：<a href="https://goperf.dev/01-common-patterns/lazy-init/">https://goperf.dev/01-common-patterns/lazy-init/</a></blockquote>
                
                  


  
  


  

<h2 id="lazy-initialization-for-performance-in-go">Lazy Initialization for Performance in Go</h2>
<p>In Go, some resources are expensive to initialize, or simply unnecessary unless certain code paths are triggered. That’s where lazy initialization becomes useful: it defers the construction of a value until the moment it’s actually needed. This pattern can improve performance, reduce startup overhead, and avoid unnecessary work—especially in high-concurrency applications.</p>
<h3 id="why-lazy-initialization-matters">Why Lazy Initialization Matters</h3>
<p>Initializing heavy resources like database connections, caches, or large in-memory structures at startup can slow down application launch and consume memory before it’s actually needed. Lazy initialization defers this work until the first time the resource is used, keeping startup fast and memory usage lean.</p>
<p>It’s also a practical pattern when you have logic that might be triggered multiple times but should only run once—ensuring that expensive operations aren’t repeated and that initialization remains safe and idempotent across concurrent calls.</p>
<h3 id="using-synconce-for-thread-safe-initialization">Using <code>sync.Once</code> for Thread-Safe Initialization</h3>
<p>Go provides the <code>sync.Once</code> type to implement lazy initialization safely in concurrent environments:</p>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">resource</span><span class="w"> </span><span class="o">*</span><span class="nx">MyResource</span>
<span class="w">    </span><span class="nx">once</span><span class="w">     </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">getResource</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">MyResource</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">once</span><span class="p">.</span><span class="nx">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">resource</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">expensiveInit</span><span class="p">()</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">resource</span>
<span class="p">}</span>
</code></pre></div>
<p>In this example, the function <code>expensiveInit()</code> executes exactly once, no matter how many goroutines invoke <code>getResource()</code> concurrently. This ensures thread-safe initialization without additional synchronization overhead.</p>
<h3 id="using-synconcevalue-and-synconcevalues-for-initialization-with-output-values">Using <code>sync.OnceValue</code> and <code>sync.OnceValues</code> for Initialization with Output Values</h3>
<p>Since Go 1.21, if your initialization logic returns a value, you might prefer using <code>sync.OnceValue</code> (single value) or <code>sync.OnceValues</code> (multiple values) for simpler, more expressive code:</p>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">getResource</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">OnceValue</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">MyResource</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">expensiveInit</span><span class="p">()</span>
<span class="p">})</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">processData</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">res</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">getResource</span><span class="p">()</span>
<span class="w">    </span><span class="c1">// use res</span>
<span class="p">}</span>
</code></pre></div>
<p>Here, <code>sync.OnceValue</code> provides a concise way to wrap one-time initialization logic and access the result without managing flags or mutexes manually. It simplifies lazy loading by directly returning the computed value on demand.</p>
<p>For cases where the initializer returns more than one value—such as a resource and an error—<code>sync.OnceValues</code> extends the same idea. It ensures the function runs exactly once and cleanly unpacks the results, keeping the code readable and thread-safe without boilerplate.</p>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">getConfig</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">OnceValues</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Config</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">loadConfig</span><span class="p">(</span><span class="s">"config.yml"</span><span class="p">)</span>
<span class="p">})</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">processData</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">getConfig</span><span class="p">()</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// use config</span>
<span class="p">}</span>
</code></pre></div>
<p>Choosing <code>sync.OnceValue</code> or <code>sync.OnceValues</code> helps you clearly express initialization logic with direct value returns, whereas <code>sync.Once</code> remains best suited for general scenarios requiring flexible initialization logic without immediate value returns.</p>
<h3 id="custom-lazy-initialization-with-atomic-operations">Custom Lazy Initialization with Atomic Operations</h3>
<p>Yes, it’s technically possible to replace <code>sync.Once</code>, <code>sync.OnceValue</code>, or <code>sync.OnceFunc</code> with custom logic using low-level atomic operations like <code>atomic.CompareAndSwap</code> or <code>atomic.Load/Store</code>. In rare, performance-critical paths, this can avoid the small overhead or allocations that come with the standard types.</p>
<p>However, the trade-off is complexity. You lose the safety guarantees and clarity of the standard primitives, and it becomes easier to introduce subtle bugs—especially under concurrency. Unless profiling shows that sync.Once is a bottleneck, the standard versions are almost always the better choice.</p>
<p><strong>That said, it’s rarely worth the tradeoff.</strong></p>
<p>Manual atomic-based initialization is more error-prone, harder to read, and easier to get wrong—especially when concurrency and memory visibility guarantees are involved. For the vast majority of cases, <code>sync.Once*</code> is safer, clearer, and performant enough.</p>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>If you’re convinced that atomic-based lazy initialization is justified in your case, this blog post walks through the details and caveats:<br/>
<span class="twemoji"><svg viewbox="0 0 24 24"><path d="M21 9a1 1 0 0 1 1 1 1 1 0 0 1-1 1h-4.47l-.13 1.21-2.2 4.94c-.2.5-.73.85-1.34.85H8.5c-.8 0-1.5-.73-1.5-1.5V10c0-.39.16-.74.43-1l4.2-4.9.77.74c.2.19.32.45.32.74l-.03.22L11 9zM2 18v-8h3v8z"/></svg></span> <a href="https://goperf.dev/blog/2025/04/03/lazy-initialization-in-go-using-atomics/">Lazy initialization in Go using atomics</a></p>
</div>
<h3 id="performance-considerations">Performance Considerations</h3>
<p>While lazy initialization can offer clear benefits, it also brings added complexity. It’s important to handle initialization carefully to avoid subtle issues like race conditions or concurrency bugs. Using built-in tools like <code>sync.Once</code> or <code>atomic</code> operations typically ensures thread-safety without much hassle. Still, it’s always a good idea to measure actual improvements through profiling, confirming lazy initialization truly enhances startup speed, reduces memory usage, or boosts your application's responsiveness.</p>
<h2 id="benchmarking-impact">Benchmarking Impact</h2>
<p>There is typically nothing specific to benchmark with lazy initialization itself, as the main benefit is deferring expensive resource creation. The performance gains are inherently tied to the avoided cost of unnecessary initialization, startup speed improvements, and reduced memory consumption, rather than direct runtime throughput differences.</p>
<h2 id="when-to-choose-lazy-initialization">When to Choose Lazy Initialization</h2>
<ul>
<li>When resource initialization is costly or involves I/O. Delaying construction avoids paying the cost of setup—like opening files, querying databases, or loading large structures—unless it’s actually needed.</li>
<li>To improve startup performance and memory efficiency. Deferring work until first use allows your application to start faster and avoid allocating memory for resources that may never be used.</li>
<li>When not all resources are needed immediately or at all during runtime. Lazy initialization helps you avoid initializing fields or services that only apply in specific code paths.</li>
<li>To guarantee a block of code executes exactly once despite repeated calls. Using tools like <code>sync.Once</code> ensures thread-safe, one-time setup in concurrent environments.</li>
</ul>









  




                
                  
</body>
</html>