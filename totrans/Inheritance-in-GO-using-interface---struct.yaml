- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:00:45'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in GO using interface + struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/inheritance-go-interface-struct/](https://golangbyexample.com/inheritance-go-interface-struct/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This post describes inheritance using interface and struct. Do visit our Inheritance
    in Go Complete Guide post for full reference
  prefs: []
  type: TYPE_NORMAL
- en: '[OOP: Inheritance in GOLANG complete guide](https://golangbyexample.com/oop-inheritance-golang-complete/)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://golangbyexample.com/oop-inheritance-golang-complete/embed/#?secret=EpVuUFYEMN#?secret=OtvYyDmPmR](https://golangbyexample.com/oop-inheritance-golang-complete/embed/#?secret=EpVuUFYEMN#?secret=OtvYyDmPmR)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go supports inheritance by embedding struct or using interface. There are different
    ways of doing it and each having some limitations. The different ways are:'
  prefs: []
  type: TYPE_NORMAL
- en: By using embedded struct – The parent struct is embedded in child struct. The
    limitation is that subtyping is not possible with this approach. You cannot pass
    the child struct to a function that expects base. Refer this link for more details
    – [**Inheritance using Struct**](https://golangbyexample.com/inheritance-go-struct/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using interfaces – Subtyping is possible but the limitation is that one has
    no way to refer to common properties. Refer this link for more details – [**Inheritance
    using Interface**](https://golangbyexample.com/inheritance-go-interface/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**By using interface + struct** – This fixes the limitations of above two approach
    but one limitation is that overriding methods is not possible. But there is workaround.
    Current post describes this approach'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Details:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this approach, the base struct is embedded in child struct and base struct
    implements all methods of the common interface. So child struct can:'
  prefs: []
  type: TYPE_NORMAL
- en: Access methods and properties of base struct
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since base struct implements all functions of the common interface, the common
    interface itself can be used for subtyping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
