["```go\npackage main\n\nimport (\n    \"log\"\n    \"net\"\n    \"sync/atomic\"\n    \"time\"\n)\n\nvar activeConnections uint64\n\nfunc main() {\n    listener, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n        log.Fatalf(\"Error starting TCP listener: %v\", err)\n    }\n    defer listener.Close()\n\n    for {\n        conn, err := listener.Accept()\n        if err != nil {\n            log.Printf(\"Error accepting connection: %v\", err)\n            continue\n        }\n\n        atomic.AddUint64(&activeConnections, 1)\n        go handleConnection(conn)\n    }\n}\n\nfunc handleConnection(conn net.Conn) {\n    defer func() {\n        conn.Close()\n        atomic.AddUint64(&activeConnections, ^uint64(0)) // effectively decrements the counter\n    }()\n\n    // Imagine complex processing here—an echo server example:\n    buffer := make([]byte, 1024)\n    for {\n        conn.SetDeadline(time.Now().Add(30 * time.Second)) // prevent idle hangs\n        n, err := conn.Read(buffer)\n        if err != nil {\n            log.Printf(\"Connection read error: %v\", err)\n            return\n        }\n        _, err = conn.Write(buffer[:n])\n        if err != nil {\n            log.Printf(\"Connection write error: %v\", err)\n            return\n        }\n    }\n} \n```", "```go\npackage main\n\nimport (\n    \"net\"\n)\n\nvar connLimiter = make(chan struct{}, 10000) // Max 10K concurrent conns\n\nfunc main() {\n    ln, _ := net.Listen(\"tcp\", \":8080\")\n    defer ln.Close()\n\n    for {\n        conn, _ := ln.Accept()\n\n        connLimiter <- struct{}{} // Acquire slot\n        go func(c net.Conn) {\n            defer func() {\n                c.Close()\n                <-connLimiter // Release slot\n            }()\n            // Dummy echo logic\n            buf := make([]byte, 1024)\n            c.Read(buf)\n            c.Write(buf)\n        }(conn)\n    }\n} \n```", "```go\n# Increase file descriptor limit\nulimit -n 200000 \n```", "```go\nsysctl -w net.core.somaxconn=65535\nsysctl -w net.ipv4.ip_local_port_range=\"10000 65535\"\nsysctl -w net.ipv4.tcp_tw_reuse=1\nsysctl -w net.ipv4.tcp_fin_timeout=15 \n```", "```go\nfunc main() {\n    lc := net.ListenConfig{\n        Control: func(network, address string, c syscall.RawConn) error {\n            var controlErr error\n            err := c.Control(func(fd uintptr) {\n                // Enable TCP_NODELAY on the socket\n                controlErr = syscall.SetsockoptInt(int(fd), syscall.IPPROTO_TCP, syscall.TCP_NODELAY, 1)\n            })\n            if err != nil {\n                return err\n            }\n            return controlErr\n        },\n    }\n    listener, err := lc.Listen(context.Background(), \"tcp\", \":8080\")\n    if err != nil {\n        log.Fatalf(\"Error creating listener: %v\", err)\n    }\n    defer listener.Close()\n    // Accept connections in a loop…\n} \n```", "```go\nGOGC=50 \n```", "```go\nimport \"runtime/debug\"\n\nfunc main() {\n    debug.SetGCPercent(50)\n    // rest of your application logic\n} \n```", "```go\nfor {\n    select {\n    case msg := <-msgChan:\n        handleMsg(msg)\n    case <-ctx.Done():\n        return\n    }\n} \n```", "```go\nvar bufPool = sync.Pool{\n    New: func() any { return make([]byte, 1024) },\n}\n\nfunc handleRequest() {\n    buf := bufPool.Get().([]byte)\n    defer bufPool.Put(buf)  // (1)\n\n    // use buffer for request handling\n} \n```", "```go\nfor {\n    conn, err := ln.Accept()\n    if err != nil {\n        // handle error\n    }\n    go handle(conn)\n} \n```", "```go\nticker := time.NewTicker(5 * time.Second)\ndefer ticker.Stop() \n```", "```go\nconn.SetReadDeadline(time.Now().Add(10 * time.Second))\n_, err := reader.ReadString('\n')\nif err != nil {\n    return // read timeout or client gone\n} \n```", "```go\nselect {\ncase <-ticker.C:\n    conn.SetWriteDeadline(time.Now().Add(10 * time.Second))\n    conn.Write([]byte(\"ping\"))\ndefault:\n    // skip heartbeat if not due\n} \n```", "```go\nfunc handle(conn net.Conn) {\n    defer conn.Close()\n    reader := bufio.NewReader(conn)\n\n    for {\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            fmt.Printf(\"Connection closed: %v\\n\", err)\n            return\n        }\n        conn.Write([]byte(line)) // echo\n    }\n} \n```", "```go\ntcpkali -m $'ping\\n' -c 10000 --connect-rate=2000 --duration=60s 127.0.0.1:9000 \n```", "```go\nimport (\n    \"runtime/trace\"\n    \"os\"\n    \"log\"\n)\n\nfunc main() {\n    f, err := os.Create(\"trace.out\")\n    if err != nil { log.Fatal(err) }\n    defer f.Close()\n\n    trace.Start(f)\n    defer trace.Stop()\n\n    // server logic ...\n} \n```", "```go\ngo tool trace trace.out \n```", "```go\nreader := bufio.NewReader(conn)\nwriter := bufio.NewWriter(conn)\ncount := 0\nconst flushInterval = 10\n\nfor {\n    line, err := reader.ReadString('\\n')\n    if err != nil {\n        return\n    }\n    writer.WriteString(line)\n    count++\n    if count >= flushInterval {\n        writer.Flush()\n        count = 0\n    }\n} \n```", "```go\ntcpkali -m $'ping\\n' -c 10000 --connect-rate=2000 --duration=60s 127.0.0.1:9000 \n```", "```go\ntcpkali -m $'ping\\n' -c 30000 --connect-rate=5000 --duration=60s 127.0.0.1:9000 \n```", "```go\nfunc hash(s string) string {\n    h := sha256.Sum256([]byte(s))\n    return hex.EncodeToString(h[:])\n}\n\n...\n\nfor {\n    line, err := reader.ReadString('\\n')\n    if err != nil {\n        return\n    }\n    _ = hash(line) // simulate CPU-intensive processing\n    writer.WriteString(line)\n    count++\n    if count >= flushInterval {\n        writer.Flush()\n        count = 0\n    }\n} \n```"]