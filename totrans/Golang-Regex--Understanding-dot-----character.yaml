- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:37:23'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Golang Regex: Understanding dot ‘.’ character'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/dot-chracter-golang-regex/](https://golangbyexample.com/dot-chracter-golang-regex/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[MatchCompile Function](#MatchCompile_Function "MatchCompile Function")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Match Method](#Match_Method "Match Method")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Dot as a literal character](#Using_Dot_as_a_literal_character "Using
    Dot as a literal character")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dot character inside a character class](#Dot_character_inside_a_character_class
    "Dot character inside a character class")*  *## **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dot ‘.’ character is one of the most commonly used metacharacters in the regular
    expression. It is used to match any character. It can also match a new line if
    a specific flag is added to the regular expression which we going to discuss later.
    By default, it doesn’t match a new line.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking into the regex itself and usage of Dot ‘**.’** character, let’s
    look at some basic functions or methods provided by Go to do a regex match.
  prefs: []
  type: TYPE_NORMAL
- en: '**MatchCompile Function**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[https://golang.org/pkg/regexp/#MustCompile](https://golang.org/pkg/regexp/#MustCompile)
    . Below is the signature of the function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We first compile the given regex string using the **MustCompile** function.
    This function panics if the given regex is not valid. After it can successfully
    compile the given regex, it returns the instance of **regexp** struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Match Method**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[https://golang.org/pkg/regexp/#Regexp.Match](https://golang.org/pkg/regexp/#Regexp.Match)'
  prefs: []
  type: TYPE_NORMAL
- en: Below is the signature of the method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can call the **Match** method on the **regexp** struct instance to match
    the given pattern with the regex. It returns true if the regex matches with the
    input string otherwise false. We need to pass in bytes of the input string to
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will see these two functions in action later in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see a simple program for Dot ‘.’ character
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we have a simple regex containing only one dot character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It matches below characters and string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It matches **ab** because by default the regex doesn’t do the match the full
    string unless we use the anchor characters (Caret and Dollar character). That
    is why it matches the first character ‘a’ in ‘ab’ and reports a match.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t match an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see another example where we have two dots in the regex.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we have a simple regex containing two dots.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It will match any given string which has at least two characters as a substring.
  prefs: []
  type: TYPE_NORMAL
- en: That is why it gives a match for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: and doesn’t give a match for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot **‘.’** as we mentioned before as well doesn’t match the new line.
    But the default behavior can be changed by adding a set of flags to the beginning
    of the regular expression. The flag we need to add to the beginning of regex is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see a program for the same
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the second regex, we have added the additional flag. That is why it gives
    a match for a new line while the first regex without a flag doesn’t give a match.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Dot as a literal character**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use **Dot ‘.’** as a literal character, we need to escape it
    with a backslash. Once escaped it will match a literal dot character.  For example,
    if we want to match the literal below string or text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then the regex for the same will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here is the program for the same
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Dot character inside a character class**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dot or **‘.’** is treated as a literal character inside the square brackets
    or character class. It doesn’t need to be escaped inside that. Let’s see a working
    program for the same as well
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
