["```\nInput: [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n```", "```\nInput: [[1,1]]\nOutput: -1\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc orangesRotting(grid [][]int) int {\n\tnumRows := len(grid)\n\tnumColumns := len(grid[0])\n\n\tqueue := make([][2]int, 0)\n\n\tfor i := 0; i < numRows; i++ {\n\t\tfor j := 0; j < numColumns; j++ {\n\t\t\tif grid[i][j] == 2 {\n\t\t\t\tqueue = append(queue, [2]int{i, j})\n\t\t\t}\n\t\t}\n\t}\n\n\tneighboursIndex := [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\n\tnumMinutes := 0\n\tfor {\n\t\tn := len(queue)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tpop := queue[0]\n\t\t\tqueue = queue[1:]\n\n\t\t\ta := pop[0]\n\t\t\tb := pop[1]\n\t\t\tfor k := 0; k < 4; k++ {\n\t\t\t\tneighbourX := a + neighboursIndex[k][0]\n\t\t\t\tneighbourY := b + neighboursIndex[k][1]\n\n\t\t\t\tif isValid(neighbourX, neighbourY, numRows, numColumns) {\n\t\t\t\t\tif grid[neighbourX][neighbourY] == 1 {\n\t\t\t\t\t\tgrid[neighbourX][neighbourY] = 2\n\t\t\t\t\t\tqueue = append(queue, [2]int{neighbourX, neighbourY})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif len(queue) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tnumMinutes++\n\t}\n\n\tfor i := 0; i < numRows; i++ {\n\t\tfor j := 0; j < numColumns; j++ {\n\t\t\tif grid[i][j] == 1 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\t}\n\n\treturn numMinutes\n}\n\nfunc isValid(i, j, numRows, numColumns int) bool {\n\tif i >= numRows || i < 0 {\n\t\treturn false\n\t}\n\n\tif j >= numColumns || j < 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc main() {\n\toutput := orangesRotting([][]int{{2, 1, 1}, {1, 1, 0}, {0, 1, 1}})\n\tfmt.Println(output)\n\n\toutput = orangesRotting([][]int{{1, 1}})\n\tfmt.Println(output)\n}\n```", "```\n4\n-1\n```"]