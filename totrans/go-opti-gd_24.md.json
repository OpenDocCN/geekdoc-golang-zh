["```go\n`package  main  import  (   \"fmt\"   \"runtime\" )  func  main()  {   // Show current value   fmt.Printf(\"GOMAXPROCS = %d\\n\",  runtime.GOMAXPROCS(0))    // Set to 4 and confirm   prev  :=  runtime.GOMAXPROCS(4)   fmt.Printf(\"Changed from %d to %d\\n\",  prev,  runtime.GOMAXPROCS(0)) }` \n```", "```go\n`GODEBUG=schedtrace=1000,scheddetail=1  go  run  main.go` \n```", "```go\n`SCHED 3024ms: gomaxprocs=14 idleprocs=14 threads=26 spinningthreads=0 needspinning=0 idlethreads=20 runqueue=0 gcwaiting=false nmidlelocked=1 stopwait=0 sysmonwait=false   P0: status=0 schedtick=173 syscalltick=3411 m=nil runqsize=0 gfreecnt=6 timerslen=0   ...   P13: status=0 schedtick=96 syscalltick=310 m=nil runqsize=0 gfreecnt=2 timerslen=0   M25: p=nil curg=nil mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=nil   ...` \n```", "```go\n`func  pollAndRead(conn  net.Conn)  ([]byte,  error)  {   buf  :=  make([]byte,  4096)   for  {   n,  err  :=  conn.Read(buf)   if  n  >  0  {   return  buf[:n],  nil   }   if  err  !=  nil  &&  !isTemporary(err)  {   return  nil,  err   }   // Data not ready yet â€” goroutine will be parked until poller wakes it   } }` \n```", "```go\n`GODEBUG=netpoll=1  go  run  main.go` \n```", "```go\n`runtime: netpoll: poll returned n=3 runtime: netpoll: waking g=102 for fd=5` \n```", "```go\n`runtime.LockOSThread() defer  runtime.UnlockOSThread()  // perform critical latency-sensitive work here` \n```", "```go\n`func  setAffinity(cpuList  []int)  error  {   pid  :=  os.Getpid()   var  mask  unix.CPUSet   for  _,  cpu  :=  range  cpuList  {   mask.Set(cpu)   }   return  unix.SchedSetaffinity(pid,  &mask) }  func  main()  {   runtime.LockOSThread()   defer  runtime.UnlockOSThread()    if  err  :=  setAffinity([]int{2,  3});  err  !=  nil  {   log.Fatalf(\"CPU affinity failed: %v\",  err)   }    // perform critical work with confirmed benefit }` \n```"]