["```go\nvar requests atomic.Int64\n\nfunc handleRequest() {\n    requests.Add(1)\n} \n```", "```go\nvar shutdown atomic.Int32\n\nfunc mainLoop() {\n    for {\n        if shutdown.Load() == 1 {\n            break\n        }\n        // do work\n    }\n}\n\nfunc stop() {\n    shutdown.Store(1)\n} \n```", "```go\nimport (\n    \"runtime\"\n    \"sync/atomic\"\n    \"unsafe\"\n)\n\nvar resource unsafe.Pointer\nvar initStatus int32 // 0: not started, 1: in progress, 2: completed\n\nfunc getResource() *MyResource {\n    if atomic.LoadInt32(&initStatus) == 2 {\n        return (*MyResource)(atomic.LoadPointer(&resource))\n    }\n\n    if atomic.CompareAndSwapInt32(&initStatus, 0, 1) {\n        newRes := expensiveInit() // initialization logic\n        atomic.StorePointer(&resource, unsafe.Pointer(newRes))\n        atomic.StoreInt32(&initStatus, 2)\n        return newRes\n    }\n\n    for atomic.LoadInt32(&initStatus) != 2 {\n        runtime.Gosched() // yield until the initializer finishes\n    }\n    return (*MyResource)(atomic.LoadPointer(&resource))\n} \n```", "```go\ntype node struct {\n    next *node\n    val  any\n}\n\nvar head atomic.Pointer[node]\n\nfunc push(n *node) {\n    for {\n        old := head.Load()\n        n.next = old\n        if head.CompareAndSwap(old, n) {\n            return\n        }\n    }\n} \n```", "```go\nif atomic.LoadInt32(&someFlag) == 0 {\n    return\n}\nmu.Lock()\ndefer mu.Unlock()\n// do something heavy \n```", "```go\nif !atomic.CompareAndSwapInt32(&someFlag, 0, 1) {\n    return // work already in progress or completed\n}\nmu.Lock()\ndefer mu.Unlock()\n// perform one-time expensive initialization \n```", "```go\nfunc BenchmarkAtomicIncrement(b *testing.B) {\n    var counter int64\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            atomic.AddInt64(&counter, 1)\n        }\n    })\n}\n\nfunc BenchmarkMutexIncrement(b *testing.B) {\n    var (\n        counter int64\n        mu      sync.Mutex\n    )\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            mu.Lock()\n            counter++\n            mu.Unlock()\n        }\n    })\n} \n```", "```go\npackage perf\n\nimport (\n    \"testing\"\n    \"sync/atomic\"\n    \"sync\"\n)\n\n// bench-start\nfunc BenchmarkAtomicIncrement(b *testing.B) {\n    var counter int64\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            atomic.AddInt64(&counter, 1)\n        }\n    })\n}\n\nfunc BenchmarkMutexIncrement(b *testing.B) {\n    var (\n        counter int64\n        mu      sync.Mutex\n    )\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            mu.Lock()\n            counter++\n            mu.Unlock()\n        }\n    })\n}\n// bench-end \n```"]