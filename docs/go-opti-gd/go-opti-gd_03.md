# 性能的常见 Go 模式[]

> 原文：[https://goperf.dev/01-common-patterns/](https://goperf.dev/01-common-patterns/)

优化 Go 应用程序需要了解有助于减少延迟、提高内存效率和增强并发的常见模式。本指南将 15 个关键技术组织成四个实用类别。

* * *

## 内存管理与效率

这些策略有助于减少内存碎片，避免过度分配，并改善缓存行为。

+   [对象池](object-pooling/)

    重复使用对象以减少 GC 压力和分配开销。

+   [内存预分配](mem-prealloc/)

    预先分配切片和映射的容量以避免昂贵的调整大小。

+   [结构体字段对齐](fields-alignment/)

    优化内存布局以最小化填充并提高局部性。

+   [避免接口装箱](interface-boxing/)

    通过避免不必要的接口转换来防止隐藏的分配。

+   [零拷贝技术](zero-copy/)

    通过切片和缓冲技巧最小化数据复制。

+   [内存效率和 Go 的垃圾回收器](gc/)

    通过最小化堆使用和重用内存来减少 GC 开销。

+   [堆分配和逃逸分析](stack-alloc/)

    使用逃逸分析来帮助值尽可能保持在栈上。

* * *

## 并发与同步

高效管理 goroutines、共享资源和协调。

+   [Goroutine 工作池](worker-pool/)

    使用固定大小的池来控制并发，以限制资源使用。

+   [原子操作和同步原语](atomic-ops/)

    使用原子操作或轻量级锁来管理共享状态。

+   [延迟初始化 (`sync.Once`)](lazy-init/)

    延迟昂贵的设置逻辑，直到实际需要时。

+   [不可变数据共享](immutable-data/)

    通过使数据不可变，在 goroutines 之间安全地共享数据而不使用锁。

+   [高效上下文管理](context/)

    使用 `context` 在 goroutines 之间传播超时和取消信号。

* * *

## I/O 优化和吞吐量

减少系统调用开销，并增加 I/O 密集型工作负载的数据吞吐量。

+   [高效缓冲](buffered-io/)

    使用缓冲读取器/写入器来最小化 I/O 调用。

+   [批量操作](batching-ops/)

    将多个小操作组合起来以减少往返次数并提高吞吐量。

* * *

## 编译器级优化和调整

利用 Go 的编译器和链接器进一步优化您的应用程序。

+   [利用编译器优化标志](comp-flags/)

    使用构建标志如 `-gcflags` 和 `-ldflags` 进行性能调整。

+   [堆分配和逃逸分析](stack-alloc/)

    分析哪些值逃逸到堆中，以帮助编译器优化内存放置。
