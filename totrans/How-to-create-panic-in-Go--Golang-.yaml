- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:26:32'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: How to create panic in Go (Golang)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/how-create-panic-golang/](https://golangbyexample.com/how-create-panic-golang/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Runtime Error Panic](#Runtime_Error_Panic "Runtime Error Panic")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calling the panic function explicitly](#Calling_the_panic_function_explicitly
    "Calling the panic function explicitly")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panic is similar to the exception in golang. Panic is meant to exit from a program
    in abnormal conditions. Panic can occur in a program in two ways
  prefs: []
  type: TYPE_NORMAL
- en: Runtime error in the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By calling the panic function explicitly. This can be called by the programmer
    when the program cannot continue and it has to exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go provides a special function to create a panic. Below is the syntax of the
    function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function can be called explicitly by the programmer to create a panic.
    It takes an empty interface as an argument.  When a panic happens in a  program
    it outputs two things
  prefs: []
  type: TYPE_NORMAL
- en: The error message that is passed to the panic function as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack trace of where the panic happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime Error Panic**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runtime error in the program can happen in below cases
  prefs: []
  type: TYPE_NORMAL
- en: Out of bounds array access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a function on a nil pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending on a closed channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect type assertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see an example of runtime error caused by out of bounds array access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above program we have a slice of length 2 and we are trying to access
    slice at index 3 in the **print** function. Out of bound access is not allowed
    and it will create panic as seen from the output. Notice that in the output there
    are two things
  prefs: []
  type: TYPE_NORMAL
- en: The error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack trace of where the panic happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more cases in which runtime error can happen in a program. We
    are not going to mention all of them but you get the idea
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling the panic function explicitly**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the cases where the panic function can be called explicitly by the
    programmer are:'
  prefs: []
  type: TYPE_NORMAL
- en: The function expected a valid argument but instead, a nil argument was supplied.
    In such case, the program cannot continue and it will raise a panic for a nil
    argument passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other scenario in which program cannot continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we again have a function **checkAndPrint** which accepts
    a slice as an argument and an index. Then it checks whether the index passed is
    greater than the length of slice minus 1\. If it is, then it is out of bounds
    access for the slice so it panics. If not then it prints the value at that index.
    Again notice that in the output there are two things
  prefs: []
  type: TYPE_NORMAL
- en: The error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack trace of where the panic happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
