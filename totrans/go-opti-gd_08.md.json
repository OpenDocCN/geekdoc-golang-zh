["```go\n`GOGC=100  # Default: GC runs when heap grows 100% since last collection GOGC=off  # Disables GC (use only in special cases like short-lived CLI tools)` \n```", "```go\n`GOMEMLIMIT=400MiB` \n```", "```go\n`import  \"runtime/debug\"  debug.SetMemoryLimit(2  <<  30)  // 2 GiB` \n```", "```go\n`GOGC=100  GOMEMLIMIT=4GiB  ./your-service` \n```", "```go\n`GOMEMLIMIT=2GiB  GOGC=off  ./my-app` \n```", "```go\n`// BAD: returns pointer to heap-allocated struct func  newUser(name  string)  *User  {   return  &User{Name:  name}  // escapes to heap }  // BETTER: use value types if pointer is unnecessary func  printUser(u  User)  {   fmt.Println(u.Name) }` \n```", "```go\n`var  bufPool  =  sync.Pool{   New:  func()  any  {  return  new(bytes.Buffer)  }, }  func  handler(w  http.ResponseWriter,  r  *http.Request)  {   buf  :=  bufPool.Get().(*bytes.Buffer)   buf.Reset()   defer  bufPool.Put(buf)    // Use buf... }` \n```", "```go\n`// Instead of allocating many small structs, allocate a slice of structs users  :=  make([]User,  0,  1000)  // single large allocation` \n```", "```go\n`package  main  import  (   \"fmt\"   \"runtime\"   \"weak\" )  type  Data  struct  {   Value  string }  func  main()  {   data  :=  &Data{Value:  \"Important\"}   wp  :=  weak.Make(data)  // create weak pointer    fmt.Println(\"Original:\",  wp.Value().Value)    data  =  nil  // remove strong reference   runtime.GC()    if  v  :=  wp.Value();  v  !=  nil  {   fmt.Println(\"Still alive:\",  v.Value)   }  else  {   fmt.Println(\"Data has been collected\")   } }` \n```", "```go\n`Original: Important Data has been collected` \n```"]