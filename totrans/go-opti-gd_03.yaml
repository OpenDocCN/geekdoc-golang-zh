- en: Object Pooling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池化
- en: 原文：[https://goperf.dev/01-common-patterns/object-pooling/](https://goperf.dev/01-common-patterns/object-pooling/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/object-pooling/](https://goperf.dev/01-common-patterns/object-pooling/)
- en: Object pooling helps reduce allocation churn in high-throughput Go programs
    by reusing objects instead of allocating fresh ones each time. This avoids repeated
    work for the allocator and eases pressure on the garbage collector, especially
    when dealing with short-lived or frequently reused structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用对象而不是每次都分配新的对象，对象池化有助于减少高吞吐量Go程序中的分配 churn。这避免了分配器的重复工作，并减轻了垃圾收集器的压力，尤其是在处理短生命周期或频繁重用的结构时。
- en: Go’s `sync.Pool` provides a built-in way to implement pooling with minimal code.
    It’s particularly effective for objects that are expensive to allocate or that
    would otherwise contribute to frequent garbage collection cycles. While not a
    silver bullet, it’s a low-friction tool that can lead to noticeable gains in latency
    and CPU efficiency under sustained load.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go的 `sync.Pool` 提供了一种使用最少代码实现池化的内置方式。它特别适用于分配成本高昂或可能导致频繁垃圾收集周期的对象。虽然不是万能的，但它是一个低摩擦的工具，可以在持续负载下带来延迟和CPU效率的明显提升。
- en: How Object Pooling Works
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池化是如何工作的
- en: Object pooling allows programs to reuse memory by recycling previously allocated
    objects instead of creating new ones on every use. Rather than hitting the heap
    each time, objects are retrieved from a shared pool and returned once they’re
    no longer needed. This reduces the number of allocations, cuts down on garbage
    collection workload, and leads to more predictable performance—especially in workloads
    with high object churn or tight latency requirements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池化允许程序通过回收先前分配的对象而不是在每次使用时创建新对象来重用内存。而不是每次都击中堆，对象从共享池中检索，并在不再需要时返回。这减少了分配的数量，减少了垃圾收集的工作量，并导致更可预测的性能——特别是在具有高对象
    churn 或严格延迟要求的工作负载中。
- en: Using `sync.Pool` for Object Reuse
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 进行对象重用
- en: Without Object Pooling (Inefficient Memory Usage)
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无对象池化（低效内存使用）
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the above example, every iteration creates a new `Data` instance, leading
    to unnecessary allocations and increased GC pressure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，每个迭代都会创建一个新的 `Data` 实例，导致不必要的分配和垃圾收集压力的增加。
- en: With Object Pooling (Optimized Memory Usage)
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过对象池化（优化内存使用）
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pooling Byte Buffers for Efficient I/O
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为高效I/O池化字节缓冲区
- en: Object pooling is especially effective when working with large byte slices that
    would otherwise lead to high allocation and garbage collection overhead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理可能导致高分配和垃圾收集开销的大型字节切片时，对象池化特别有效。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using `sync.Pool` for byte buffers significantly reduces memory pressure when
    dealing with high-frequency I/O operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 对字节缓冲区进行池化，在处理高频I/O操作时显著减少了内存压力。
- en: Benchmarking Impact
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响
- en: To prove that object pooling actually reduces allocations and improves speed,
    we can use Go's built-in memory profiling tools (`pprof`) and compare memory allocations
    between the non-pooled and pooled versions. Simulating a full-scale application
    that actively uses memory for benchmarking is challenging, so we need a controlled
    test to evaluate direct heap allocations versus pooled allocations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明对象池实际上减少了分配并提高了速度，我们可以使用Go的内置内存分析工具（`pprof`）并比较非池化和池化版本之间的内存分配。模拟一个全面使用内存进行基准测试的应用程序具有挑战性，因此我们需要一个受控的测试来评估直接堆分配与池化分配之间的差异。
- en: <details class="example"><summary>Show the benchmark file</summary>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示基准文件</summary>
- en: '[PRE3]</details>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]</details>'
- en: '| Benchmark | Iterations | Time per op (ns) | Bytes per op | Allocs per op
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 基准 | 迭代次数 | 每次操作时间（ns） | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| BenchmarkWithoutPooling-14 | 1,692,014 | 705.4 | 8,192 | 1 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 无池化基准-14 | 1,692,014 | 705.4 | 8,192 | 1 |'
- en: '| BenchmarkWithPooling-14 | 160,440,506 | 7.455 | 0 | 0 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 池化基准-14 | 160,440,506 | 7.455 | 0 | 0 |'
- en: The benchmark results highlight the contrast in performance and memory usage
    between direct allocations and object pooling. In `BenchmarkWithoutPooling`, each
    iteration creates a new object on the heap, leading to higher execution time and
    increased memory consumption. This constant allocation pressure triggers more
    frequent garbage collection, which adds latency and reduces throughput. The presence
    of nonzero allocation counts per operation confirms that each iteration contributes
    to GC load, making this approach less efficient in high-throughput scenarios.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果突出了直接分配和对象池化在性能和内存使用上的对比。在 `BenchmarkWithoutPooling` 中，每次迭代都会在堆上创建一个新的对象，导致执行时间更长，内存消耗增加。这种持续的分配压力会触发更频繁的垃圾回收，增加延迟并降低吞吐量。每个操作的非零分配计数确认了每次迭代都会对GC负载做出贡献，这使得这种方法在高吞吐量场景中效率较低。
- en: When Should You Use `sync.Pool`?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该在何时使用 `sync.Pool`？
- en: 'Use sync.Pool when:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用 sync.Pool：
- en: You have short-lived, reusable objects (e.g., buffers, scratch memory, request
    state). Pooling avoids repeated allocations and lets you recycle memory efficiently.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有短暂的生命周期且可重用的对象（例如，缓冲区、临时内存、请求状态）。池化避免了重复分配，并允许你高效地回收内存。
- en: Allocation overhead or GC churn is measurable and significant. Reusing objects
    reduces the number of heap allocations, which in turn lowers garbage collection
    frequency and pause times.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配开销或GC（垃圾回收）的波动是可测量且显著的。重用对象减少了堆分配的数量，从而降低了垃圾回收的频率和暂停时间。
- en: The object’s lifecycle is local and can be reset between uses. When objects
    don’t need complex teardown and are safe to reuse after a simple reset, pooling
    is straightforward and effective.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的生命周期是局部的，可以在使用之间重置。当对象不需要复杂的拆解，并且在简单重置后可以安全重用时，池化简单且有效。
- en: You want to reduce pressure on the garbage collector in high-throughput systems.
    In systems handling thousands of requests per second, pooling helps maintain consistent
    performance and minimizes GC-related latency spikes.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在高吞吐量系统中减少对垃圾回收器的压力。在每秒处理数千个请求的系统中，池化有助于保持一致的性能并最小化GC相关的延迟峰值。
- en: 'Avoid sync.Pool when:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 sync.Pool：
- en: Objects are long-lived or shared across multiple goroutines. `sync.Pool` is
    optimized for short-lived, single-use objects and doesn’t manage shared ownership
    or coordination.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是长期存在或跨多个goroutine共享的。`sync.Pool`针对短暂的单次使用对象进行了优化，不管理共享所有权或协调。
- en: The reuse rate is low and pooled objects are not frequently accessed. If objects
    sit idle in the pool, you gain little benefit and may even waste memory.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用率低且池化对象不常被访问。如果对象在池中闲置，你获得的收益很少，甚至可能浪费内存。
- en: Predictability or lifecycle control is more important than allocation speed.
    Pooling makes lifecycle tracking harder and may not be worth the tradeoff.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测性或生命周期控制比分配速度更重要。池化使得生命周期跟踪更加困难，可能不值得这种权衡。
- en: Memory savings are negligible or code complexity increases significantly. If
    pooling doesn’t provide clear benefits, it can add unnecessary complexity to otherwise
    simple code.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存节省微不足道或代码复杂性显著增加。如果池化没有提供明显的优势，它可能会在不复杂的代码中增加不必要的复杂性。
