["```\nInfix Expression: In infix expression, the operator is in between pair of operands like (a op b).\nexample: a+b, 2/2 .\nPostfix Expression: In postfix expression, the operator is placed post to both operands like (a b op).\nexample: ab+, 22/ . \n```", "```\na+b*c+d\n```", "```\nabc*+d+:\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype Stack []string\n\n//IsEmpty: check if stack is empty\nfunc (st *Stack) IsEmpty() bool {\n    return len(*st) == 0\n}\n\n//Push a new value onto the stack\nfunc (st *Stack) Push(str string) {\n    *st = append(*st, str) //Simply append the new value to the end of the stack\n}\n\n//Remove top element of stack. Return false if stack is empty.\nfunc (st *Stack) Pop() bool {\n    if st.IsEmpty() {\n        return false\n    } else {\n        index := len(*st) - 1 // Get the index of top most element.\n        *st = (*st)[:index]   // Remove it from the stack by slicing it off.\n        return true\n    }\n}\n\n//Return top element of stack. Return false if stack is empty.\nfunc (st *Stack) Top() string {\n    if st.IsEmpty() {\n        return \"\"\n    } else {\n        index := len(*st) - 1   // Get the index of top most element.\n        element := (*st)[index] // Index onto the slice and obtain the element.\n        return element\n    }\n}\n\n//Function to return precedence of operators\nfunc prec(s string) int {\n    if s == \"^\" {\n        return 3\n    } else if (s == \"/\") || (s == \"*\") {\n        return 2\n    } else if (s == \"+\") || (s == \"-\") {\n        return 1\n    } else {\n        return -1\n    }\n}\n\nfunc infixToPostfix(infix string) string {\n    var sta Stack\n    var postfix string\n    for _, char := range infix {\n        opchar := string(char)\n        // if scanned character is operand, add it to output string\n        if (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9') {\n            postfix = postfix + opchar\n        } else if char == '(' {\n            sta.Push(opchar)\n        } else if char == ')' {\n            for sta.Top() != \"(\" {\n                postfix = postfix + sta.Top()\n                sta.Pop()\n            }\n            sta.Pop()\n        } else {\n            for !sta.IsEmpty() && prec(opchar) <= prec(sta.Top()) {\n                postfix = postfix + sta.Top()\n                sta.Pop()\n            }\n            sta.Push(opchar)\n        }\n    }\n    // Pop all the remaining elements from the stack\n    for !sta.IsEmpty() {\n        postfix = postfix + sta.Top()\n        sta.Pop()\n    }\n    return postfix\n}\nfunc main() {\n    //infix := \"a+b\"\n    //infix := \"a+b*c+d\"\n    //infix := \"a+b*(c^d-e)^(f+g*h)-i\" // abcd^e-fgh*+^*+i-\n    //infix := \"1+2+3*4+5/5-2\"\n    infix := \"2+3*(2^3-5)^(2+1*2)-4\" //abcd^e-fgh*+^*+i-\n    postfix := infixToPostfix(infix)\n    fmt.Printf(\"%s infix has %s postfix \", infix, postfix)\n\n}\n```", "```\n2+3*(2^3-5)^(2+1*2)-4 infix has 2323^5-212*+^*+4- postfix\n```"]