# 内存效率：掌握Go的垃圾回收器[]

> 原文：[https://goperf.dev/01-common-patterns/gc/](https://goperf.dev/01-common-patterns/gc/)

Go中的内存管理是自动化的——但它并非不可见。你进行的每一次分配都会对垃圾回收工作负载做出贡献。对象创建和丢弃的频率越高，运行时在回收内存时需要做的工作就越多。

这在优先考虑低延迟、可预测的资源使用或高吞吐量的系统中尤其相关。调整您的分配模式并利用像弱引用这样的新功能可以帮助减轻垃圾回收器的压力，而不会增加您的代码复杂性。

## Go的垃圾回收器是如何工作的

信息

强烈建议您阅读官方的[A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)！该文档提供了对多个Go垃圾回收器内部结构的详细描述。

Go使用一个**非代际、并发、三色标记-清除**垃圾回收器。以下是它在实际中的含义以及它的实现方式。

### 非代际

许多现代垃圾回收器，如JVM或.NET CLR中的那些，在假设大多数对象年轻死亡的情况下将内存划分为*代际*（年轻和年老）。这些收集器专注于年轻代，导致收集周期更短。

Go的垃圾回收器采用不同的方法。它平等地对待所有对象——没有代际分割——这不是因为代际垃圾回收器与短暂的暂停时间或并发扫描冲突，而是因为它尚未在迄今为止尝试的Go程序设计中显示出清晰、一致的好处。这种选择避免了提升逻辑和专用内存区域的复杂性。虽然这可能意味着总体上扫描更多的对象，但这种成本通过并发执行和高效的写屏障得到了缓解。

### 并发

Go的垃圾回收器与应用程序并发运行，这意味着它的大部分工作都是在不停止世界的情况下完成的。并发是通过使用多个阶段来实现的，这些阶段与正常程序执行交织在一起：

尽管Go的垃圾回收器主要是并发的，但它仍然需要在几个点上进行短暂的停止世界（STW）暂停以保持正确性。这些暂停被保持得非常短——通常在100微秒以下——即使是在大型堆和数百个goroutine的情况下。

STW对于确保在垃圾回收分析内存结构时内存结构不被修改是必不可少的。在大多数应用程序中，这些暂停是感觉不到的。然而，即使在延迟敏感系统中，亚毫秒级的暂停也可能很重要——因此，当优化尾部延迟或抖动时，理解和监控STW行为变得很重要。

+   **STW开始阶段：** 应用程序会短暂暂停以启动垃圾回收。运行时会扫描栈、全局变量和根对象。

+   **并发标记阶段**：垃圾回收器遍历堆，在程序继续运行的同时标记所有可达对象。这是工作量最大的阶段，但它是并发运行的，以避免长时间的停止世界暂停。

+   **STW 标记终止**：一旦标记基本完成，垃圾回收器会短暂暂停程序以完成任何剩余的工作，并在开始清除之前确保堆处于一致状态。这个暂停通常非常短——以微秒计。

+   **并发清除阶段**：垃圾回收器从不可达（白色）对象中回收内存，并将其返回到堆中以供重用，同时你的程序继续运行。

写屏障确保在应用程序在并发标记期间修改对象时的正确性。这些屏障有助于跟踪扫描过程中创建或修改的引用，以便垃圾回收器不会错过它们。

### 三色标记和清除

三色算法在垃圾回收期间将堆分成三个工作集：

+   **白色**：尚未到达的对象——如果它们保持白色，它们将被收集。

+   **灰色**：已经被发现（即，标记为可达）但尚未扫描其引用的对象。

+   **黑色**：既是可达的又被完全扫描的对象——它们被保留，不需要进一步处理。

垃圾回收首先将所有根对象（栈、全局变量等）标记为灰色。然后遍历灰色集合：对于每个对象，它扫描其字段。任何仍然是白色的被引用对象都被添加到灰色集合中。一旦一个对象的引用被完全处理，它就被标记为黑色。

当没有灰色对象剩下时，任何仍然保持白色的对象在清除阶段都会被清理。这种模型确保没有活动对象被意外收集——即使引用在扫描过程中发生变化——这要归功于 Go 的写屏障，它维护了算法的核心不变性。

一个关键的优化是**增量标记**：Go 将 GC 工作分散到避免长时间暂停，由精确的栈扫描和保守的写屏障支持。并发清除的使用进一步减少了延迟，允许在不停机的情况下回收内存。

这种设计使 Go 的垃圾回收器既安全又快速，对具有大堆和多个核心的服务器工作负载非常友好。

## GC 调优：GOGC

Go 的垃圾回收器经过调整，能够在不进行手动配置的情况下提供良好的性能。默认的 `GOGC` 设置通常在内存消耗和 CPU 努力之间取得适当的平衡，能够很好地适应广泛的工作负载。在大多数情况下，手动调整它带来的好处很少——在许多情况下，它实际上会使事情变得更糟，通过增加暂停时间或内存压力。除非你已经分析了特定的瓶颈并理解了权衡，否则通常最好让 `GOGC` 保持原样。

话虽如此，有一些特定的情况，调整`GOGC`可以带来显著的收益。例如，Uber在其Go服务中实施了动态GC调整[Uber实现了动态GC调整](https://www.uber.com/en-GB/blog/how-we-saved-70k-cores-across-30-mission-critical-services/)，以减少CPU使用并在这个过程中节省了数万个核心。他们的方法依赖于性能分析、指标收集和自动化，以根据实际的内存压力和工作负载特征安全地调整GC行为。

另一个不寻常的案例来自Cloudflare。他们[对高并发加密工作负载进行了性能分析](https://blog.cloudflare.com/go-dont-collect-my-garbage/)，发现随着goroutine的增加，Go的GC成为瓶颈。他们的应用程序产生的垃圾最少，但GC开销随着并发性增长。通过将GOGC调整到一个更高的值——具体为11300——他们显著减少了GC频率并提高了吞吐量，与单核基线相比实现了超过22倍的性能提升。这个案例突出了在CPU密集型和低分配场景中允许更多的堆增长可以带来重大改进。

因此，如果你决定调整垃圾回收器，请保持条理性：

+   首先进行性能分析。使用像`pprof`这样的工具来确认GC活动是否是瓶颈。

+   逐步更改设置。例如，将`GOGC`从100增加到150意味着GC将运行得更少，使用更少的CPU但更多的内存。

+   验证影响。调整后，使用性能数据验证更改是否产生了积极的效果。没有这种确认，很容易使事情变得更糟。

```go
GOGC=100  # Default: GC runs when heap grows 100% since last collection
GOGC=off  # Disables GC (use only in special cases like short-lived CLI tools) 
```

### 使用`GOMEMLIMIT`进行内存限制

除了`GOGC`之外，Go还提供了`GOMEMLIMIT`——这是一个软内存限制，限制了运行时将尝试保持在总堆大小之下的上限。这允许你显式地控制内存增长，在容器或具有严格内存预算的系统等环境中特别有用。

这有什么好处？在容器化环境中（如Kubernetes），内存限制通常在OS或编排器级别强制执行。如果你的应用程序超过了其内存配额，OOM杀手可能会突然终止容器。默认情况下，Go的GC并不了解这些限制。

设置`GOMEMLIMIT`有助于防止这种情况。例如，如果你的容器有512MiB的内存限制，你可能设置：

```go
GOMEMLIMIT=400MiB 
```

这个缓冲区为Go运行时提供了在达到系统强加的内存上限之前行动的空间。它允许垃圾回收器随着总内存使用量的增长而变得更加激进，从而降低因内存不足而杀死进程的可能性。它还留出了非堆分配的空间——如goroutine栈、OS线程和其他内部运行时结构，这些不计算在堆大小之内，但仍然消耗实际内存。

你也可以通过编程设置限制：

```go
import "runtime/debug"

debug.SetMemoryLimit(2 << 30) // 2 GiB 
```

当堆使用接近限制时，GC 将变得更加激进，这可能会增加 CPU 负载。请小心不要设置限制得太低——特别是如果你的应用程序维护了一个大的活动对象集——否则可能会触发过多的 GC 循环。

虽然 `GOGC` 根据堆增长控制 GC 运行的频率，但 `GOMEMLIMIT` 本身限制了堆的大小。这两个可以结合使用以实现更精确的控制：

```go
GOGC=100 GOMEMLIMIT=4GiB ./your-service 
```

这告诉 GC 使用默认的增长比率，并在堆使用接近 4 GiB 时开始收集。

### GOMEMLIMIT=X 和 GOGC=off 配置

在内存可用性固定且可预测的场景中——例如在容器或虚拟机内部，你可以同时使用这两个变量：

+   `GOMEMLIMIT=X` 告诉运行时目标一个特定的内存上限。例如，`GOMEMLIMIT=2GiB` 当总内存使用接近 2 GiB 时将触发垃圾回收。

+   `GOGC=off` 禁用了默认的 GC 调度算法，因此垃圾回收仅在内存限制达到时运行。

此配置最大化内存使用效率，并避免了频繁 GC 循环的开销。它特别适用于高吞吐量或对延迟敏感的系统，在这些系统中，可预测的内存使用非常重要。

**示例：**

```go
GOMEMLIMIT=2GiB GOGC=off ./my-app 
```

在这种配置下，内存使用量会自由增长，直到达到 2 GiB 的阈值。在那个点上，Go 执行完整的垃圾回收遍历。

警告

+   总是使用你的实际工作负载进行基准测试。如果你的应用程序产生了大量的短生命周期分配，禁用自动 GC 可能会适得其反。

+   使用 `runtime.ReadMemStats` 或 `pprof` 监控内存压力和 GC 暂停时间。

+   当你的内存使用模式被充分理解和稳定时，这种方法效果最佳。

## 降低 GC 压力的实用策略

### 优先使用栈分配

Go 在可能的情况下始终在栈上分配变量。避免将变量逃逸到堆上：

```go
// BAD: returns pointer to heap-allocated struct
func newUser(name string) *User {
    return &User{Name: name}  // escapes to heap
}

// BETTER: use value types if pointer is unnecessary
func printUser(u User) {
    fmt.Println(u.Name)
} 
```

使用 `go build -gcflags="-m"` 来查看逃逸分析诊断。有关更多详细信息，请参阅 [堆分配和逃逸分析](../stack-alloc/)。

### 使用 `sync.Pool` 为短生命周期的对象

`sync.Pool` 是用于临时、可重复使用的分配的理想选择，这些分配的 GC 成本很高。

```go
var bufPool = sync.Pool{
    New: func() any { return new(bytes.Buffer) },
}

func handler(w http.ResponseWriter, r *http.Request) {
    buf := bufPool.Get().(*bytes.Buffer)
    buf.Reset()
    defer bufPool.Put(buf)

    // Use buf...
} 
```

有关更多详细信息，请参阅 [对象池](../object-pooling/)。

### 批量分配

将分配组合成更少的对象以减少 GC 压力。

```go
// Instead of allocating many small structs, allocate a slice of structs
users := make([]User, 0, 1000)  // single large allocation 
```

有关更多详细信息，请参阅 [内存预分配](../mem-prealloc/)。

## Go 中的弱引用

Go 1.24 添加了 `weak` 包，提供了一种创建弱引用的标准方法——这些引用不会保持其目标对象存活。在像 Go 这样的垃圾收集系统中，强引用扩展了对象的生命周期：只要还有东西指向它，它就不会被收集。这通常是您想要的，但在像缓存、去重映射或对象图这样的结构中，这可能导致内存存活时间远长于预期。弱引用通过允许您在不阻止垃圾收集器回收它的情况下引用对象来解决这一问题。

相比之下，弱引用会告诉垃圾收集器：“如果没有其他强引用，您可以收集这个对象。”这种模式对于构建不应干扰垃圾收集的内存敏感数据结构非常重要。

```go
package main

import (
    "fmt"
    "runtime"
    "weak"
)

type Data struct {
    Value string
}

func main() {
    data := &Data{Value: "Important"}
    wp := weak.Make(data) // create weak pointer

    fmt.Println("Original:", wp.Value().Value)

    data = nil // remove strong reference
    runtime.GC()

    if v := wp.Value(); v != nil {
        fmt.Println("Still alive:", v.Value)
    } else {
        fmt.Println("Data has been collected")
    }
} 
```

```go
Original: Important
Data has been collected 
```

在这个例子中，`wp` 持有一个对 `Data` 对象的弱引用。在强引用（`data`）超出作用域并且垃圾收集器运行后，`Data` 可能会被收集——此时 `wp.Value()` 将返回 nil。这种模式在像缓存或规范映射这样的内存敏感环境中特别有用，在这些环境中，您希望避免人为地延长对象的生命周期。始终在使用之前检查 `Value()` 的结果，因为目标可能已经被回收。

## 基准测试影响

依赖于合成基准测试来评估 Go 的垃圾收集器性能很诱人，但通用基准测试很少能捕捉到真实工作负载的细微差别。内存行为高度依赖于分配模式、对象生命周期、并发性以及短生命周期与长生命周期数据结构的使用频率。

例如，在维护大型内存索引的 CPU 密集型微服务中，垃圾收集的影响将显著不同于具有最小堆使用的 I/O 重的 API 服务器。因此，调优决策应始终基于您的应用程序的配置文件数据。

我们在更专注的文章中涵盖了目标用例及其垃圾收集性能权衡：

+   [对象池](../object-pooling/): 使用 `sync.Pool` 减少分配 churn

+   [堆栈分配和逃逸分析](../stack-alloc/): 通过保持值在堆栈上最小化堆使用

+   [内存预分配](../mem-prealloc/): 避免切片和映射的不必要增长

当应用于正确的上下文时，这些技术可以产生可测量的差异，但它们不适合一刀切的基准测试。
