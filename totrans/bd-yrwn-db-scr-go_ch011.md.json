["```go\n[](#cb1-1)type TableDef struct {\n[](#cb1-2)    // user defined\n[](#cb1-3)    Name    string\n[](#cb1-4)    Types   []uint32   // column types\n[](#cb1-5)    Cols    []string   // column names\n[](#cb1-6)    Indexes [][]string // the first index is the primary key\n[](#cb1-7)    // auto-assigned B-tree key prefixes for different tables and indexes\n[](#cb1-8)    Prefixes []uint32\n[](#cb1-9)}\n```", "```go\n[](#cb2-1)create table t1 (\n[](#cb2-2)    k1 string,\n[](#cb2-3)    k2 int,\n[](#cb2-4)    v1 string,\n[](#cb2-5)    v2 string,\n[](#cb2-6)    primary key (k1, k2),\n[](#cb2-7)    index idx1 (v1),\n[](#cb2-8)    index idx2 (v2, k2)\n[](#cb2-9));\n```", "```go\n[](#cb3-1)type Scanner struct {\n[](#cb3-2)    // the range, from Key1 to Key2\n[](#cb3-3)    Cmp1 int // CMP_??\n[](#cb3-4)    Cmp2 int\n[](#cb3-5)    Key1 Record\n[](#cb3-6)    Key2 Record\n[](#cb3-7)    // internal\n[](#cb3-8)    db     *DB\n[](#cb3-9)    tdef   *TableDef\n[](#cb3-10)    index  int    // which index?\n[](#cb3-11)    iter   *BIter // the underlying B-tree iterator\n[](#cb3-12)    keyEnd []byte // the encoded Key2\n[](#cb3-13)}\n```", "```go\n[](#cb4-1)func dbScan(db *DB, tdef *TableDef, req *Scanner) error {\n[](#cb4-2)    // ...\n[](#cb4-3)    isCovered := func(index []string) bool {\n[](#cb4-4)        key := req.Key1.Cols\n[](#cb4-5)        return len(index) >= len(key) && slices.Equal(index[:len(key)], key)\n[](#cb4-6)    }\n[](#cb4-7)    req.index = slices.IndexFunc(tdef.Indexes, isCovered)\n[](#cb4-8)    // ...\n[](#cb4-9)}\n```", "```go\n[](#cb5-1)// order-preserving encoding\n[](#cb5-2)func encodeValues(out []byte, vals []Value) []byte {\n[](#cb5-3)    for _, v := range vals {\n[](#cb5-4)        out = append(out, byte(v.Type)) // *added*: doesn't start with 0xff\n[](#cb5-5)        switch v.Type {\n[](#cb5-6)        case TYPE_INT64:\n[](#cb5-7)            var buf [8]byte\n[](#cb5-8)            u := uint64(v.I64) + (1 << 63)        // flip the sign bit\n[](#cb5-9)            binary.BigEndian.PutUint64(buf[:], u) // big endian\n[](#cb5-10)            out = append(out, buf[:]...)\n[](#cb5-11)        case TYPE_BYTES:\n[](#cb5-12)            out = append(out, escapeString(v.Str)...)\n[](#cb5-13)            out = append(out, 0) // null-terminated\n[](#cb5-14)        default:\n[](#cb5-15)            panic(\"what?\")\n[](#cb5-16)        }\n[](#cb5-17)    }\n[](#cb5-18)    return out\n[](#cb5-19)}\n```", "```go\n[](#cb6-1)// for primary keys and indexes\n[](#cb6-2)func encodeKey(out []byte, prefix uint32, vals []Value) []byte {\n[](#cb6-3)    // 4-byte table prefix\n[](#cb6-4)    var buf [4]byte\n[](#cb6-5)    binary.BigEndian.PutUint32(buf[:], prefix)\n[](#cb6-6)    out = append(out, buf[:]...)\n[](#cb6-7)    // order-preserving encoded keys\n[](#cb6-8)    out = encodeValues(out, vals)\n[](#cb6-9)    return out\n[](#cb6-10)}\n[](#cb6-11)\n[](#cb6-12)// for the input range, which can be a prefix of the index key.\n[](#cb6-13)func encodeKeyPartial(\n[](#cb6-14)    out []byte, prefix uint32, vals []Value, cmp int,\n[](#cb6-15)) []byte {\n[](#cb6-16)    out = encodeKey(out, prefix, vals)\n[](#cb6-17)    if cmp == CMP_GT || cmp == CMP_LE { // encode missing columns as infinity\n[](#cb6-18)        out = append(out, 0xff) // unreachable +infinity\n[](#cb6-19)    } // else: -infinity is the empty string\n[](#cb6-20)    return out\n[](#cb6-21)}\n```", "```go\n[](#cb7-1)type UpdateReq struct {\n[](#cb7-2)    tree *BTree\n[](#cb7-3)    // out\n[](#cb7-4)    Added   bool   // added a new key\n[](#cb7-5)    Updated bool   // added a new key or an old key was changed\n[](#cb7-6)    Old     []byte // the value before the update\n[](#cb7-7)    // in\n[](#cb7-8)    Key  []byte\n[](#cb7-9)    Val  []byte\n[](#cb7-10)    Mode int\n[](#cb7-11)}\n```", "```go\n[](#cb8-1)func dbUpdate(db *DB, tdef *TableDef, rec Record, mode int) (bool, error) {\n[](#cb8-2)    // ...\n[](#cb8-3)    // insert the row\n[](#cb8-4)    req := UpdateReq{Key: key, Val: val, Mode: mode}\n[](#cb8-5)    if _, err = db.kv.Update(&req); err != nil {\n[](#cb8-6)        return false, err\n[](#cb8-7)    }\n[](#cb8-8)    // maintain secondary indexes\n[](#cb8-9)    if req.Updated && !req.Added {\n[](#cb8-10)        // use `req.Old` to delete the old indexed keys ...\n[](#cb8-11)    }\n[](#cb8-12)    if req.Updated {\n[](#cb8-13)        // add the new indexed keys ...\n[](#cb8-14)    }\n[](#cb8-15)    return req.Updated, nil\n[](#cb8-16)}\n```"]