- en: 14\. Query Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 查询语言
- en: 14.1 Expression evaluation
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 表达式评估
- en: Both `SELECT` and `UPDATE` contain expressions on columns that need evaluation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 和 `UPDATE` 都包含需要评估的列表达式。'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Evaluating a tree is as obvious as it was discussed in the previous chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 评估树与上一章讨论的一样明显。
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`INSERT` contains expressions on constants that are evaluated with an empty
    `env`.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT` 包含用空 `env` 评估的常量表达式。'
- en: 14.2 Range queries
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 范围查询
- en: Set up a range query
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置范围查询。
- en: Both `SELECT`, `UPDATE`, and `DELETE` can do range queries, the difference is
    what to do with the results. `QLScan` is the common part that represents a range
    query.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`、`UPDATE` 和 `DELETE` 都可以进行范围查询，区别在于如何处理结果。`QLScan` 是表示范围查询的共同部分。'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It has 3 phases: `INDEX BY`, `LIMIT`, and `FILTER`. `Scanner` implements the
    `INDEX BY`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它有 3 个阶段：`INDEX BY`、`LIMIT` 和 `FILTER`。`Scanner` 实现了 `INDEX BY`。
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Revisit the infinity encoding
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新审视无穷编码
- en: '`INDEX BY` takes 1 of the 3 forms defined in the last chapter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`INDEX BY` 采用上一章中定义的 3 种形式之一。'
- en: '`a > start AND a < end`: An interval of (*s**t**a**r**t*, *e**n**d*).'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a > start AND a < end`：一个区间 (*s**t**a**r**t*, *e**n**d*).'
- en: '`a > s`: An open-ended interval of (*s*, +∞).'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a > s`：一个开区间 (*s*, +∞)。'
- en: '`a = p`: A prefix of the index.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a = p`：索引的前缀。'
- en: Let’s say the index is (*a*, *b*). Queries using a prefix of the index are already
    handled by the key encoding in chapter 10\. So …
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设索引是 (*a*, *b*)。使用索引前缀的查询已经在第 10 章中的键编码中处理了。所以……
- en: '`a = p` is equivalent to `a >= p AND a <= p`, encoded as (*a*, *b*) ≥ (*p*, −∞)
    and (*a*, *b*) ≤ (*p*, +∞).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a = p` 等价于 `a >= p AND a <= p`，编码为 (*a*, *b*) ≥ (*p*, −∞) 和 (*a*, *b*) ≤ (*p*,
    +∞)。'
- en: '`a > s` is equivalent to `a > s AND () <= ()`, encoded as (*a*, *b*) > (*s*, −∞)
    and (*a*,) < (+∞,).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a > s` 等价于 `a > s AND () <= ()`，编码为 (*a*, *b*) > (*s*, −∞) 和 (*a*,) < (+∞,).'
- en: Since the use of the empty tuple `()`, `Key1` and `Key2` can now have a different
    set of columns, so we have to modify the index selection to allow this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了空元组 `()`, `Key1` 和 `Key2` 现在可以有不同的列集，因此我们必须修改索引选择以允许这样做。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 14.3 Results iterator
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 结果迭代器
- en: Iterators all the way down
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一直到底的迭代器
- en: The next phases are `LIMIT` and `FILTER`. The results are consumed from iterators.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是 `LIMIT` 和 `FILTER`。结果从迭代器中消费。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why use iterators instead of an array of results? Because a DB can potentially
    work with larger-than-memory data, an iterator doesn’t require the results to
    be ready in memory at once, it can even stream the results as they’re produced.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用迭代器而不是结果数组？因为数据库可以潜在地处理大于内存的数据，迭代器不需要一次性将结果准备好在内存中，它甚至可以在结果产生时流式传输结果。
- en: A chain of iterators for a `SELECT`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 的迭代器链。'
- en: '| Iterator | Out | Role |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 迭代器 | 输出 | 角色 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `BIter` | KV | Iterate through the B+tree. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `BIter` | KV | 遍历 B+ 树。|'
- en: '| `KVIter` | KV | Combine the snapshot with local updates. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `KVIter` | KV | 将快照与本地更新合并。|'
- en: '| `Scanner` | Row | Decode records and follow secondary indexes. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner` | 行 | 解码记录并跟随二级索引。|'
- en: '| `qlScanIter` | Row | Offset, limit, and filter rows. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `qlScanIter` | 行 | 偏移量、限制和过滤行。|'
- en: '| `qlSelectIter` | Row | Evaluate expressions in `SELECT`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `qlSelectIter` | 行 | 在 `SELECT` 中评估表达式。|'
- en: Transform data with iterators
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代器转换数据
- en: An iterator takes another iterator as input to transform a stream of items.
    This is a useful programming pattern.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器接受另一个迭代器作为输入以转换项目流。这是一种有用的编程模式。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`qlScanIter` is a bit more involved, as some bookkeeping is required for filtering.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`qlScanIter` 稍微复杂一些，因为过滤需要一些记录。'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 14.4 Conclusions and next steps
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 结论和下一步
- en: 'We have multiple interfaces to a persistent, transactional DB:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个接口到持久性、事务性数据库：
- en: A KV that can be embedded in applications.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以嵌入到应用程序中的键值对。
- en: A relational DB that can be embedded in applications.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以嵌入到应用程序中的关系型数据库。
- en: A SQL-like query language for the relational DB.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关系型数据库的类似 SQL 的查询语言。
- en: Without adding new functionality, we can create a *network protocol* to allow
    the DB to run in a different process or machine. Network programming in Go is
    high-level and easy, but you can always learn more with a “from scratch” attitude,
    which you can find in the [“Build Your Own Redis”](https://build-your-own.org/redis/)
    book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不添加新功能，我们可以创建一个 *网络协议* 来允许数据库在不同的进程或机器上运行。Go 中的网络编程是高级且简单的，但你可以始终以“从头开始”的态度学习更多，这在
    [“自己动手构建 Redis”](https://build-your-own.org/redis/) 一书中可以找到。
- en: Since we have a basic parser and interpreter, we can take on compilers. You
    can create a programming language and compile to machine code instead of merely
    interpreting it. See the [“From Source Code To Machine Code”](https://build-your-own.org/compiler/)
    book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个基本的解析器和解释器，我们可以着手处理编译器。你可以创建一种编程语言，并将其编译成机器码，而不是仅仅进行解释。参见[“从源代码到机器码”](https://build-your-own.org/compiler/)这本书。
