<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch007.xhtml</title>
  <style>
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #fffadf; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #008080; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #556622; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #008080; font-style: italic; } /* Comment */
    code span.cv { color: #008080; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #008080; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #008080; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="append-only-kv-store" class="level1">
<h1>06. Append-Only KV Store</h1>
<section id="what-we-will-do-1" class="level2">
<h2>6.1 What we will do</h2>
<p>We’ll create a KV store with a copy-on-write B+tree backed by a file.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> KV <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    Path   <span class="dt">string</span> <span class="co">// file name</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// internals</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    fd   <span class="dt">int</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    tree BTree</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// more ...</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> Open<span class="op">()</span> <span class="dt">error</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> Get<span class="op">(</span>key <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> <span class="dt">bool</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> db<span class="op">.</span>tree<span class="op">.</span>Get<span class="op">(</span>key<span class="op">)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> Set<span class="op">(</span>key <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> val <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>tree<span class="op">.</span>Insert<span class="op">(</span>key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> updateFile<span class="op">(</span>db<span class="op">)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> Del<span class="op">(</span>key <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="op">(</span><span class="dt">bool</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    deleted <span class="op">:=</span> db<span class="op">.</span>tree<span class="op">.</span>Delete<span class="op">(</span>key<span class="op">)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> deleted<span class="op">,</span> updateFile<span class="op">(</span>db<span class="op">)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The scope of this chapter is durability + atomicity:</p>
<ul>
<li>The file is append-only; space reuse is left to the next chapter.</li>
<li>We will ignore concurrency and assume sequential access within 1 process.</li>
</ul>
<p>We’ll implement the 3 B+tree callbacks that deal with disk pages:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> BTree <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    root <span class="dt">uint64</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    get <span class="kw">func</span><span class="op">(</span><span class="dt">uint64</span><span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span> <span class="co">// read a page</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span> <span class="kw">func</span><span class="op">([]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">uint64</span> <span class="co">// append a page</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    del <span class="kw">func</span><span class="op">(</span><span class="dt">uint64</span><span class="op">)</span>        <span class="co">// ignored in this chapter</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<!-- `BTree.new` captures new pages,
and `updateFile` updates the file with respect to durability and atomicity. -->
</section>
<section id="two-phase-update" class="level2">
<h2>6.2 Two-phase update</h2>
<section id="atomicity-durability" class="level3">
<h3>Atomicity + durability</h3>
<p>As discussed in chapter 03, for a copy-on-write tree, the root pointer is updated atomically. Then <code>fsync</code> is used to <em>request</em> and <em>confirm</em> durability.</p>
<p>The atomicity of the root pointer itself is insufficient; to make the whole tree atomic, new nodes must be persisted <em>before</em> the root pointer. And <strong>the write order is not the order in which the data is persisted</strong>, due to factors like caching. So another <code>fsync</code> is used to ensure the order.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> updateFile<span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 1. Write new nodes.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> writePages<span class="op">(</span>db<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2. `fsync` to enforce the order between 1 and 3.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> syscall<span class="op">.</span>Fsync<span class="op">(</span>db<span class="op">.</span>fd<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 3. Update the root pointer atomically.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> updateRoot<span class="op">(</span>db<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 4. `fsync` to make everything persistent.</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> syscall<span class="op">.</span>Fsync<span class="op">(</span>db<span class="op">.</span>fd<span class="op">)</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="alternative-durability-with-a-log" class="level3">
<h3>Alternative: durability with a log</h3>
<p>The alternative double-write scheme also has 2 <code>fsync</code>’ed phases:</p>
<ol type="1">
<li>Write the updated pages with checksum.</li>
<li><code>fsync</code> to make the update persistent (for crash recovery).</li>
<li>Update the data in-place (apply the double-writes).</li>
<li><code>fsync</code> for the order between 3 and 1 (reuse or delete the double-writes).</li>
</ol>
<p>A difference with copy-on-write is the order of the phases: the data is persistent after the 1st <code>fsync</code>; the DB can return success and do the rest in the background.</p>
<p>The double-write is comparable to a log, which also needs only 1 <code>fsync</code> for an update. And it can be an actual log to buffer multiple updates, which improves performance. This is another example of logs in DBs, besides the LSM-tree.</p>
<p>We won’t use a log as copy-on-write doesn’t need it. But a log still offers the benefits discussed above; it’s one of the reasons logs are ubiquitous in databases.</p>
</section>
<section id="concurrency-of-in-memory-data" class="level3">
<h3>Concurrency of in-memory data</h3>
<p>Atomicity for in-memory data (w.r.t. concurrency) can be achieved with a mutex (lock) or some atomic CPU instructions. There is a similar problem: memory reads/writes may not appear in order due to factors like out-of-order execution.</p>
<p>For an in-memory copy-on-write tree, new nodes must be made visible to concurrent readers <em>before</em> the root pointer is updated. This is called a <em>memory barrier</em> and is analogous to <code>fsync</code>, although <code>fsync</code> is more than enforcing order.</p>
<p>Synchronization primitives such as mutexes, or any OS syscalls, will enforce memory ordering in a portable way, so you don’t have to mess with CPU-specific atomics or barriers (which are inadequate for concurrency anyway).</p>
</section>
</section>
<section id="database-on-a-file" class="level2">
<h2>6.3 Database on a file</h2>
<section id="the-file-layout" class="level3">
<h3>The file layout</h3>
<p>Our DB is a single file divided into “pages”. Each page is a B+tree node, except for the 1st page; the 1st page contains the pointer to the latest root node and other auxiliary data, we call this the <em>meta page</em>.</p>
<pre><code>|     the_meta_page    | pages... | root_node | pages... | (end_of_file)
| root_ptr | page_used |                ^                ^
      |          |                      |                |
      +----------|----------------------+                |
                 |                                       |
                 +---------------------------------------+</code></pre>
<p>New nodes are simply appended like a log, but we cannot use the file size to count the number of pages, because after a power loss the file size (metadata) may become inconsistent with the file data. This is filesystem dependent, we can avoid this by storing the number of pages in the meta page.</p>
</section>
<section id="fsync-on-directory" class="level3">
<h3>`fsync` on directory</h3>
<p>As mentioned in chapter 01, <code>fsync</code> must be used on the parent directory after a <code>rename</code>. This is also true when creating new files, because there are 2 things to be made persistent: the file data, and the directory that references the file.</p>
<p>We’ll preemptively <code>fsync</code> after potentially creating a new file with <code>O_CREATE</code>. To <code>fsync</code> a directory, <code>open</code> the directory in <code>O_RDONLY</code> mode.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> createFileSync<span class="op">(</span>file <span class="dt">string</span><span class="op">)</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// obtain the directory fd</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    flags <span class="op">:=</span> os<span class="op">.</span>O_RDONLY <span class="op">|</span> syscall<span class="op">.</span>O_DIRECTORY</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    dirfd<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>Open<span class="op">(</span>path<span class="op">.</span>Dir<span class="op">(</span>file<span class="op">),</span> flags<span class="op">,</span> <span class="bn">0o644</span><span class="op">)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;open directory: %w&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">defer</span> syscall<span class="op">.</span>Close<span class="op">(</span>dirfd<span class="op">)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// open or create the file</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    flags <span class="op">=</span> os<span class="op">.</span>O_RDWR <span class="op">|</span> os<span class="op">.</span>O_CREATE</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    fd<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>Openat<span class="op">(</span>dirfd<span class="op">,</span> path<span class="op">.</span>Base<span class="op">(</span>file<span class="op">),</span> flags<span class="op">,</span> <span class="bn">0o644</span><span class="op">)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;open file: %w&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// fsync the directory</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">=</span> syscall<span class="op">.</span>Fsync<span class="op">(</span>dirfd<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=</span> syscall<span class="op">.</span>Close<span class="op">(</span>fd<span class="op">)</span>  <span class="co">// may leave an empty file</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;fsync directory: %w&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fd<span class="op">,</span> <span class="ot">nil</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The directory fd can be used by <code>openat</code> to open the target file, which guarantees that the file is from the same directory we opened before, in case the directory path is replaced in between (race condition). Although this is not our concern as we don’t expect multi-process operations.</p>
</section>
<section id="mmap-page-cache-and-io" class="level3">
<h3>`mmap`, page cache and IO</h3>
<p><code>mmap</code> is a way to read/write a file as if it’s an in-memory buffer. Disk IO is implicit and automatic with <code>mmap</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> Mmap<span class="op">(</span>fd <span class="dt">int</span><span class="op">,</span> offset <span class="dt">int64</span><span class="op">,</span> length <span class="dt">int</span><span class="op">,</span> <span class="op">...)</span> <span class="op">(</span>data <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span></code></pre></div>
<p>To understand <code>mmap</code>, let’s review some operating system basics. An OS page is the minimum unit for mapping between virtual address and physical address. However, the virtual address space of a process is not fully backed by physical memory all the time; part of the process memory can be swapped to disk, and when the process tries to access it:</p>
<ol type="1">
<li>The CPU triggers a <em>page fault</em>, which hands control to the OS.</li>
<li>The OS then …
<ol type="1">
<li>Reads the swapped data into physical memory.</li>
<li>Remaps the virtual address to it.</li>
<li>Hands control back to the process.</li>
</ol></li>
<li>The process resumes with the virtual address mapped to real RAM.</li>
</ol>
<p><code>mmap</code> works in a similar way, the process gets an address range from <code>mmap</code> and when it touches a page in it, it page faults and the OS reads the data into a cache and remaps the page to the cache. That’s the automatic IO in a read-only scenario.</p>
<p>The CPU also takes note (called a dirty bit) when the process modifies a page so the OS can write the page back to disk later. <code>fsync</code> is used to request and wait for the IO. This is writing data via <code>mmap</code>, it is not very different from <code>write</code> on Linux because <code>write</code> goes to the same page cache.</p>
<p>You don’t have to <code>mmap</code>, but it’s important to understand the basics.</p>
</section>
</section>
<section id="manage-disk-pages" class="level2">
<h2>6.4 Manage disk pages</h2>
<p>We’ll use <code>mmap</code> to implement these page management callbacks. because it’s just convenient.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> Open<span class="op">()</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>tree<span class="op">.</span>get <span class="op">=</span> db<span class="op">.</span>pageRead   <span class="co">// read a page</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>tree<span class="op">.</span><span class="bu">new</span> <span class="op">=</span> db<span class="op">.</span>pageAppend <span class="co">// apppend a page</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>tree<span class="op">.</span>del <span class="op">=</span> <span class="kw">func</span><span class="op">(</span><span class="dt">uint64</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<section id="invoke-mmap" class="level3">
<h3>Invoke `mmap`</h3>
<p>A file-backed <code>mmap</code> can be either read-only, read-write, or copy-on-write. To create a read-only <code>mmap</code>, use the <code>PROT_READ</code> and <code>MAP_SHARED</code> flags.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Mmap<span class="op">(</span>fd<span class="op">,</span> offset<span class="op">,</span> size<span class="op">,</span> syscall<span class="op">.</span>PROT_READ<span class="op">,</span> syscall<span class="op">.</span>MAP_SHARED<span class="op">)</span></span></code></pre></div>
<p>The mapped range can be larger than the current file size, which is a fact that we can exploit because the file will grow.</p>
<!-- In x64, the virtual address space is 48-bit (256TB),
and for most use cases, a single 1TB `mmap` will probably last forever.
However, this isn't viable on 32-bit systems. -->
</section>
<section id="mmap-a-growing-file" class="level3">
<h3>`mmap` a growing file</h3>
<p><code>mremap</code> remaps a mapping to a larger range, it’s like <code>realloc</code>. That’s one way to deal with the growing file. However, the address may change, which can hinder concurrent readers in later chapters. Our solution is to add new mappings to cover the expanded file.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> KV <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    mmap <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        total  <span class="dt">int</span>      <span class="co">// mmap size, can be larger than the file size</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        chunks <span class="op">[][]</span><span class="dt">byte</span> <span class="co">// multiple mmaps, can be non-continuous</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">// `BTree.get`, read a page.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> pageRead<span class="op">(</span>ptr <span class="dt">uint64</span><span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    start <span class="op">:=</span> <span class="dt">uint64</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> chunk <span class="op">:=</span> <span class="kw">range</span> db<span class="op">.</span>mmap<span class="op">.</span>chunks <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        end <span class="op">:=</span> start <span class="op">+</span> <span class="dt">uint64</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>chunk<span class="op">))/</span>BTREE_PAGE_SIZE</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ptr <span class="op">&lt;</span> end <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            offset <span class="op">:=</span> BTREE_PAGE_SIZE <span class="op">*</span> <span class="op">(</span>ptr <span class="op">-</span> start<span class="op">)</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> chunk<span class="op">[</span>offset <span class="op">:</span> offset<span class="op">+</span>BTREE_PAGE_SIZE<span class="op">]</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> end</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">panic</span><span class="op">(</span><span class="st">&quot;bad ptr&quot;</span><span class="op">)</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Adding a new mapping each time the file is expanded results in lots of mappings, which is bad for performance because the OS has to keep track of them. This is avoided with exponential growth, since <code>mmap</code> can go beyond the file size.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> extendMmap<span class="op">(</span>db <span class="op">*</span>KV<span class="op">,</span> size <span class="dt">int</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> size <span class="op">&lt;=</span> db<span class="op">.</span>mmap<span class="op">.</span>total <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">nil</span> <span class="co">// enough range</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    alloc <span class="op">:=</span> max<span class="op">(</span>db<span class="op">.</span>mmap<span class="op">.</span>total<span class="op">,</span> <span class="dv">64</span><span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">)</span> <span class="co">// double the current address space</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> db<span class="op">.</span>mmap<span class="op">.</span>total <span class="op">+</span> alloc <span class="op">&lt;</span> size <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        alloc <span class="op">*=</span> <span class="dv">2</span> <span class="co">// still not enough?</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    chunk<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>Mmap<span class="op">(</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        db<span class="op">.</span>fd<span class="op">,</span> <span class="dt">int64</span><span class="op">(</span>db<span class="op">.</span>mmap<span class="op">.</span>total<span class="op">),</span> alloc<span class="op">,</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        syscall<span class="op">.</span>PROT_READ<span class="op">,</span> syscall<span class="op">.</span>MAP_SHARED<span class="op">,</span> <span class="co">// read-only</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;mmap: %w&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>mmap<span class="op">.</span>total <span class="op">+=</span> alloc</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>mmap<span class="op">.</span>chunks <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>db<span class="op">.</span>mmap<span class="op">.</span>chunks<span class="op">,</span> chunk<span class="op">)</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">nil</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You may wonder why not just create a very large mapping (say, 1TB) and forget about the growing file, since an unrealized virtual address costs nothing. This is OK for a toy DB in 64-bit systems.</p>
</section>
<section id="capture-page-updates" class="level3">
<h3>Capture page updates</h3>
<p>The <code>BTree.new</code> callback collects new pages from B+tree updates, and allocates the page number from the end of DB.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> KV <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    page <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        flushed <span class="dt">uint64</span>   <span class="co">// database size in number of pages</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        temp    <span class="op">[][]</span><span class="dt">byte</span> <span class="co">// newly allocated pages</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> pageAppend<span class="op">(</span>node <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">uint64</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    ptr <span class="op">:=</span> db<span class="op">.</span>page<span class="op">.</span>flushed <span class="op">+</span> <span class="dt">uint64</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">))</span> <span class="co">// just append</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>page<span class="op">.</span>temp <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">,</span> node<span class="op">)</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ptr</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Which are written (appended) to the file after B+tree updates.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> writePages<span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// extend the mmap if needed</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    size <span class="op">:=</span> <span class="op">(</span><span class="dt">int</span><span class="op">(</span>db<span class="op">.</span>page<span class="op">.</span>flushed<span class="op">)</span> <span class="op">+</span> <span class="bu">len</span><span class="op">(</span>db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">))</span> <span class="op">*</span> BTREE_PAGE_SIZE</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> extendMmap<span class="op">(</span>db<span class="op">,</span> size<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// write data pages to the file</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span>db<span class="op">.</span>page<span class="op">.</span>flushed <span class="op">*</span> BTREE_PAGE_SIZE<span class="op">)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> _<span class="op">,</span> err <span class="op">:=</span> unix<span class="op">.</span>Pwritev<span class="op">(</span>db<span class="op">.</span>fd<span class="op">,</span> db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">,</span> offset<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// discard in-memory data</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>page<span class="op">.</span>flushed <span class="op">+=</span> <span class="dt">uint64</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">))</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>page<span class="op">.</span>temp <span class="op">=</span> db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">[:</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">nil</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>pwritev</code> is variant of <code>write</code> with an offset and multiple input buffers. We have to control the offset because we also need to write the meta page later. Multiple input buffers are combined by the kernel. <!-- Multiple input buffers are combined by the kernel
so we don't have to write each page one by one or combine them manually. --></p>
</section>
</section>
<section id="the-meta-page" class="level2">
<h2>6.5 The meta page</h2>
<section id="read-the-meta-page" class="level3">
<h3>Read the meta page</h3>
<p>We’ll also add some magic bytes to the meta page to identify the file type.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> DB_SIG <span class="op">=</span> <span class="st">&quot;BuildYourOwnDB06&quot;</span> <span class="co">// not compatible between chapters</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">// | sig | root_ptr | page_used |</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">// | 16B |    8B    |     8B    |</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> saveMeta<span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> <span class="op">[]</span><span class="dt">byte</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> data <span class="op">[</span><span class="dv">32</span><span class="op">]</span><span class="dt">byte</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">copy</span><span class="op">(</span>data<span class="op">[:</span><span class="dv">16</span><span class="op">],</span> <span class="op">[]</span><span class="dt">byte</span><span class="op">(</span>DB_SIG<span class="op">))</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>LittleEndian<span class="op">.</span>PutUint64<span class="op">(</span>data<span class="op">[</span><span class="dv">16</span><span class="op">:],</span> db<span class="op">.</span>tree<span class="op">.</span>root<span class="op">)</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>LittleEndian<span class="op">.</span>PutUint64<span class="op">(</span>data<span class="op">[</span><span class="dv">24</span><span class="op">:],</span> db<span class="op">.</span>page<span class="op">.</span>flushed<span class="op">)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data<span class="op">[:]</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> loadMeta<span class="op">(</span>db <span class="op">*</span>KV<span class="op">,</span> data <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span></span></code></pre></div>
<p>The meta page is reserved if the file is empty.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> readRoot<span class="op">(</span>db <span class="op">*</span>KV<span class="op">,</span> fileSize <span class="dt">int64</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> fileSize <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span> <span class="co">// empty file</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        db<span class="op">.</span>page<span class="op">.</span>flushed <span class="op">=</span> <span class="dv">1</span> <span class="co">// the meta page is initialized on the 1st write</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">nil</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// read the page</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    data <span class="op">:=</span> db<span class="op">.</span>mmap<span class="op">.</span>chunks<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    loadMeta<span class="op">(</span>db<span class="op">,</span> data<span class="op">)</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// verify the page</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">nil</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="update-the-meta-page" class="level3">
<h3>Update the meta page</h3>
<p>Writing a small amount of page-aligned data to a real disk, modifying only a single sector, is likely power-loss-atomic at the hardware level. Some <a href="https://www.postgresql.org/message-id/flat/17064-bb0d7904ef72add3%40postgresql.org">real databases</a> depend on this. That’s how we update the meta page too.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 3. Update the meta page. it must be atomic.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> updateRoot<span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> _<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>Pwrite<span class="op">(</span>db<span class="op">.</span>fd<span class="op">,</span> saveMeta<span class="op">(</span>db<span class="op">),</span> <span class="dv">0</span><span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;write meta page: %w&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">nil</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>However, atomicity means different things at different levels, as you’ve seen with <code>rename</code>. <code>write</code> is not atomic w.r.t. concurrent readers at the <a href="https://stackoverflow.com/questions/35595685/">system call level</a>. This is likely how the page cache works.</p>
<p>We’ll consider read/write atomicity when we add concurrent transations, but we have already seen a solution: In an LSM-tree, the 1st level is the only thing that is updated, and it’s duplicated as a MemTable, which moves the concurrency problem to memory. We can keep an in-memory copy of the meta page and synchronize it with a mutex, thus avoiding concurrent disk reads/writes.</p>
<p>Even if the hardware is not atomic w.r.t. power loss. Atomicity is achievable with log + checksum. We could switch between 2 checksumed meta pages for each update, to ensure that one of them is good after a power loss. This is called <em>double buffering</em>, which is a rotating log with 2 entries.</p>
</section>
</section>
<section id="error-handling" class="level2">
<h2>6.6 Error handling</h2>
<section id="scenarios-after-io-errors" class="level3">
<h3>Scenarios after IO errors</h3>
<p>The bare minimum of error handling is to propagate errors with <code>if err != nil</code>. Next, consider the possibility of using the DB after an IO error (<code>fsync</code> or <code>write</code>).</p>
<ul>
<li>Read after a failed update?
<ul>
<li>The reasonable choice is to behave as if nothing happened.</li>
</ul></li>
<li>Update it again after a failure?
<ul>
<li>If the error persists, it’s expected to fail again.</li>
<li>If the error is temporary, can we recover from the previous error?</li>
</ul></li>
<li>Restart the DB after the problem is resolved?
<ul>
<li>This is just crash recovery; discussed in chapter 03.</li>
</ul></li>
</ul>
</section>
<section id="revert-to-the-previous-version" class="level3">
<h3>Revert to the previous version</h3>
<p>There is a <a href="https://www.usenix.org/system/files/atc20-rebello.pdf">survey</a> on the handling of <code>fsync</code> failures. From which we can learn that the topic is filesystem dependent. If we read after an <code>fsync</code> failure, some filesystems return the failed data as the page cache doesn’t match the disk. So reading back failed writes is problematic.</p>
<p>But since we’re copy-on-write, this is not a problem; we can revert to the old tree root to avoid the problematic data. The tree root is stored in the meta page, but we never read the meta page from disk after opening a DB, so we’ll just revert the <em>in-memory</em> root pointer.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>db <span class="op">*</span>KV<span class="op">)</span> Set<span class="op">(</span>key <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> val <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    meta <span class="op">:=</span> saveMeta<span class="op">(</span>db<span class="op">)</span> <span class="co">// save the in-memory state (tree root)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    db<span class="op">.</span>tree<span class="op">.</span>Insert<span class="op">(</span>key<span class="op">,</span> val<span class="op">)</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> updateOrRevert<span class="op">(</span>db<span class="op">,</span> meta<span class="op">)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> updateOrRevert<span class="op">(</span>db <span class="op">*</span>KV<span class="op">,</span> meta <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2-phase update</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    err <span class="op">:=</span> updateFile<span class="op">(</span>db<span class="op">)</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// revert on error</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the in-memory states can be reverted immediately to allow reads</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        loadMeta<span class="op">(</span>db<span class="op">,</span> meta<span class="op">)</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// discard temporaries</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        db<span class="op">.</span>page<span class="op">.</span>temp <span class="op">=</span> db<span class="op">.</span>page<span class="op">.</span>temp<span class="op">[:</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> err</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So after a write failure, it’s still possible to use the DB in read-only mode. Reads can also fail, but we’re using <code>mmap</code>, on a read error the process is just killed by <code>SIGBUS</code>. That’s one of the drawbacks of <code>mmap</code>.</p>
</section>
<section id="recover-from-temporary-write-errors" class="level3">
<h3>Recover from temporary write errors</h3>
<p>Some write errors are temporary, such as “no space left”. If an update fails and then the next succeeds, the end state is still good. The problem is the intermediate state: between the 2 updates, the content of the meta page <em>on disk</em> is unknown!</p>
<p>If <code>fsync</code> fails on the meta page, the meta page on disk can be either the new or the old version, while the in-memory tree root is the old version. So the 2nd successful update will overwrite the data pages of the newer version, which can be left in a corrupted intermediate state if crashed.</p>
<p>The solution is to rewrite the last known meta page on recovery.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> KV <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    failed <span class="dt">bool</span> <span class="co">// Did the last update fail?</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> updateOrRevert<span class="op">(</span>db <span class="op">*</span>KV<span class="op">,</span> meta <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ensure the on-disk meta page matches the in-memory one after an error</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> db<span class="op">.</span>failed <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// write and fsync the previous meta page</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        db<span class="op">.</span>failed <span class="op">=</span> <span class="ot">false</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    err <span class="op">:=</span> updateFile<span class="op">(</span>db<span class="op">)</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the on-disk meta page is in an unknown state;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// mark it to be rewritten on later recovery.</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        db<span class="op">.</span>failed <span class="op">=</span> <span class="ot">true</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> err</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We rely on filesystems to report errors correctly, but there is <a href="https://danluu.com/filesystem-errors/">evidence</a> that they don’t. So can the system as a whole handle errors is still doubtful.</p>
</section>
</section>
<section id="summary-of-the-append-only-kv-store" class="level2">
<h2>6.7 Summary of the append-only KV store</h2>
<ul>
<li>File layout for a copy-on-write B+tree.</li>
<li>Durability and atomicity with <code>fsync</code>.</li>
<li>Error handling.</li>
</ul>
<p>B+tree on disk is a major step. We just have to add a free list to make it practical.</p>
</section>
</section>
</body>
</html>
