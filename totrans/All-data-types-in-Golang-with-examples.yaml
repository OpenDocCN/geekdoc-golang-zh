- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:08:44'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: All data types in Golang with examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/all-data-types-in-golang-with-examples/](https://golangbyexample.com/all-data-types-in-golang-with-examples/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Note:** If you are interested in learning Golang, then for that we have a
    golang comprehensive tutorial series. Do check it out – [Golang Comprehensive
    Tutorial Series](https://golangbyexample.com/golang-comprehensive-tutorial/).
    Now let’s see the current tutorial. Below is the table of contents.'
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Basic Types](#Basic_Types "Basic Types")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integers (Signed and UnSigned)](#Integers_Signed_and_UnSigned "Integers (Signed
    and UnSigned)")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Floats](#Floats "Floats")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Complex Numbers](#Complex_Numbers "Complex Numbers")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Byte](#Byte "Byte")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rune](#Rune "Rune")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[String](#String "String")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Booleans](#Booleans "Booleans")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Composite Types](#Composite_Types "Composite Types")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Non-Reference Types](#Non-Reference_Types "Non-Reference Types")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Arrays](#Arrays "Arrays")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Structs](#Structs "Structs")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reference Types](#Reference_Types "Reference Types")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Slices](#Slices "Slices")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Channels](#Channels "Channels")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Maps](#Maps "Maps")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pointers](#Pointers "Pointers")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions](#Functions "Functions")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Interface](#Interface "Interface")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Special case of empty interface](#Special_case_of_empty_interface "Special
    case of empty interface")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")*  *# Overview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Golang is statically typed programming language meaning that each variable has
    a type. Go has several built in types that we will look into in this article.
    Data types in Go can be categorized into two types
  prefs: []
  type: TYPE_NORMAL
- en: Basic Types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Composite Types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basic Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: int8
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: int16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: int32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: int64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsigned
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uint
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uint8
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uint16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uint32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uint64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uintptr
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Floats
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: float32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: float64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex Numbers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: complex64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: complex128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Byte
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rune
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection/Aggregation or Non-Reference Types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference Types
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function/Methods
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Special case of empty Interface
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic Types**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first discuss the basic types in GO.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integers** (Signed and UnSigned)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers can be signed or unsigned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signed**'
  prefs: []
  type: TYPE_NORMAL
- en: Signed integers are of 5 types as below
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| int | Platform Dependent |'
  prefs: []
  type: TYPE_TB
- en: '| int8 | 8 bits/1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| int16 | 16 bits/2 byte |'
  prefs: []
  type: TYPE_TB
- en: '| int32 | 32 bits/4 byte |'
  prefs: []
  type: TYPE_TB
- en: '| int64 | 64 bits/8 byte |'
  prefs: []
  type: TYPE_TB
- en: '**int**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** Platform Dependent.'
  prefs: []
  type: TYPE_NORMAL
- en: On 32 bit machines, the size of an int will be 32 bits or 4 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On 64 bit machines, the size of an int will be 64 bits or 8 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Range**: Again Platform dependent'
  prefs: []
  type: TYPE_NORMAL
- en: On 32 bit machines, the range of int will be -2^(31) to 2^(31) -1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On 64 bit machines, the range of int will be -2^(63) to 2^(63) -1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to use int whenever using signed Integer other than the cases
    mentioned below
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the machine is a 32 bit and range needed is greater than -2^(31) to 2^(31) -1,
    then use **int64** instead **int**. Note that in this case for int64,  2 32-bit
    memory addresses to form a 64-bit number together.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the range is less then use appropriate integer type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties:**'
  prefs: []
  type: TYPE_NORMAL
- en: Declare an int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: int is default type for **integer.** When you don’t specify a type the default
    will be int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**bits** package of golang can help know the size of an **int** on your system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**unsafe.Sizeof()** function can also be used to see the size of int in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full Working Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is the full working code of the above properties
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**int8**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 8 bits or 1 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: -2⁷ to 2⁷ -1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: Use int8 when there it is known that the int range will be between -2⁷ to 2⁷ -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For array values which lies between -27 to 27 -1, is a good use case for using
    int8\. For eg if you are storing ASCII index for lowercase letters then int8 can
    be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good idea to use int8 for data values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare an int8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of int8 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**int16**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 16 bits or 2 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: -2^(15) to 2^(15) -1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: Use int16 when there it is known that the int range will be between -2^(15) to
    2^(15) -1.  For temporary values such as loop invariants, it is still advisable
    to use int even though it might take more space because it is likely to be promoted
    to int in some operations or library calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For array values which lies between -215 to 215 -1, is a good use case for using
    int8\. For eg if you are storing ASCII index for lowercase letters than int16
    can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare an int16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of int16 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**int32**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 32 bits or 4 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: -2^(31) to 2^(31) -1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare an int32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of int8 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**int64**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 64 bits or 8 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: -2^(63) to 2^(63) -1'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**int64** is used when the range is higher. For eg **time.Duration** is of
    type **int64**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare an int64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of int64 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**UnSigned**'
  prefs: []
  type: TYPE_NORMAL
- en: UnSigned integers are of 5 types as below
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| uint | Platform Dependent |'
  prefs: []
  type: TYPE_TB
- en: '| uint8 | 8 bits/1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| uint16 | 16 bits/2 byte |'
  prefs: []
  type: TYPE_TB
- en: '| uint32 | 32 bits/4 byte |'
  prefs: []
  type: TYPE_TB
- en: '| uint64 | 64 bits/8 byte |'
  prefs: []
  type: TYPE_TB
- en: '**uint**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** Platform Dependent.'
  prefs: []
  type: TYPE_NORMAL
- en: On 32 bit machines, the size of an int will be 32 bits or 4 byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On 64 bit machines, the size of an int will be 64 bits or 8 byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Range**: Again Platform dependent'
  prefs: []
  type: TYPE_NORMAL
- en: On 32 bit machines, the range of int will be -2^(31) to 2^(31) -1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On 64 bit machines, the range of int will be -2^(63) to 2^(63) -1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to use uint  whenever using signed Integer other than the
    cases mention below
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the machine is a 32 bit and range needed is greater than -231 to 231 -1,
    then use int64 instead int. Note that in this case for int64,  2 32-bit memory
    addresses to form a 64-bit number together.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the range is less than use the appropriate int type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties:**'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a uint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**bits** package of golang can help know the size of an **uint** on your system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**unsafe.Sizeof()** function can also be used to see the size of uint in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full Working Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is the full working code of above properties
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**uintptr**'
  prefs: []
  type: TYPE_NORMAL
- en: This is an unsigned integer type that is large enough to hold any pointer address.
    Therefore is size and range are platform dependent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** Platform Dependent.'
  prefs: []
  type: TYPE_NORMAL
- en: On 32 bit machines, the size of int will be 32 bits or 4 byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On 64 bit machines, the size of int will be 64 bits or 8 byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Range**: Again Platform dependent'
  prefs: []
  type: TYPE_NORMAL
- en: On 32 bit machines, the range of int will be -2^(31) to 2^(31) -1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On 64 bit machines, the range of int will be -2^(63) to 2^(63) -1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties:**'
  prefs: []
  type: TYPE_NORMAL
- en: A uintptr can be converted to **unsafe.Pointer** and viceversa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic can be performed on the uintptr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uintptr even though it holds a pointer address, is just a value and does not
    references any object. Therefore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its value will not be updated if the corresponding object moves. Eg When goroutine
    stack changes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The corresponding object can be garbage collected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '****When to Use:****'
  prefs: []
  type: TYPE_NORMAL
- en: '***   Its purpose is to be used along with unsafe.Pointer mainly used for unsafe
    memory access.'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to save the pointer address value for printing it or storing it.
    Since the address is just stored and does not reference anything, the corresponding
    object can be garbage collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**uint8**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 8 bits or 1 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**:  0 to 255 or 0 to 2⁸ -1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: Use uint8 when there it is known that the int range will be between 2⁸ -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For array values which lies between  2⁸ -1\. is a good use case for using uint8\.
    For eg if you are storing ASCII index in an array then **uint8** can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare a uint8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of uint8 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**uint16**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 16 bits or 2 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: 0 to 2^(16) -1'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: Use int16 when there it is known that the int range will be between 0 to 2^(16) -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For array values which lies between -0 to 2^(16) -1, is a good use case for
    using int8\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare a uint16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of uint16 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**uint32**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 32 bits or 4 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: 0 to 2^(32) -1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare a uint32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of uint32 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**uint64**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size:** 64 bits or 8 byte'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: 0 to 2^(64) -1'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: uint64 is used when the range is higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare a uint64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of uint64 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Floats**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Floats are numbers with decimals. It is of two types
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** |'
  prefs: []
  type: TYPE_TB
- en: '| float32 | 32 bits or 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| float64 | 64 bits or 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: '**float64** is the default float type. When you initialize a variable with
    a decimal value and don’t specify the float type, the default type inferred will
    be **float64**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**float32**'
  prefs: []
  type: TYPE_NORMAL
- en: '**float32** uses single-precision floating point format to store values. Basically
    it is the set of all IEEE-754 32-bit floating-point numbers. The 32 bits are divided
    into – 1 bit sign, 8 bits exponent, and 23 bits mantissa. float 32 take half much
    size as float 64 and are comparatively faster on some machine architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: 32 bits or 4 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: 1.2E-38 to 3.4E+38′'
  prefs: []
  type: TYPE_NORMAL
- en: '**DefaultValue**: 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: If in your system memory is a bottleneck and range is less, then **float32**
    can be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare a float32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of float32 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**float64**'
  prefs: []
  type: TYPE_NORMAL
- en: float64 uses a double-precision floating-point format to store values. Basically
    it is the set of all IEEE-754 64-bit floating-point numbers. The 64 bits are divided
    into – 1-bit sign, 11 bits exponent, 52 bits mantissa. float64 takes twice as
    much size compared to float32 but can represent numbers more accurately than float32.
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: 32 bits or 4 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: 1.2E-38 to 3.4E+38'
  prefs: []
  type: TYPE_NORMAL
- en: '**DefaultValue**: 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use:**'
  prefs: []
  type: TYPE_NORMAL
- en: When the precision needed is high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example illustrates below points
  prefs: []
  type: TYPE_NORMAL
- en: Declare a float64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of float64 in bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default is float64 when you don’t specify a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Complex Numbers**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex Numbers are of two types
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Property** |'
  prefs: []
  type: TYPE_TB
- en: '| complex64 | Both real and imaginary part are float32 |'
  prefs: []
  type: TYPE_TB
- en: '| complex128 | Both real and imaginary part are float64 |'
  prefs: []
  type: TYPE_TB
- en: The default complex type is complex128
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**'
  prefs: []
  type: TYPE_NORMAL
- en: Complex Numbers can be initialized in two ways
  prefs: []
  type: TYPE_NORMAL
- en: Using complex function. It has below signature. Do make sure that both a and
    b should be of same type , meaning either they both should be float32 or both
    should be float64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using the shorthand syntax. This is used when creating a complex number with
    direct numbers. The complex type created using below method will be of type **complex128**
    if type is not specified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**complex64**'
  prefs: []
  type: TYPE_NORMAL
- en: For complex 64 both real and imaginary part are float32
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: Both real and imaginary part are of same size as float32\. It is
    of size 32 bits or 4 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: Both real and imaginary part range is same as float32 i.e 1.2E-38
    to 3.4E+38'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is a sample code that shows
  prefs: []
  type: TYPE_NORMAL
- en: How to create a complex64 number using the above two method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of a complex64 number. Size will be  8 bytes(4 +4) which is equivalent
    to two float32 numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print type of a complex64 number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: + operation on complex number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**complex128**'
  prefs: []
  type: TYPE_NORMAL
- en: For complex128 both **real** and **imaginary** part are **float64**
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: Both **real** and **imaginary** part are of same size as float64\.
    It is of size 64 bits or 8 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range**: Both **real** and **imaginary** part range is same as **float64**
    i.e -1.7E+308 to +1.7E+308'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is a sample code that shows
  prefs: []
  type: TYPE_NORMAL
- en: How to create a complex128 number using above two method. It also shows when
    type is not specified, the default type will be **complex128**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of a complex128 number. Size will be  16 bytes(8 +8) which is equivalent
    to two float64 numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print type of a complex128 number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different operations on complex number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Byte**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: byte in Go is an alias for **uint8** meaning it is an integer value. This integer
    value is of 8 bits and it represents one byte i.e number between 0-255). A single
    byte therefore can represent ASCII characters. Golang does not have any data type
    of ‘char’. Therefore
  prefs: []
  type: TYPE_NORMAL
- en: byte is used to represent the ASCII character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rune is used to represent all UNICODE characters which include every character
    that exists. We will study about rune later in this tutorial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define Byte**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: While declaring byte we have specify the type, as we have in the program above.
    If we don’t specify the type, then the default type is meant as a **rune.**
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In below code example:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define a byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the byte type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print size of byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Rune**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: rune in Go is  an alias for **int32** meaning it is an integer value. This integer
    value is meant to represent a Unicode Code Point. To understand rune you have
    to know what Unicode is. Below is short description but you can refer to famous
    blog post about it – [The Absolute Minimum Every Software Developer Absolutely,
    Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html)
  prefs: []
  type: TYPE_NORMAL
- en: '**What is UniCode**'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode is a superset of ASCII characters which assigns a unique number to every
    character that exists. This unique number is called Unicode Code Point.
  prefs: []
  type: TYPE_NORMAL
- en: For eg
  prefs: []
  type: TYPE_NORMAL
- en: Digit **0** is represented as Unicode Point **U+0030 (Decimal Value – 48)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small Case **b** is represented as Unicode Point  **U+0062 (Decimal Value –
    98)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pound symbol **£ **is represented as Unicode Point **U+00A3 (Decimal Value
    – 163)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)
    to know about Unicode Point of other characters. But Unicode doesn’t talk about
    how these code points will be saved in memory. This is where **utf-8** comes into
    picture
  prefs: []
  type: TYPE_NORMAL
- en: '**UTF-8**'
  prefs: []
  type: TYPE_NORMAL
- en: utf-8 saves every Unicode Point either using 1, 2, 3 or 4 bytes. ASCII points
    are stored using 1 byte. That is why rune is an alias for int32 because a Unicode
    Point can be of max 4 bytes in Go as in GO every string is encoded using utf-8.
  prefs: []
  type: TYPE_NORMAL
- en: Every rune is intended to refer to one Unicode Point.  For eg if you print a
    string after typecasting it to a rune array then it will print the Unicode Point
    for each of character. For for below string **“0b£”** output will be – **[U+0030
    U+0062 U+00A3]**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Declare Rune**'
  prefs: []
  type: TYPE_NORMAL
- en: A rune is declared using a character between single quotes like below declaring
    a variable named **‘rPound’**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After declaring Rune you can perform below things as well
  prefs: []
  type: TYPE_NORMAL
- en: '**Print Type –** Output will be **int32**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Print Unicode Code Point –** Output will be **U+00A3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Print Character –** Output will be **£**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**When to Use**'
  prefs: []
  type: TYPE_NORMAL
- en: You should use a rune when you intend to save Unicode Code Point in the value.
    A rune array should be used when all values in the array are meant to be a Unicode
    Code Point.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code:**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is the code illustrating each point we discussed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**String**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: string is a read only slice of bytes in golang. String can be initialized in
    two ways
  prefs: []
  type: TYPE_NORMAL
- en: using double quotes “” eg “this”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string in double quotes honors the escape sequences. For eg if the string contains
    a \n then while printing there will be a new line
  prefs: []
  type: TYPE_NORMAL
- en: using back quotes ` eg  \`this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String in back quotes is just a raw string and it does not honor any kind of
    escape sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Each character in a string will occupy some bytes depending upon encoding used.
    For eg in utf-8 encoded string, each character will occupy between 1-4 bytes.
    You can read about utf-8 in this must read famous blog-[The Absolute Minimum Every
    Software Developer Absolutely, Positively Must Know About Unicode and Character
    Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html).   In
    utf-8 , the characters **a** or **b** are encoded using 1  byte while the character
    pound sign **£** is encoded using two bytes . Therefore the string “ab£” will
    output 4 bytes when you will convert the string to byte array and print it like
    below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Also when you try to print the length of the above string using **len(“ab£”),**
    it will output 4 and not 3 because it contains 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that **range** loops over sequences of byte which form each character,
    therefore for the below range loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Output will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are many operations that can be performed on a string. One such operation
    is concatenation which combines two string. The sign ‘+’ is used for concatenation.
    Let’s see full working  code for all above things that we discussed
  prefs: []
  type: TYPE_NORMAL
- en: '**Code:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**Booleans**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data type is **bool** and has two possible values true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default Value: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations:'
  prefs: []
  type: TYPE_NORMAL
- en: AND – &&
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OR  – ||
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negation – !
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: The below code example shows
  prefs: []
  type: TYPE_NORMAL
- en: If not initialized the default value is **false**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the above operations on the bool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Composite Types**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Non-Reference Types**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arraysin go are values. They are fixed-length sequences of the same type. Since
    arrays in Go are values, that is why
  prefs: []
  type: TYPE_NORMAL
- en: When you assign an array to another variable, it copies the entire array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you pass an array as an argument to a function, it makes an entire copy
    of the array instead of passing just the address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array is declared as below. Assume N is the size of the array
  prefs: []
  type: TYPE_NORMAL
- en: Specifying size  and values both
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Specifying size  – No values. Values are set to default zero value of that type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As we said arrays have fixed length. Therefore
  prefs: []
  type: TYPE_NORMAL
- en: We cannot assign an array to a different array of the same type but different
    length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you pass an array as a function argument, then size is also part of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see an example of array. Below example
  prefs: []
  type: TYPE_NORMAL
- en: Illustrates how to declare an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass array as a function argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Structs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In GO struct is named collection of fields. These fields can be of different
    types. Struct acts as a container of related data of heterogeneous data type.
    For example, different attributes are used to represent and employee in an organization.
    Employee can have
  prefs: []
  type: TYPE_NORMAL
- en: Name of string type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age of int type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOB of time.Time type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .. and so on. A struct can be used to represent an employee
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The below program depicts
  prefs: []
  type: TYPE_NORMAL
- en: Declare a struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a struct in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size of a struct is the sum of the size of its fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Reference Types**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Slices**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slices are dynamically sized, reference into the elements of an array. As mentioned
    above arrays are of fixed size, so slices give a more flexible interface to arrays.
    A slice is a reference type as it internally references an array. It is internally
    represented by three fields
  prefs: []
  type: TYPE_NORMAL
- en: Address to the underlying array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length of the slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capacity of the slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slices are typed by the type of the underlying array element, not by its length
    or capacity. Thus two slices will be of the same type if the type of the underlying
    array is same irrespective of its length and capacity. The built in **append**
    function can be used to add more values to the underlying array. If on using **append**
    function the length of the slice increases by current capacity, then a new slice
    is allocated of double the capacity and elements of the current slice are copied
    to that.
  prefs: []
  type: TYPE_NORMAL
- en: The built in function **len** can you used to get the current length of the
    sliceInitialising a slice
  prefs: []
  type: TYPE_NORMAL
- en: Using make – it helps you create a slice specifying the type of array, its length
    and capacity. Specifying length and capacity is optional. If length is specified
    and capacity is not, then capacity will be equal to length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Direct initialization. The below example creates a slice of string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Slices can be also be created from an array or from a different slice.
  prefs: []
  type: TYPE_NORMAL
- en: Below is a program showing an example of a slice showing
  prefs: []
  type: TYPE_NORMAL
- en: Declare a slice using the above ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing append function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to iterate over a slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**Channels**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Channels provide synchronization and communication between goroutines. You can
    think of it as a pipe through which goroutines can send values and receive values.
    The operation <- is used to send or receive, with direction of arrow specifying
    the direction of flow of data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Channel are of two types
  prefs: []
  type: TYPE_NORMAL
- en: '**Unbuffered Channel**- It doesn''t have any capacity to hold and values and
    thus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send on a channel is block unless there is another goroutine to receive.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive is block until there is another goroutine on the other side to send.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffered Channel-** You can specify the size of buffer here and for them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send on a buffer channel only blocks if the buffer is full
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive is the only block is buffer of the channel is empty
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A  channel holds data of a particular type at a time. While creating a channel,
    the type of data l has to be specified while initializing a new channel. Channel
    can be created using make. In the below example, we are creating a channel which
    holds data of type string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Closing a channel
  prefs: []
  type: TYPE_NORMAL
- en: The **close()** function can be used to close a channel. Closing a channel means
    that no more values can be sent to the channel
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a working code example of both buffered and unbuffered channel
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffered Channel Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**UnBuffered Channel Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '**Maps**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: maps are golang builtin datatype similar to a hash which map key to a value.
    maps are referenced data types. When you assign one map to another both refer
    to the same underlying map.
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero Value**'
  prefs: []
  type: TYPE_NORMAL
- en: zero value of a map is nil
  prefs: []
  type: TYPE_NORMAL
- en: '**Declare**'
  prefs: []
  type: TYPE_NORMAL
- en: A map can be declared using the var keyword specifying the type of both it's
    key and value. For eg below map declares a map with the name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**Initialize**'
  prefs: []
  type: TYPE_NORMAL
- en: Using make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Using curly braces. You can specify map literal value in the map or can also
    leave empty curly braces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '**Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: Add to a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Get from a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Delete a key from the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: The below example shows all the points we discussed above
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**Pointers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pointer is a variable that holds a memory address of another variable. The zero
    value of a pointer is nil.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declare a pointer**'
  prefs: []
  type: TYPE_NORMAL
- en: In the below example ex is int pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '**Initialize**'
  prefs: []
  type: TYPE_NORMAL
- en: '**&** used to get the address of a variable'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '* operator can be used to dereference a pointer which means getting the value
    at address stored in the pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Pointers can also be initialized using **new** operator
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Let's see a working code covering all the above points
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '**Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go function are values and can be passed around like a value. Basically,
    function can be used as first-order objects and can be passed around.  The signature
    of a function is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: A function has a name, arguments and returns values. Also, note that there are
    some important differences between method and function in Go. Let's see the signature
    of a method
  prefs: []
  type: TYPE_NORMAL
- en: '**Method:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: From the above signature, it is clear that the method has a receiver argument.
    A receiver can be a struct or any other type. The method will have access to the
    properties of the receiver and can call the receiver's other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Below is a working example of function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '**Interface**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interface is a type in Go which is a collection of method signatures. Any type
    which implements all methods of the interface is of that interface type. Zero
    value of an interface is nil.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature of Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '**Interface are implemented implicitly**'
  prefs: []
  type: TYPE_NORMAL
- en: There is no explicit declaration that a type implements an interface. In fact,
    in Go there doesn't exist any **"implements"** keyword similar to Java.  A type
    implements an interface if it implements all the methods of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is correct to define a variable of an interface type and we can assign any
    concrete type value to this variable if the concrete type implements all the methods
    of the interface. Let's see a working example of interface. In the below program
  prefs: []
  type: TYPE_NORMAL
- en: We declare an interface of name shape with one method **area**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: square struct implements the area method, hence it implicitly implements the
    shape interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we declare the variable of name "s" of type shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s is assigned a concrete value of type square. This works because square struct
    implements all methods of shape interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '**Special case of empty interface**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An empty interface has no methods, hence by default all concrete types implement
    the empty interface. If you write a function that accepts an empty interface then
    you can pass any type to that function. See working code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is all about the builtin data types that exist in Go. Hopefully by going
    through this article you will have better undertstanding of data types in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '[sidetoc](https://golangbyexample.com/tag/sidetoc/)***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
