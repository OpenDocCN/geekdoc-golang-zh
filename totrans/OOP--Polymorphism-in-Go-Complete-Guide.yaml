- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-10-13 06:01:20'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-10-13 06:01:20
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'OOP: Polymorphism in Go Complete Guide'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP：Go中的多态完全指南
- en: 来源：[https://golangbyexample.com/oop-polymorphism-in-go-complete-guide/](https://golangbyexample.com/oop-polymorphism-in-go-complete-guide/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://golangbyexample.com/oop-polymorphism-in-go-complete-guide/](https://golangbyexample.com/oop-polymorphism-in-go-complete-guide/)
- en: Before understanding, polymorphism lets first understand what polymorphism is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解多态之前，首先了解什么是多态。
- en: “Same name many forms”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “同名多形态”
- en: In the programming context, we also come across several use cases in which behavior
    is similar across different context. It is better for such behavior to be represented
    by the same name. This is where polymorphism comes into the picture in the programming
    context. From a programming perspective, there are two kinds of polymorphism possible-
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程上下文中，我们还会遇到许多行为在不同环境中相似的用例。将此类行为用相同的名称表示更为合适。这就是多态在编程中的意义。从编程的角度来看，有两种可能的多态性——
- en: Compile Time Polymorphism – In this type of polymorphism, the compiler is able
    to know which exact functions will be executed for a particular call. Some example
    of compile-time polymorphism is.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时多态——在这种多态中，编译器能够知道特定调用将执行哪些具体函数。编译时多态的示例包括：
- en: Function overloading – same function name having different arguments
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载——同一函数名具有不同的参数。
- en: Operator overloading
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Run Time Polymorphism – In this type of polymorphism, the function to be called
    is decided at run time.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时多态——在这种多态中，调用的函数在运行时决定。
- en: Let’s look at what type of Compile and Runtime Polymorphism is possible in GO
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在GO中可能实现的编译时和运行时多态的类型。
- en: '**[Compile Time Polymorphism in Go](https://golangbyexample.com/compile-time-polymorphism-go)**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Go中的编译时多态](https://golangbyexample.com/compile-time-polymorphism-go)**'
- en: '**[Run Time Polymorphism in Go](https://golangbyexample.com/runtime-polymorphism-go/)**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Go中的运行时多态](https://golangbyexample.com/runtime-polymorphism-go/)**'
- en: '**Conclusion: **'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论：**'
- en: If you have read the above two articles then you will find out that compile-time
    polymorphism is not possible in GoLang. It only has Run-Time Polymorphism. Run-Time
    polymorphism is achieved in GO using interfaces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了以上两篇文章，你会发现GoLang中不支持编译时多态。它只具有运行时多态。运行时多态在GO中是通过接口实现的。
