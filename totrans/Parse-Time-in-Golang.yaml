- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:08:05'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Parse Time in Golang
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/parse-time-in-golang/](https://golangbyexample.com/parse-time-in-golang/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Code](#Code "Code")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parse** function of **time** package in golang can be used to parse the string
    representation of time into **time.Time** object'
  prefs: []
  type: TYPE_NORMAL
- en: Package link – [https://golang.org/pkg/time/#Parse](https://golang.org/pkg/time/#Parse)
  prefs: []
  type: TYPE_NORMAL
- en: If you have worked with time/date formatting/parsing in other languages you
    might have noticed that the other languages use special placeholders for time/date
    formatting. For eg ruby language uses
  prefs: []
  type: TYPE_NORMAL
- en: '%d for day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%Y for year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'etc. Golang, instead of using codes such as above, uses date and time format
    placeholders that look like date and time only. Go uses standard time, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So if you notice Go uses
  prefs: []
  type: TYPE_NORMAL
- en: 01 for the day of the month,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 02 for the month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 03 for hours,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 04 for minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 05 for second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below placeholder table describes the exact mapping. Go takes a more pragmatic
    approach where you don’t need to remember or lookup for the traditional formatting
    codes as in other languages
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Placeholder** |'
  prefs: []
  type: TYPE_TB
- en: '| Day | **2** or **02** or **_2** |'
  prefs: []
  type: TYPE_TB
- en: '| Day of Week | **Monday** or **Mon** |'
  prefs: []
  type: TYPE_TB
- en: '| Month | **01** or **1** or **Jan** or **January** |'
  prefs: []
  type: TYPE_TB
- en: '| Year | **2006** or **06** |'
  prefs: []
  type: TYPE_TB
- en: '| Hour | **03** or **3** or **15** |'
  prefs: []
  type: TYPE_TB
- en: '| Minutes | **04** or **4** |'
  prefs: []
  type: TYPE_TB
- en: '| Seconds | **05** or **5** |'
  prefs: []
  type: TYPE_TB
- en: '| Milli Seconds  (ms) | **.000** //Trailing zero will be includedor **.999**
      //Trailing zero will be omitted |'
  prefs: []
  type: TYPE_TB
- en: '| Micro Seconds (μs) | **.000000** //Trailing zero will be includedor **.999999** 
          //Trailing zero will be omitted |'
  prefs: []
  type: TYPE_TB
- en: '| Nano Seconds (ns) | **.000000000** //Trailing zero will be includedor **.999999999**
    //Trailing zero will be omitted |'
  prefs: []
  type: TYPE_TB
- en: '| am/pm | **PM** or **pm** |'
  prefs: []
  type: TYPE_TB
- en: '| Timezone | **MST** |'
  prefs: []
  type: TYPE_TB
- en: '| Timezone offset | **Z0700** or **Z070000** or **Z07** or **Z07:00** or **Z07:00:00** 
    or **-0700** or  **-070000** or **-07** or **-07:00** or **-07:00:00** |'
  prefs: []
  type: TYPE_TB
- en: Now coming back to time.Parse
  prefs: []
  type: TYPE_NORMAL
- en: '**time.Parse** function takes in two arguments'
  prefs: []
  type: TYPE_NORMAL
- en: First argument is the layout consisting of time format placeholder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second argument is the actual formatted string representing time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way you have to go about this is to make sure that the layout string (first
    argument ) matches the string representation (second argument) of the time you
    want to parse into time.Time.
  prefs: []
  type: TYPE_NORMAL
- en: For parsing **2020-01-29**, layout string should be **06-01-02** or **2006-01-02**
    or something which maps correctly based on the above placeholder table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly for parsing **“2020-Jan-29 Wednesday 12:19:25”** the layout string
    can be **“2006-Jan-02 Monday 03:04:05”**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**time.Parse** will raise an error if it encounters an error while parsing
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below are the working Code Examples of **time.Parse().**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]*'
  prefs: []
  type: TYPE_NORMAL
