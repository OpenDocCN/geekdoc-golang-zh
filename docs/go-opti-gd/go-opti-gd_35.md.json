["```go\nfunc handleWS(conn *websocket.Conn) {\n    for {\n        _, message, err := conn.ReadMessage()\n        if err != nil {\n            break\n        }\n        process(message)\n    }\n}\n\nhttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n    ws, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        return\n    }\n    go handleWS(ws)\n}) \n```", "```go\nvar bufferPool = sync.Pool{\n    New: func() interface{} { return make([]byte, 4096) },\n}\n\nfunc handle(conn net.Conn) {\n    buf := bufferPool.Get().([]byte)\n    defer bufferPool.Put(buf)\n\n    for {\n        n, err := conn.Read(buf)\n        if err != nil {\n            return\n        }\n\n        data := make([]byte, n)\n        copy(data, buf[:n])\n        go process(data)\n    }\n} \n```", "```go\ndata := buf[:n]\ngo process(data) \n```", "```go\nconst timeout = 30 * time.Second\n\nfunc handle(conn net.Conn) {\n    defer conn.Close()\n\n    buffer := make([]byte, 4096) // 4 KB buffer; size depends on protocol and usage\n\n    for {\n        conn.SetReadDeadline(time.Now().Add(timeout))\n        n, err := conn.Read(buffer)\n        if err != nil {\n            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n                return\n            }\n            return\n        }\n\n        conn.SetWriteDeadline(time.Now().Add(timeout))\n        _, err = conn.Write(buffer[:n])\n        if err != nil {\n            return\n        }\n    }\n} \n```", "```go\nfunc handle(ctx context.Context, conn net.Conn) {\n    defer conn.Close()\n\n    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)\n    defer cancel()\n\n    done := make(chan struct{})\n    go func() {\n        select {\n        case <-ctx.Done():\n            conn.Close()\n        case <-done:\n        }\n    }()\n\n    // perform read/write as before\n    close(done)\n} \n```", "```go\ntype RateLimiter struct {\n    tokens chan struct{}\n}\n\nfunc NewRateLimiter(rate int) *RateLimiter {\n    rl := &RateLimiter{tokens: make(chan struct{}, rate)}\n    for i := 0; i < rate; i++ {\n        rl.tokens <- struct{}{}\n    }\n    go func() {\n        ticker := time.NewTicker(time.Second)\n        for range ticker.C {\n            select {\n            case rl.tokens <- struct{}{}:\n            default:\n            }\n        }\n    }()\n    return rl\n}\n\nfunc (rl *RateLimiter) Acquire() {\n    <-rl.tokens\n} \n```", "```go\nrl := NewRateLimiter(100)\nfor {\n    rl.Acquire()\n    // read/process/send\n} \n```", "```go\ntype framedConn struct {\n    net.Conn\n    mw *bufio.Writer\n}\n\nfunc (f *framedConn) WriteFrame(data []byte) error {\n    if err := binary.Write(f.mw, binary.BigEndian, uint32(len(data))); err != nil {\n        return err\n    }\n    if _, err := f.mw.Write(data); err != nil {\n        return err\n    }\n    return f.mw.Flush()\n} \n```"]