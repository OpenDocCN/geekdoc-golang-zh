- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:30:31'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Packages and Modules in Go (Golang) – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/packages-modules-go-second/](https://golangbyexample.com/packages-modules-go-second/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the  chapter 5 of the golang comprehensive tutorial series. Refer to
    this link for other chapters of the series – [Golang Comprehensive Tutorial Series](https://golangbyexample.com/golang-comprehensive-tutorial/)
  prefs: []
  type: TYPE_NORMAL
- en: '**Next Tutorial** – [Variables](https://golangbyexample.com/variables-in-golang-complete-guide/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Previous Tutorial** – [Packages and Modules – Part 1](https://golangbyexample.com/packages-modules-go-first)'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s check out the current tutorial. Below is the table of contents for
    current tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Types of Modules](#Types_of_Modules "Types of Modules")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Package vs Module](#Package_vs_Module "Package vs Module")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Add a dependency to your project](#Add_a_dependency_to_your_project "Add a
    dependency to your project")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Directly adding it to the go.mod file](#Directly_adding_it_to_the_gomod_file
    "Directly adding it to the go.mod file")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do a go get](#Do_a_go_get "Do a go get")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Add the dependency to your source code and do a go mod tidy](#Add_the_dependency_to_your_source_code_and_do_a_go_mod_tidy
    "Add the dependency to your source code and do a go mod tidy")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adding a vendor directory](#Adding_a_vendor_directory "Adding a vendor directory")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Module Import Path](#Module_Import_Path "Module Import Path")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing package within same module](#Importing_package_within_same_module
    "Importing package within same module")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing package from different module locally](#Importing_package_from_different_module_locally
    "Importing package from different module locally")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Selecting the version of library](#Selecting_the_version_of_library "Selecting
    the version of library")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Differ in minor or patch version](#Differ_in_minor_or_patch_version "Differ
    in minor or patch version")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Differ in major version](#Differ_in_major_version "Differ in major version")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[go mod command](#go_mod_command "go mod command")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Direct vs Indirect Dependencies in go.mod file](#Direct_vs_Indirect_Dependencies_in_gomod_file
    "Direct vs Indirect Dependencies in go.mod file")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last tutorial we learn about package in detail and overview of modules.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial we will focus on modules
  prefs: []
  type: TYPE_NORMAL
- en: '**Types of Modules**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learn that module is a directory containing nested go packages. So essentially
    module can be treated as a package only that contains nested packages. We have
    seen in the package tutorial can a package can be either an executable package
    or utility package (non-executable). Similar to package, modules can be of two
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executable module** – We already know that **main** is the executable package
    in GoLang. Hence a module containing the main package is the executable module
    .  The **main** package will contain a **main** function that denotes the start
    of a program. On installing the module having **main** package it will be create
    an executable in the $GOBIN directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-Executable module or Utility Module**– Any package other than **main**
    package is a non-executable package. It is not self executable. It just contains
    the utility function and other utility things which can be utilized by an executable
    package. Hence if the module doesn’t contain the **main** package then it will
    be a non-executable or utility module.  This module is meant to be used as a utility
    and will be imported by other modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a executable for a module  (Only for module with main package)
  prefs: []
  type: TYPE_NORMAL
- en: Do a go build and it will create the executable in the current directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do a go install and it will create the executable in the $GOBIN directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package vs Module**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per module definition, it is a directory containing a collection of nested
    and related go packages **go.mod** at its root.  The **go.mod** file defines the
  prefs: []
  type: TYPE_NORMAL
- en: Module import path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency requirements of the module for a successful build. It defines both
    project’s dependencies requirement and also locks them to their correct version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules provides
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With modules go project doesn’t necessarily have to lie the **$GOPATH/sr**c
    folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also in addition to **go.mod** file go also keeps a **go.sum** file which contains
    the cryptographic hash of bits of all project’s dependent modules. This to make
    validate that your project’s dependent modules are not changed.
  prefs: []
  type: TYPE_NORMAL
- en: The behaviour of packages inside a module is same as earlier. So whatever applied
    for a package also applies now. There is no change in that. However a collection
    of packages can be called as module when there is a requirement to version them
    separately. Also when it is common piece of code and you want to share that code
    across multiple projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Add a dependency to your project**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s explore some ways of adding dependency to your project
  prefs: []
  type: TYPE_NORMAL
- en: Directly adding it to the **go.mod** file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do a **go get**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the dependency to your source code and do a **go mod tidy**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before looking at each of the ways, again let’s create a module first
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Directly adding it to the go.mod file**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can  add direct dependency to the go.mod file too. Let’s do that
  prefs: []
  type: TYPE_NORMAL
- en: Add below dependency to the **go.mod** file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With this dependency go.mod file will look like below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to download the newly added dependency as well. Fo that we can use
    the below command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command will download the **github.com/pborman/uuid** module as well all
    its dependencies. Also, it will update the **go.sum** file with the checksum and
    version of all direct and indirect dependencies. go build as well as go install
    also will download the dependencies and also build the binary. go run will also
    download and run the binary as well. go mod download command is used when you
    want to pre-download the dependencies without build or running it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do a go get**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply doing a go get will also the add the dependency in the go.mod file. Remove
    the uuid dependency we added above from go.mod file and clean up go.sum file.
    Now run below command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now check the contents of go.mod file. Do a cat **go.mod**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The dependency will be marked as **//indirect** as it is not being used in any
    of the source files. Once you do a go build after using this in the source files,
    the //indirect will be removed automatically by go. Also it will update the **go.sum**
    file with the checksum and version of all direct and indirect dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Add the dependency to your source code and do a go mod tidy**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically go mod tidy command makes sure that your go.mod files reflects the
    dependencies that you have actually used in your project. When we run go mod tidy
    command then it will do two things
  prefs: []
  type: TYPE_NORMAL
- en: Add any dependency which is imported in the source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any dependency which is mentioned in the **go.mod** file but not imported
    in any of the source files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see an example. Create a module with an import path as “**sample.com/learn**“
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create a file named **uuid.go** in the same directory with below contents
  prefs: []
  type: TYPE_NORMAL
- en: '**uuid.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have imported the dependency in the uuid.go as well
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s run the below command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command will download all the dependencies that are required in your source
    files and update **go.mod** file with that dependency. After running this command
    let’s now let’s again examine the contents of **go.mod** file. Do a cat **go.mod**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Adding a vendor directory**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to vendor your dependencies,  then below command can be used to
    achieve the same
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It will create a vendor directory inside your project directory. You can also
    check in the vendor directory to your VCS (Version Control System). This becomes
    useful in sense that none of the dependency needs to be downloaded at run time
    as it is already present in the vendor folder checked into VCS
  prefs: []
  type: TYPE_NORMAL
- en: '**Module Import Path**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that module import path is the prefix path that is used
    to import all packages within that module
  prefs: []
  type: TYPE_NORMAL
- en: There can be three cases that decide what import path name can be used with
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: The module is a utility module and you plan to publish your module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module is a utility module and you don’t plan to publish your module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module is a executable module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The module is a utility module and you plan to publish your module**'
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to publish your module then the module name should match the URL
    of the repo which host that module. Go tries to download dependencies from the
    VCS using the same import path of the module.
  prefs: []
  type: TYPE_NORMAL
- en: '**The module is a utility module and you don’t plan to publish your module**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the case when you only mean to use the utility module locally only.
    In this case the import path can be anything.
  prefs: []
  type: TYPE_NORMAL
- en: '**The module is a executable module**'
  prefs: []
  type: TYPE_NORMAL
- en: In this case also module import path can be anything. The module import path
    can be a non-url even if you plan to commit your module into VCS as it will not
    be used by any other module
  prefs: []
  type: TYPE_NORMAL
- en: However it is a good practice to use meaningful import path while creating module
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing package within same module**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any package within the same module can be imported using the import path of
    module + directory containing that package. To illustrate lets create a module
  prefs: []
  type: TYPE_NORMAL
- en: Make a **learn** directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a module with import path as **“sample.com/learn”**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now create main.go (Having main package and main function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And math/math.go – math package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**main.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**math/math.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See how we have imported the math package in the main.go file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here the import path is import path of module which is **sample.com/learn**
    +  directory containing the package which is **math.** Hence “**sample.com/learn/math”**
    . Packages in nested directory can also be imported in the same way. The way it
    works is that since the prefix is the module import path, hence go will know that
    you are trying to import from the same module. So it will directly refer it instead
    of downloading it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing package from different module locally**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases when we want to import a module which is present locally. Let’s
    understand how we can import such a module. But first, we have to create a module
    that can be used by others and then import it into the other module. For that
    let’s create two modules
  prefs: []
  type: TYPE_NORMAL
- en: '**sample.com/math** module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**school** module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**school** module will be calling code of the **sample.com/math** module'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first create the **sample.com/math** module which will be used by **school**
    module
  prefs: []
  type: TYPE_NORMAL
- en: Make a **math** directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a module with import path as **sample.com/math**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a file **math.go** with below contents  in the **math** directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Nowlet’s create the school module
  prefs: []
  type: TYPE_NORMAL
- en: Nowcreate a **school** directory in the same path as **math** directory side
    by side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a module name **school**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s modify the **go.mod** file to import the math module in the school
    module. To import a local module that is not pushed to VCS, we are going to use
    replace directory. The replace directory will replace the module path with the
    path you specify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Create file school.go which is going to use the Add function in **[sample.com](http://sample.com)/math**
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now do a go run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is able to call the Add function of the **[sample.com](http://sample.com)/math**
    module and correctly gives the output as 6.
  prefs: []
  type: TYPE_NORMAL
- en: Also it will update the go.mod with version information of the **[sample.com](http://sample.com)/math**
    module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Selecting the version of library**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how does GO’s approach while selecting the version of the library
    of which two versions are specified in the **go.mod** file, we have to first understand
    Semantic Versioning
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Versioning is comprised of three parts separated by dots. Below is
    the format for versioning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '**v** – it is just an indicator that it is a version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: major_version – It represents the incompatible API changes in the library. So
    when there are changes in the library that is not backward compatible, in that
    case, major_version is incremented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minor_version – It represents the change in functionality of the library in
    a backward-compatible manner. So when there are some functionality changes in
    the library but those changes are backward compatible then, in that case, the
    minor version is incremented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: patch_version – It represents the bug fixes in the library in a backward-compatible
    manner. So when there are bug fixes to the existing functionality of the library,
    then in that case patch_version is incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now there can be two cases
  prefs: []
  type: TYPE_NORMAL
- en: Two versions of the same library is used which only differ in the minor and
    patch version. Their major version is the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two versions of the same library is used which differ in the major.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see what approach does go follows in the above two cases
  prefs: []
  type: TYPE_NORMAL
- en: '**Differ in minor or patch version**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go follows the minimum version policy approach while selecting the version of
    the library of which two versions are specified in the **go.mod** file which differ
    only in their minor or patch version.
  prefs: []
  type: TYPE_NORMAL
- en: For example in case you are using the two versions of same library which are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: then go will choose 1.3.0 as it is the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Differ in major version**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go treats the major version as a different module itself. Now, what does that
    means? This essentially means that the import path will have a major version as
    its suffix. Let’s take the example of any go library with VCS as **github.com/sample**.
    Let’s latest semantic version is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then the go.mod file will like below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It has major version in its import path. So any library which is using this
    sample library have to import it like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If in future **v9** version is released than it has to be imported in the application
    like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Also the library will change its go.mod file to reflect the v9 major version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What it essentially allows is to use different major version of the same library
    to be used within same go application.  We can also give meaningful names when
    different major version of the same library is imported in the same application.
    For eg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is also known as **Semantic Import Versioning**
  prefs: []
  type: TYPE_NORMAL
- en: Also note that
  prefs: []
  type: TYPE_NORMAL
- en: For the first version it is ok to not specify the version in the go.mod file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also be careful when importing different major version of the same library.
    Look out for the new functionality that might be available with new versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also for the same reason when you update a specific module using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: then it will only upgrade to the latest minor version or patch version whichever
    applicable. For example let’s say the current version used by an application is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Also let’s say we have below versions available
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then when we run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: then it will update to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The reason is because go get will only update the minor or patch version but
    never the major version as go treats major version of a module as a different
    module entirely.
  prefs: []
  type: TYPE_NORMAL
- en: To upgrade the major version, specify that  upgraded dependency explicitly 
    in the **go.mod** file or do a go get of that version.
  prefs: []
  type: TYPE_NORMAL
- en: Also couple of points to note about upgrading module
  prefs: []
  type: TYPE_NORMAL
- en: To upgrade a dependency to its latest patch version only, use below command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To upgrade a dependency to a specific version, use below command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To upgrade a dependency to a specific commit, use below command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To upgrade all dependency to their latest minor and patch version, use below
    command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**go mod command**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below are some of the options for the go mod command.
  prefs: []
  type: TYPE_NORMAL
- en: '**download –** It will download the the required dependencies to the  $GOPATH/pkg/mod/cache
    folder.  Also it will update the **go.sum** file with the checksum and version
    of all direct and indirect dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**edit** – This is for editing the go.mod file. It provides a set of editing
    flags. Run below command to see set of all editing flags available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: go help mod editFor eg below are some editing flags available
  prefs: []
  type: TYPE_NORMAL
- en: '**-fmt** flag will format the go.mod file. It will not make any other change'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**-module** flag can be used to set the module’s import path'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**graph** – This can be used to print the module requirement dependency graph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**init** – We already have seen the usage of this command above. It is used
    to init a new module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tidy** – This command will download all the dependencies that are required
    in your source files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vendor** – If you want to vendor your dependencies,  then below command can
    be used to achieve the same. It will create a vendor directory inside your project
    directory. You can also check in the vendor directory to your VCS (Version Control
    System)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**verify –** This command checks for the modification of current downloaded
    dependencies. If any of the downloaded dependency has been verified that it will
    exit with a non-zero code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**why –** this command analyzes the graph of packages from the main module.
    It prints the shortest path from the main module to the given package. For instance
    the school module which we created in section “Importing package from different
    module locally” if we print why command as below'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: then below will be the output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The output illustrates that the [sample.com](http://sample.com)/math package
    is at one distance in the graph from main module which is school here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct vs Indirect Dependencies in go.mod file**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A direct dependency is the dependency which the module directly imports . An
    indirect dependency is the dependency which are imported by module’s direct dependencies.
    Also, any dependency that is mentioned in the **go.mod** file but not imported
    in any of the source files of the module is also treated as an indirect dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '**go.mod** file only records the direct dependency.However it may record an
    indirect dependency in below cases'
  prefs: []
  type: TYPE_NORMAL
- en: Any indirect dependency which is not listed in the go.mod file of your direct
    dependency or if direct dependency doesn’t have a go.mod file , then that direct
    dependency will be added to the go.mod file with //direct as the suffix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any dependency which is not imported in any of the source file of the module
    (Example of this we have already seen earlier in the tutorial)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**go.sum** will record the checksum of direct and indirect dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of Indirect Dependencies in go.mod file**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand it with an example. For that let’s first create a module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let’s add colly lib version v1.2.0 as a dependency in the go.mod file. colly
    version v1.2.0 doesn’t have a go.mod file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now create a file learn.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now do a go build. Since colly version v1.2.0 doesn’t have a go.mod file , all
    dependencies required by colly will be added to the go.mod file with //indirect
    as suffix. Do a go build. Now check the go.mod file. You will see below contents
    of the file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: All other dependencies are suffixed by **//indirect**. Also check that all direct
    and indirect dependencies will be recorded in the go.sum file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is all about packages and modules in golang. Hope you have liked this article.
    Please share feedback/mistakes/improvements in comments
  prefs: []
  type: TYPE_NORMAL
- en: '****Next Tutorial** – **[Variables](https://golangbyexample.com/variables-in-golang-complete-guide/)
    ****Previous Tutorial** –** [Packages and Modules – Part 1](https://golangbyexample.com/packages-modules-go-first)'
  prefs: []
  type: TYPE_NORMAL
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
