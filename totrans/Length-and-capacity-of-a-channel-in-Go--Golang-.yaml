- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:24:37'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Length and capacity of a channel in Go (Golang)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/length-and-capacity-channel-golang/](https://golangbyexample.com/length-and-capacity-channel-golang/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Length and capacity of a buffered channel](#Length_and_capacity_of_a_buffered_channel
    "Length and capacity of a buffered channel")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Length and capacity of a unbuffered channel](#Length_and_capacity_of_a_unbuffered_channel
    "Length and capacity of a unbuffered channel")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Length and capacity of nil channel](#Length_and_capacity_of_nil_channel "Length
    and capacity of nil channel")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length, as well as capacity only, applies to the buffered channel.  The length
    of a channel is the number of elements that are already there in the channel whereas
    the capacity of a buffered channel is the number of elements which that channel
    can hold.  So length actually represents the number of elements queued in the
    buffer of the channel while capacity refers to the size of the buffer of the channel.
    Hence the length of a channel is always less than or equal to the capacity of
    the channel.
  prefs: []
  type: TYPE_NORMAL
- en: len() function can be used to get the length of the channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cap() function can be used to get the capacity of the channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length and capacity of unbuffered channel is always zero
  prefs: []
  type: TYPE_NORMAL
- en: '**Length and capacity of a buffered channel**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, the first created a channel of capacity 3.  After that, we
    keep sending some value to the channel. As you can notice from your output that
    after each send operation to the length of channel increases by one while capacity
    is always the same which is 3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Length and capacity of a unbuffered channel**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Length and capacity of unbuffered channel is always zero
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Length and capacity of nil channel**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Length and capacity of nil channel is always zero
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Below is the summary table of result of **len()** and **cap()** on different
    types of channel
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Unbuffered Channel****(Not Closed and not nil)** | **Buffered
    Channel****(Not Closed and not nil)** | **Closed Channel** | **Nil Channel** |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 0 | Number of elements queued in the buffer of the channel | -0
    if unbuffered channel-Number of elements queued in the buffer if buffered channel
    | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Capacity | 0 | Size of the buffer of the channel | -0 if unbuffered channel-Size
    of the buffer if buffered channel | 0 |'
  prefs: []
  type: TYPE_TB
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
