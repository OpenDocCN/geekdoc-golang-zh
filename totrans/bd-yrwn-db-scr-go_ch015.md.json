["```go\n[](#cb1-1)type QLEvalContex struct {\n[](#cb1-2)    env Record // input row values\n[](#cb1-3)    out Value  // output\n[](#cb1-4)    err error\n[](#cb1-5)}\n```", "```go\n[](#cb2-1)func qlEval(ctx *QLEvalContex, node QLNode) {\n[](#cb2-2)    switch node.Type {\n[](#cb2-3)    // refer to a column\n[](#cb2-4)    case QL_SYM:\n[](#cb2-5)        if v := ctx.env.Get(string(node.Str)); v != nil {\n[](#cb2-6)            ctx.out = *v\n[](#cb2-7)        } else {\n[](#cb2-8)            qlErr(ctx, \"unknown column: %s\", node.Str)\n[](#cb2-9)        }\n[](#cb2-10)    // a literal value\n[](#cb2-11)    case QL_I64, QL_STR:\n[](#cb2-12)        ctx.out = node.Value\n[](#cb2-13)    // operators\n[](#cb2-14)    case QL_NEG:\n[](#cb2-15)        qlEval(ctx, node.Kids[0])\n[](#cb2-16)        if ctx.out.Type == TYPE_INT64 {\n[](#cb2-17)            ctx.out.I64 = -ctx.out.I64\n[](#cb2-18)        } else {\n[](#cb2-19)            qlErr(ctx, \"QL_NEG type error\")\n[](#cb2-20)        }\n[](#cb2-21)    // ...\n[](#cb2-22)    }\n[](#cb2-23)}\n```", "```go\n[](#cb3-1)type QLScan struct {\n[](#cb3-2)    Table  string // table name\n[](#cb3-3)    Key1   QLNode // index by\n[](#cb3-4)    Key2   QLNode\n[](#cb3-5)    Filter QLNode // filter\n[](#cb3-6)    Offset int64  // limit\n[](#cb3-7)    Limit  int64\n[](#cb3-8)}\n```", "```go\n[](#cb4-1)func qlScanInit(req *QLScan, sc *Scanner) (err error) {\n[](#cb4-2)    // convert `QLNode` to `Record` and `CMP_??`\n[](#cb4-3)    if sc.Key1, sc.Cmp1, err = qlEvalScanKey(req.Key1); err != nil {\n[](#cb4-4)        return err\n[](#cb4-5)    }\n[](#cb4-6)    if sc.Key2, sc.Cmp2, err = qlEvalScanKey(req.Key2); err != nil {\n[](#cb4-7)        return err\n[](#cb4-8)    }\n[](#cb4-9)    switch { // special handling when `Key1` and `Key2` are not both present\n[](#cb4-10)    case req.Key1.Type == 0 && req.Key2.Type == 0: // no `INDEX BY`\n[](#cb4-11)        sc.Cmp1, sc.Cmp2 = CMP_GE, CMP_LE // full table scan\n[](#cb4-12)    case req.Key1.Type == QL_CMP_EQ && req.Key2.Type == 0:\n[](#cb4-13)        // equal by a prefix: INDEX BY key = val\n[](#cb4-14)        sc.Key2 = sc.Key1\n[](#cb4-15)        sc.Cmp1, sc.Cmp2 = CMP_GE, CMP_LE\n[](#cb4-16)    case req.Key1.Type != 0 && req.Key2.Type == 0:\n[](#cb4-17)        // open-ended range: INDEX BY key > val\n[](#cb4-18)        if sc.Cmp1 > 0 {\n[](#cb4-19)            sc.Cmp2 = CMP_LE // compare with a zero-length tuple\n[](#cb4-20)        } else {\n[](#cb4-21)            sc.Cmp2 = CMP_GE\n[](#cb4-22)        }\n[](#cb4-23)    }\n[](#cb4-24)    return nil\n[](#cb4-25)}\n```", "```go\n[](#cb5-1)func dbScan(tx *DBTX, tdef *TableDef, req *Scanner) error {\n[](#cb5-2)    // ...\n[](#cb5-3)    covered := func(key []string, index []string) bool {\n[](#cb5-4)        return len(index) >= len(key) && slices.Equal(index[:len(key)], key)\n[](#cb5-5)    }\n[](#cb5-6)    req.index = slices.IndexFunc(tdef.Indexes, func(index []string) bool {\n[](#cb5-7)        return covered(req.Key1.Cols, index) && covered(req.Key2.Cols, index)\n[](#cb5-8)    })\n[](#cb5-9)    // ...\n[](#cb5-10)}\n```", "```go\n[](#cb6-1)type RecordIter interface {\n[](#cb6-2)    Valid() bool\n[](#cb6-3)    Next()\n[](#cb6-4)    Deref(*Record) error\n[](#cb6-5)}\n```", "```go\n[](#cb7-1)type qlSelectIter struct {\n[](#cb7-2)    iter  RecordIter    // input\n[](#cb7-3)    names []string\n[](#cb7-4)    exprs []QLNode\n[](#cb7-5)}\n[](#cb7-6)\n[](#cb7-7)func (iter *qlSelectIter) Valid() bool {\n[](#cb7-8)    return iter.iter.Valid()\n[](#cb7-9)}\n[](#cb7-10)func (iter *qlSelectIter) Next() {\n[](#cb7-11)    iter.iter.Next()\n[](#cb7-12)}\n[](#cb7-13)func (iter *qlSelectIter) Deref(rec *Record) error {\n[](#cb7-14)    if err := iter.iter.Deref(rec); err != nil {\n[](#cb7-15)        return err\n[](#cb7-16)    }\n[](#cb7-17)    vals, err := qlEvelMulti(*rec, iter.exprs)\n[](#cb7-18)    if err != nil {\n[](#cb7-19)        return err\n[](#cb7-20)    }\n[](#cb7-21)    *rec = Record{iter.names, vals}\n[](#cb7-22)    return nil\n[](#cb7-23)}\n```", "```go\n[](#cb8-1)type qlScanIter struct {\n[](#cb8-2)    // input\n[](#cb8-3)    req *QLScan\n[](#cb8-4)    sc  Scanner\n[](#cb8-5)    // state\n[](#cb8-6)    idx int64\n[](#cb8-7)    end bool\n[](#cb8-8)    // cached output item\n[](#cb8-9)    rec Record\n[](#cb8-10)    err error\n[](#cb8-11)}\n```"]