["```go\npackage main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    // Show current value\n    fmt.Printf(\"GOMAXPROCS = %d\\n\", runtime.GOMAXPROCS(0))\n\n    // Set to 4 and confirm\n    prev := runtime.GOMAXPROCS(4)\n    fmt.Printf(\"Changed from %d to %d\\n\", prev, runtime.GOMAXPROCS(0))\n} \n```", "```go\nGODEBUG=schedtrace=1000,scheddetail=1 go run main.go \n```", "```go\nSCHED 3024ms: gomaxprocs=14 idleprocs=14 threads=26 spinningthreads=0 needspinning=0 idlethreads=20 runqueue=0 gcwaiting=false nmidlelocked=1 stopwait=0 sysmonwait=false\n  P0: status=0 schedtick=173 syscalltick=3411 m=nil runqsize=0 gfreecnt=6 timerslen=0\n  ...\n  P13: status=0 schedtick=96 syscalltick=310 m=nil runqsize=0 gfreecnt=2 timerslen=0\n  M25: p=nil curg=nil mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=nil\n  ... \n```", "```go\nfunc pollAndRead(conn net.Conn) ([]byte, error) {\n    buf := make([]byte, 4096)\n    for {\n        n, err := conn.Read(buf)\n        if n > 0 {\n            return buf[:n], nil\n        }\n        if err != nil && !isTemporary(err) {\n            return nil, err\n        }\n        // Data not ready yet â€” goroutine will be parked until poller wakes it\n    }\n} \n```", "```go\nGODEBUG=netpoll=1 go run main.go \n```", "```go\nruntime: netpoll: poll returned n=3\nruntime: netpoll: waking g=102 for fd=5 \n```", "```go\nruntime.LockOSThread()\ndefer runtime.UnlockOSThread()\n\n// perform critical latency-sensitive work here \n```", "```go\nfunc setAffinity(cpuList []int) error {\n    pid := os.Getpid()\n    var mask unix.CPUSet\n    for _, cpu := range cpuList {\n        mask.Set(cpu)\n    }\n    return unix.SchedSetaffinity(pid, &mask)\n}\n\nfunc main() {\n    runtime.LockOSThread()\n    defer runtime.UnlockOSThread()\n\n    if err := setAffinity([]int{2, 3}); err != nil {\n        log.Fatalf(\"CPU affinity failed: %v\", err)\n    }\n\n    // perform critical work with confirmed benefit\n} \n```"]