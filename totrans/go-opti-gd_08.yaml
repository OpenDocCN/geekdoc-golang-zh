- en: 'Memory Efficiency: Mastering Go’s Garbage Collector'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存效率：掌握Go的垃圾回收器
- en: 原文：[https://goperf.dev/01-common-patterns/gc/](https://goperf.dev/01-common-patterns/gc/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/gc/](https://goperf.dev/01-common-patterns/gc/)
- en: Memory management in Go is automated—but it’s not invisible. Every allocation
    you make contributes to GC workload. The more frequently objects are created and
    discarded, the more work the runtime has to do reclaiming memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的内存管理是自动化的——但它并非不可见。你进行的每一次分配都会对GC的工作负载做出贡献。对象创建和丢弃的频率越高，运行时在回收内存方面需要做的工作就越多。
- en: This becomes especially relevant in systems prioritizing low latency, predictable
    resource usage, or high throughput. Tuning your allocation patterns and leveraging
    newer features like weak references can help reduce pressure on the GC without
    adding complexity to your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这在优先考虑低延迟、可预测的资源使用或高吞吐量的系统中尤为重要。调整你的分配模式并利用像弱引用这样的新功能可以帮助减轻GC的压力，而不会增加你代码的复杂性。
- en: How Go's Garbage Collector Works
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go的垃圾回收器是如何工作的
- en: Info
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Highly encourage you to read the official [A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)!
    The document provides a detailed description of multiple Go's GC internals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你阅读官方的[A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)！该文档提供了对多个Go的GC内部结构的详细描述。
- en: Go uses a **non-generational, concurrent, tri-color mark-and-sweep** garbage
    collector. Here's what that means in practice and how it's implemented.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用一个**非代、并发、三色标记-清除**垃圾收集器。以下是它在实际中的含义以及它的实现方式。
- en: Non-generational
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非代
- en: Many modern GCs, like those in the JVM or .NET CLR, divide memory into *generations*
    (young and old) under the assumption that most objects die young. These collectors
    focus on the young generation, which leads to shorter collection cycles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代GC，如JVM或.NET CLR中的GC，基于大多数对象年轻时就死亡这一假设，将内存划分为*代*（年轻和年老）。这些收集器专注于年轻代，这导致了更短的收集周期。
- en: Go’s GC takes a different approach. It treats all objects equally—no generational
    segmentation—not because generational GC conflicts with short pause times or concurrent
    scanning, but because it hasn’t shown clear, consistent benefits in real-world
    Go programs with the designs tried so far. This choice avoids the complexity of
    promotion logic and specialized memory regions. While it can mean scanning more
    objects overall, this cost is mitigated by concurrent execution and efficient
    write barriers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go的GC采取了一种不同的方法。它平等地对待所有对象——没有代分割——不是因为代GC与短暂的暂停时间或并发扫描冲突，而是因为到目前为止的设计在现实世界的Go程序中并没有显示出明确、一致的好处。这种选择避免了提升逻辑和专用内存区域的复杂性。虽然这可能意味着总体上需要扫描更多的对象，但这种成本通过并发执行和高效的写屏障得到了缓解。
- en: Concurrent
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发
- en: 'Go’s GC runs concurrently with your application, which means it does most of
    its work without stopping the world. Concurrency is implemented using multiple
    phases that interleave with normal program execution:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go的GC与你的应用程序并发运行，这意味着它的大部分工作都不需要停止世界。并发是通过多个阶段实现的，这些阶段与正常程序执行交织在一起：
- en: Even though Go’s garbage collector is mostly concurrent, it still requires brief
    Stop-The-World (STW) pauses at several points to maintain correctness. These pauses
    are kept extremely short—typically under 100 microseconds—even with large heaps
    and hundreds of goroutines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go的垃圾收集器主要是并发的，但它仍然需要在几个点上进行短暂的停止世界（STW）暂停，以保持正确性。这些暂停被保持得非常短——通常在100微秒以下——即使是在大型堆和数百个goroutine的情况下。
- en: STW is essential for ensuring that memory structures are not mutated while the
    GC analyzes them. In most applications, these pauses are imperceptible. However,
    even sub-millisecond pauses in latency-sensitive systems can be significant—so
    understanding and monitoring STW behavior becomes important when optimizing for
    tail latencies or jitter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: STW对于确保在GC分析内存结构时内存结构不被修改是必不可少的。在大多数应用程序中，这些暂停是感觉不到的。然而，在延迟敏感系统中，即使是亚毫秒的暂停也可能很重要——因此，当优化尾部延迟或抖动时，理解和监控STW行为变得很重要。
- en: '**STW Start Phase:** The application is briefly paused to initiate GC. The
    runtime scans stacks, globals, and root objects.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STW开始阶段**：应用程序会短暂暂停以启动GC。运行时会扫描栈、全局变量和根对象。'
- en: '**Concurrent Mark Phase:** The garbage collector traverses the heap, marking
    all reachable objects while the program continues running. This is the heaviest
    phase in terms of work but runs concurrently to avoid long stop-the-world pauses.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发标记阶段**：垃圾收集器遍历堆，在程序继续运行的同时标记所有可达对象。这是工作量最大的阶段，但它是并发运行的，以避免长时间的停止世界暂停。'
- en: '**STW Mark Termination:** Once marking is mostly complete, the GC briefly pauses
    the program to finish any remaining work and ensure the heap is in a consistent
    state before sweeping begins. This pause is typically very short—measured in microseconds.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STW 标记终止**：一旦标记基本完成，GC 会短暂暂停程序以完成任何剩余的工作，并在开始清除之前确保堆处于一致状态。这种暂停通常非常短——以微秒计。'
- en: '**Concurrent Sweep Phase:** The GC reclaims memory from unreachable (white)
    objects and returns it to the heap for reuse, all while your program continues
    running.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发清除阶段**：GC 从不可达（白色）对象中回收内存，并将其返回到堆中以供重用，同时你的程序继续运行。'
- en: Write barriers ensure correctness while the application mutates objects during
    concurrent marking. These barriers help track references created or modified mid-scan
    so the GC doesn’t miss them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 写屏障确保在应用程序并发标记期间对象突变时的正确性。这些屏障有助于跟踪扫描过程中创建或修改的引用，以便垃圾回收器不会错过它们。
- en: Tri-color Mark and Sweep
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三色标记和清除
- en: 'The tri-color algorithm breaks the heap into three working sets during garbage
    collection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 三色算法在垃圾回收期间将堆拆分为三个工作集：
- en: '**White:** Objects that haven’t been reached—if they stay white, they’ll be
    collected.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白色**：尚未到达的对象——如果它们保持白色，它们将被收集。'
- en: '**Grey:** Objects that have been discovered (i.e., marked as reachable) but
    haven’t had their references scanned yet.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灰色**：已发现的对象（即，标记为可达）但尚未扫描其引用。'
- en: '**Black:** Objects that are both reachable and fully scanned—they’re retained
    and don’t need further processing.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑色**：既可达又完全扫描的对象——它们被保留，不需要进一步处理。'
- en: 'Garbage collection starts by marking all root objects (stack, globals, etc.)
    grey. It then walks the grey set: for each object, it scans its fields. Any referenced
    objects that are still white are added to the grey set. Once an object’s references
    are fully processed, it’s marked black.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收首先将所有根对象（栈、全局变量等）标记为灰色。然后遍历灰色集：对于每个对象，它扫描其字段。任何仍为白色的引用对象都将添加到灰色集中。一旦一个对象的引用被完全处理，它就被标记为黑色。
- en: When no grey objects remain, anything still white is unreachable and gets cleaned
    up during the sweep phase. This model ensures that no live object is accidentally
    collected—even if references change mid-scan—thanks to Go’s write barriers that
    maintain the algorithm’s core invariants.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有灰色对象剩余时，任何仍为白色的对象都是不可达的，并在清除阶段被清理。这种模型确保没有活动对象被意外收集——即使引用在扫描过程中发生变化——这得益于
    Go 的写屏障，它维护算法的核心不变性。
- en: 'A key optimization is **incremental marking**: Go spreads out GC work to avoid
    long pauses, supported by precise stack scanning and conservative write barriers.
    The use of concurrent sweeping further reduces latency, allowing memory to be
    reclaimed without halting execution.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的优化是**增量标记**：Go 将 GC 工作分散以避免长时间暂停，这得益于精确的栈扫描和保守的写屏障。并发清除的使用进一步减少了延迟，允许在不停机的情况下回收内存。
- en: This design gives Go a GC that’s safe, fast, and friendly to server workloads
    with large heaps and many cores.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使 Go 的 GC 变得安全、快速，并且对具有大堆和多个核心的服务器工作负载友好。
- en: 'GC Tuning: GOGC'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC 调优：GOGC
- en: Go’s garbage collector is tuned to deliver good performance without manual configuration.
    The default `GOGC` setting typically strikes the right balance between memory
    consumption and CPU effort, adapting well across a wide range of workloads. In
    most cases, manually tweaking it offers little benefit—and in many, it actually
    makes things worse by increasing either pause times or memory pressure. Unless
    you’ve profiled a specific bottleneck and understand the trade-offs, it’s usually
    best to leave `GOGC` alone.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的垃圾回收器经过调整，在不进行手动配置的情况下提供良好的性能。默认的 `GOGC` 设置通常在内存消耗和 CPU 努力之间取得平衡，适应广泛的负载。在大多数情况下，手动调整它几乎没有好处——在许多情况下，它实际上会使事情变得更糟，通过增加暂停时间或内存压力。除非你已经分析了特定的瓶颈并理解了权衡，否则通常最好让
    `GOGC` 保持原样。
- en: That said, there are specific cases where tuning `GOGC` can yield significant
    gains. For example, [Uber implemented dynamic GC tuning](https://www.uber.com/en-GB/blog/how-we-saved-70k-cores-across-30-mission-critical-services/)
    across their Go services to reduce CPU usage and saved tens of thousands of cores
    in the process. Their approach relied on profiling, metric collection, and automation
    to safely adjust GC behavior based on actual memory pressure and workload characteristics.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在某些特定情况下调整 `GOGC` 可以带来显著的收益。例如，[Uber 在其 Go 服务中实施了动态 GC 调整](https://www.uber.com/en-GB/blog/how-we-saved-70k-cores-across-30-mission-critical-services/)
    以减少 CPU 使用，并在过程中节省了数万个核心。他们的方法依赖于分析、指标收集和自动化，以根据实际的内存压力和工作负载特征安全地调整 GC 行为。
- en: Another unusual case is from Cloudflare. They [profiled a high-concurrency cryptographic
    workload](https://blog.cloudflare.com/go-dont-collect-my-garbage/) and found that
    Go’s GC became a bottleneck as goroutines increased. Their application produced
    minimal garbage, yet GC overhead grew with concurrency. By tuning GOGC to a much
    higher value—specifically 11300—they significantly reduced GC frequency and improved
    throughput, achieving over 22× performance gains compared to the single-core baseline.
    This case highlights how allowing more heap growth in CPU-bound and low-allocation
    scenarios can yield major improvements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不寻常的案例来自 Cloudflare。他们 [分析了高并发加密工作负载](https://blog.cloudflare.com/go-dont-collect-my-garbage/)
    并发现，随着 goroutine 的增加，Go 的 GC 变成了瓶颈。他们的应用程序产生的垃圾最少，但 GC 开销随着并发性增长。通过将 GOGC 调整到一个更高的值——具体为
    11300——他们显著减少了 GC 频率并提高了吞吐量，与单核基线相比实现了超过 22 倍的性能提升。这个案例突出了在 CPU 密集型和低分配场景中允许更多堆增长如何带来重大改进。
- en: 'So, if you decide to tune the garbage collector, be methodical:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你决定调整垃圾收集器，请有计划地进行：
- en: Always profile first. Use tools like `pprof` to confirm that GC activity is
    a bottleneck.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是先进行性能分析。使用 `pprof` 等工具确认 GC 活动是瓶颈。
- en: Change settings incrementally. For example, increasing `GOGC` from 100 to 150
    means the GC will run less frequently, using less CPU but more memory.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步更改设置。例如，将 `GOGC` 从 100 增加到 150 意味着 GC 将运行得更少，使用更少的 CPU 但更多的内存。
- en: Verify impact. After tuning, validate with profiling data that the change had
    a positive effect. Without that confirmation, it's easy to make things worse.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证影响。调整后，使用分析数据验证更改是否产生了积极效果。没有这种确认，很容易使事情变得更糟。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Memory Limiting with `GOMEMLIMIT`
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `GOMEMLIMIT` 进行内存限制
- en: In addition to `GOGC`, Go provides `GOMEMLIMIT`—a soft memory limit that caps
    the total heap size the runtime will try to stay under. This allows you to explicitly
    control memory growth, especially useful in environments like containers or systems
    with strict memory budgets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `GOGC` 之外，Go 还提供了 `GOMEMLIMIT`——这是一个软内存限制，它限制了运行时尝试保持在下的总堆大小。这允许你显式地控制内存增长，这在容器或具有严格内存预算的系统等环境中特别有用。
- en: Why is this helpful? In containerized environments (like Kubernetes), memory
    limits are typically enforced at the OS or orchestrator level. If your application
    exceeds its memory quota, the OOM killer may abruptly terminate the container.
    Go's GC isn't aware of those limits by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处？在容器化环境中（如 Kubernetes），内存限制通常在操作系统或编排器级别强制执行。如果你的应用程序超过了其内存配额，OOM 杀手可能会突然终止容器。Go
    的 GC 默认情况下并不了解这些限制。
- en: 'Setting a `GOMEMLIMIT` helps prevent this. For example, if your container has
    a 512MiB memory limit, you might set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `GOMEMLIMIT` 有助于防止这种情况。例如，如果你的容器有 512MiB 的内存限制，你可能设置如下：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This buffer gives the Go runtime room to act before reaching the hard system-imposed
    memory cap. It allows the garbage collector to become more aggressive as total
    memory usage grows, reducing the chances of the process being killed due to an
    out-of-memory condition. It also leaves space for non-heap allocations—like goroutine
    stacks, OS threads, and other internal runtime structures—which don’t count toward
    heap size but still consume real memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓冲区为 Go 运行时提供了在达到系统强加的内存上限之前进行操作的空间。它允许垃圾收集器在总内存使用量增长时变得更加激进，从而降低因内存不足而终止进程的可能性。它还留出了空间用于非堆分配——例如
    goroutine 栈、OS 线程和其他内部运行时结构，这些结构不计入堆大小，但仍然消耗实际内存。
- en: 'You can also set the limit programmatically:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过编程方式设置限制：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The GC will become more aggressive as heap usage nears the limit, which can
    increase CPU load. Be careful not to set the limit too low—especially if your
    application maintains a large live set of objects—or you may trigger excessive
    GC cycles.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当堆使用接近限制时，GC 将变得更加激进，这可能会增加 CPU 负载。请小心不要将限制设置得太低——特别是如果您的应用程序维护一个大型活动对象集——否则可能会触发过多的
    GC 循环。
- en: 'While `GOGC` controls how frequently the GC runs based on heap growth, `GOMEMLIMIT`
    constrains the heap size itself. The two can be combined for more precise control:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `GOGC` 根据堆增长频率控制 GC 的运行，但 `GOMEMLIMIT` 限制了堆的大小。这两个变量可以结合使用以实现更精确的控制：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells the GC to operate with the default growth ratio and to start collecting
    sooner if heap usage nears 4 GiB.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 GC 以默认的增长比率运行，并在堆使用接近 4 GiB 时开始收集。
- en: GOMEMLIMIT=X and GOGC=off configuration
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GOMEMLIMIT=X 和 GOGC=off 配置
- en: 'In scenarios where memory availability is fixed and predictable—such as within
    containers or VMs, you can use these two variables together:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存可用性固定且可预测的场景中——例如在容器或虚拟机中，你可以同时使用这两个变量：
- en: '`GOMEMLIMIT=X` tells the runtime to aim for a specific memory ceiling. For
    example, `GOMEMLIMIT=2GiB` will trigger garbage collection when total memory usage
    nears 2 GiB.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOMEMLIMIT=X` 告诉运行时达到特定的内存上限。例如，`GOMEMLIMIT=2GiB` 将在总内存使用量接近 2 GiB 时触发垃圾回收。'
- en: '`GOGC=off` disables the default GC pacing algorithm, so garbage collection
    only runs when the memory limit is hit.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOGC=off` 禁用了默认的 GC 调度算法，因此垃圾回收仅在达到内存限制时运行。'
- en: This configuration maximizes memory usage efficiency and avoids the overhead
    of frequent GC cycles. It's especially effective in high-throughput or latency-sensitive
    systems where predictable memory usage matters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置最大化内存使用效率，并避免了频繁 GC 循环的开销。它特别适用于高吞吐量或对延迟敏感的系统，在这些系统中，可预测的内存使用很重要。
- en: '**Example:**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this setup, memory usage grows freely until the 2 GiB threshold is reached.
    At that point, Go performs a full garbage collection pass.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，内存使用量自由增长，直到达到 2 GiB 的阈值。在那个时刻，Go 执行完整的垃圾回收过程。
- en: Warning
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Always benchmark with your real workload. Disabling automatic GC can backfire
    if your application produces a lot of short-lived allocations.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是用您的实际工作负载进行基准测试。如果您的应用程序产生大量短生命周期的分配，禁用自动 GC 可能会适得其反。
- en: Monitor memory pressure and GC pause times using `runtime.ReadMemStats` or `pprof`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `runtime.ReadMemStats` 或 `pprof` 监控内存压力和 GC 暂停时间。
- en: This approach works best when your memory usage patterns are well understood
    and stable.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的内存使用模式被充分理解和稳定时，这种方法效果最佳。
- en: Practical Strategies for Reducing GC Pressure
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低 GC 压力的实用策略
- en: Prefer Stack Allocation
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先使用栈分配
- en: 'Go allocates variables on the stack whenever possible. Avoid escaping variables
    to the heap:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在可能的情况下始终在栈上分配变量。避免将变量逃逸到堆上：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use `go build -gcflags="-m"` to view escape analysis diagnostics. See [Stack
    Allocations and Escape Analysis](../stack-alloc/) for more details.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go build -gcflags="-m"` 查看逃逸分析诊断。有关更多详细信息，请参阅[栈分配和逃逸分析](../stack-alloc/)。
- en: Use sync.Pool for Short-Lived Objects
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于短生命周期对象的 sync.Pool
- en: '`sync.Pool` is ideal for temporary, reusable allocations that are expensive
    to GC.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Pool` 是用于临时、可重用且 GC 成本高昂的分配的理想选择。'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See [Object Pooling](../object-pooling/) for more details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅[对象池](../object-pooling/)。
- en: Batch Allocations
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量分配
- en: Group allocations into fewer objects to reduce GC pressure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存分配分组到更少的对象中，以降低 GC 压力。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See [Memory Preallocation](../mem-prealloc/) for more details.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅[内存预分配](../mem-prealloc/)。
- en: Weak References in Go
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的弱引用
- en: 'Go 1.24 added the `weak` package, providing a standardized way to create weak
    references—pointers that don’t keep their target objects alive. In garbage-collected
    systems like Go, strong references extend an object’s lifetime: as long as something
    points to it, it won’t be collected. That’s usually what you want, but in structures
    like caches, deduplication maps, or object graphs, this can lead to memory staying
    alive much longer than intended. Weak references solve that by allowing you to
    refer to an object without blocking the GC from reclaiming it when nothing else
    is using it.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.24 添加了 `weak` 包，提供了一种创建弱引用的标准方式——这些引用不会保持其目标对象存活。在像 Go 这样的垃圾回收系统中，强引用延长了对象的生命周期：只要有什么东西指向它，它就不会被回收。这通常是您想要的，但在像缓存、去重映射或对象图这样的结构中，这可能导致内存存活时间远超过预期。弱引用通过允许您在不阻止
    GC 在没有其他东西使用它时回收对象的情况下引用对象来解决此问题。
- en: 'A weak reference, by contrast, tells the garbage collector: “you can collect
    this object if nothing else is strongly referencing it.” This pattern is important
    for building memory-sensitive data structures that should not interfere with garbage
    collection.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，弱引用会告诉垃圾收集器：“如果没有任何其他强引用引用它，你可以收集这个对象。”这种模式对于构建不应干扰垃圾收集的内存敏感数据结构非常重要。
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, `wp` holds a weak reference to a `Data` object. After the strong
    reference (`data`) goes out of scope and the garbage collector runs, the `Data`
    may be collected—at which point `wp.Value()` will return nil. This pattern is
    especially useful in memory-sensitive contexts like caches or canonicalization
    maps, where you want to avoid artificially extending object lifetimes. Always
    check the result of `Value()` before using it, since the target may have been
    reclaimed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`wp` 持有一个对 `Data` 对象的弱引用。在强引用（`data`）超出作用域并且垃圾收集器运行后，`Data` 可能被收集——此时
    `wp.Value()` 将返回 nil。这种模式在内存敏感的上下文中特别有用，如缓存或规范映射，在这些上下文中，你希望避免人为地延长对象的生命周期。始终在使用之前检查
    `Value()` 的结果，因为目标可能已经被回收。
- en: Benchmarking Impact
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响
- en: It's tempting to rely on synthetic benchmarks to evaluate the performance of
    Go's garbage collector, but generic benchmarks rarely capture the nuances of real-world
    workloads. Memory behavior is highly dependent on allocation patterns, object
    lifetimes, concurrency, and how frequently short-lived versus long-lived data
    structures are used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于合成基准来评估 Go 的垃圾收集器性能很诱人，但通用的基准很少能捕捉到真实工作负载的细微差别。内存行为高度依赖于分配模式、对象生命周期、并发性以及短生命周期与长生命周期数据结构的使用频率。
- en: For example, the impact of GC in a CPU-bound microservice that maintains large
    in-memory indexes will differ dramatically from an I/O-heavy API server with minimal
    heap usage. As such, tuning decisions should always be informed by your application's
    profiling data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在维护大型内存索引的 CPU 密集型微服务中，GC 的影响与堆使用量极小的 I/O 重的 API 服务器相比将截然不同。因此，调优决策应始终基于你的应用程序的配置文件数据。
- en: 'We cover targeted use cases and their GC performance trade-offs in more focused
    articles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更专注的文章中涵盖了目标用例及其 GC 性能权衡：
- en: '[Object Pooling](../object-pooling/): Reducing allocation churn using `sync.Pool`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[对象池](../object-pooling/)：使用 `sync.Pool` 减少分配波动'
- en: '[Stack Allocations and Escape Analysis](../stack-alloc/): Minimizing heap usage
    by keeping values on the stack'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[栈分配和逃逸分析](../stack-alloc/)：通过在栈上保持值来最小化堆使用'
- en: '[Memory Preallocation](../mem-prealloc/): Avoiding unnecessary growth of slices
    and maps'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存预分配](../mem-prealloc/)：避免切片和映射不必要的增长'
- en: When applied to the right context, these techniques can make a measurable difference,
    but they don’t lend themselves to one-size-fits-all benchmarks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于正确的上下文时，这些技术可以产生可测量的差异，但它们不适合所有基准测试。
