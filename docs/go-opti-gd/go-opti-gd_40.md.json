["```go\nsequenceDiagram\n    participant App as Application\n    participant TCP as TCP Stack\n    participant Net as Network\n\n    App->>TCP: Send 1 byte\n    note right of TCP: Buffering (no ACK received)\n    App->>TCP: Send 1 byte\n    note right of TCP: Still buffering...\n\n    TCP-->>Net: Send 2 bytes (batched)\n    Net-->>TCP: ACK received\n\n    App->>TCP: Send 1 byte\n    TCP-->>Net: Immediately send (ACK received, buffer clear)\n```", "```go\nfunc SetTCPNoDelay(conn *net.TCPConn) error {\n    return conn.SetNoDelay(true)\n} \n```", "```go\nlistenerConfig := &net.ListenConfig{\n    Control: func(network, address string, c syscall.RawConn) error {\n        return c.Control(func(fd uintptr) {\n            syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n        })\n    },\n}\nlistener, err := listenerConfig.Listen(context.Background(), \"tcp\", \":8080\") \n```", "```go\nfunc SetSocketBuffers(conn *net.TCPConn, recvBuf, sendBuf int) error {\n    if err := conn.SetReadBuffer(recvBuf); err != nil {\n        return err\n    }\n    return conn.SetWriteBuffer(sendBuf)\n} \n```", "```go\nfunc SetKeepAlive(conn *net.TCPConn, idleTime time.Duration) error {\n    if err := conn.SetKeepAlive(true); err != nil {\n        return err\n    }\n    return conn.SetKeepAlivePeriod(idleTime)\n} \n```", "```go\n# System-level setting\nsysctl -w net.core.somaxconn=4096 \n```", "```go\nlistenerConfig := net.ListenConfig{\n    Control: func(network, address string, c syscall.RawConn) error {\n        return c.Control(func(fd uintptr) {\n            // Custom syscall here; safely handled means it executes within the correct context,\n            // before the socket is handed over to the Go runtime, with proper error checking and synchronization\n        })\n    },\n} \n```"]