["```\ne := fmt.Errorf(\"... %w ...\", ..., err, ...)\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype errorOne struct{}\n\nfunc (e errorOne) Error() string {\n\treturn \"Error One happended\"\n}\n\nfunc main() {\n\n\te1 := errorOne{}\n\n\te2 := fmt.Errorf(\"E2: %w\", e1)\n\n\te3 := fmt.Errorf(\"E3: %w\", e2)\n\n\tfmt.Println(e2)\n\n\tfmt.Println(e3)\n\n}\n```", "```\nE2: Error One happended\nE3: E2: Error One happended\n```", "```\ne2 := fmt.Errorf(\"E2: %w\", e1)\n```", "```\ne3 := fmt.Errorf(\"E3: %w\", e2)\n```", "```\nE2: Error One happended\n```", "```\nE3: E2: Error One happended\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype notPositive struct {\n\tnum int\n}\n\nfunc (e notPositive) Error() string {\n\treturn fmt.Sprintf(\"checkPositive: Given number %d is not a positive number\", e.num)\n}\n\ntype notEven struct {\n\tnum int\n}\n\nfunc (e notEven) Error() string {\n\treturn fmt.Sprintf(\"checkEven: Given number %d is not an even number\", e.num)\n}\n\nfunc checkPositive(num int) error {\n\tif num < 0 {\n\t\treturn notPositive{num: num}\n\t}\n\treturn nil\n}\n\nfunc checkEven(num int) error {\n\tif num%2 == 1 {\n\t\treturn notEven{num: num}\n\t}\n\treturn nil\n}\n\nfunc checkPostiveAndEven(num int) error {\n\tif num > 100 {\n\t\treturn fmt.Errorf(\"checkPostiveAndEven: Number %d is greater than 100\", num)\n\t}\n\n\terr := checkPositive(num)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = checkEven(num)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tnum := 3\n\terr := checkPostiveAndEven(num)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Givennnumber is positive and even\")\n\t}\n\n}\n```", "```\ncheckEven: Given number 3 is not an even number\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype notPositive struct {\n\tnum int\n}\n\nfunc (e notPositive) Error() string {\n\treturn fmt.Sprintf(\"checkPositive: Given number %d is not a positive number\", e.num)\n}\n\ntype notEven struct {\n\tnum int\n}\n\nfunc (e notEven) Error() string {\n\treturn fmt.Sprintf(\"checkEven: Given number %d is not an even number\", e.num)\n}\n\nfunc checkPositive(num int) error {\n\tif num < 0 {\n\t\treturn notPositive{num: num}\n\t}\n\treturn nil\n}\n\nfunc checkEven(num int) error {\n\tif num%2 == 1 {\n\t\treturn notEven{num: num}\n\t}\n\treturn nil\n}\n\nfunc checkPostiveAndEven(num int) error {\n\tif num > 100 {\n\t\treturn fmt.Errorf(\"checkPostiveAndEven: Number %d is greater than 100\", num)\n\t}\n\n\terr := checkPositive(num)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"checkPostiveAndEven: %w\", err)\n\t}\n\n\terr = checkEven(num)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"checkPostiveAndEven: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tnum := 3\n\terr := checkPostiveAndEven(num)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Given number is positive and even\")\n\t}\n\n}\n```", "```\ncheckPostiveAndEven: checkEven: Given number 3 is not an even number\n```", "```\nfmt.Errorf(\"checkPostiveAndEven: %w\", err)\n```", "```\ncheckPostiveAndEven: checkEven: Given number 3 is not an even number\n```", "```\nfunc Unwrap(err error) error\n```", "```\nimport (\n    \"errors\"\n    \"fmt\"\n)\ntype errorOne struct{}\nfunc (e errorOne) Error() string {\n    return \"Error One happened\"\n}\nfunc main() {\n    e1 := errorOne{}\n    e2 := fmt.Errorf(\"E2: %w\", e1)\n    e3 := fmt.Errorf(\"E3: %w\", e2)\n    fmt.Println(errors.Unwrap(e3))\n    fmt.Println(errors.Unwrap(e2))\n    fmt.Println(errors.Unwrap(e1))\n}\n```", "```\nE2: Error One happended\nError One happended \n```", "```\ne2 := fmt.Errorf(\"E2: %w\", e1)\n```", "```\ne3 := fmt.Errorf(\"E3: %w\", e2)\n```", "```\nfmt.Println(errors.Unwrap(e3))\n```", "```\nE2: Error One happened\n```", "```\nfmt.Println(errors.Unwrap(e1))\n```", "```\n{nil}\n```", "```\nfunc Is(err, target error) bool\n```", "```\npackage main\nimport (\n    \"errors\"\n    \"fmt\"\n)\ntype errorOne struct{}\nfunc (e errorOne) Error() string {\n    return \"Error One happended\"\n}\nfunc main() {\n    var err1 errorOne\n    err2 := do()\n    if err1 == err2 {\n        fmt.Println(\"Equality Operator: Both errors are equal\")\n    }\n    if errors.Is(err1, err2) {\n        fmt.Println(\"Is function: Both errors are equal\")\n    }\n}\nfunc do() error {\n    return errorOne{}\n}\n```", "```\nEquality Operator: Both errors are equal\nIs function: Both errors are equal\n```", "```\nerr1 == err2\n```", "```\nerrors.Is(err1, err2)\n```", "```\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype errorOne struct{}\n\nfunc (e errorOne) Error() string {\n\treturn \"Error One happended\"\n}\n\nfunc main() {\n\terr1 := errorOne{}\n\n\terr2 := do()\n\n\tif err1 == err2 {\n\t\tfmt.Println(\"Equality Operator: Both errors are equal\")\n\t} else {\n\t\tfmt.Println(\"Equality Operator: Both errors are not equal\")\n\t}\n\n\tif errors.Is(err2, err1) {\n\t\tfmt.Println(\"Is function: Both errors are equal\")\n\t}\n}\n\nfunc do() error {\n\treturn fmt.Errorf(\"E2: %w\", errorOne{})\n}\n```", "```\nEquality Operator: Both errors are not equal\nIs function: Both errors are equal\n```", "```\nreturn fmt.Errorf(\"E2: %w\", errorOne{})\n```", "```\nEquality Operator: Both errors are not equal\n```", "```\nIs function: Both errors are equal\n```", "```\nerr := err.({type})\n```", "```\nerr, ok := err.({type})\n```", "```\nfunc As(err error, target interface{}) bool\n```", "```\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\n\terr := openFile(\"non-existing.txt\")\n\n\tif e, ok := err.(*os.PathError); ok {\n\t\tfmt.Printf(\"Using Assert: Error e is of type path error. Path: %v\\n\", e.Path)\n\t} else {\n\t\tfmt.Println(\"Using Assert: Error not of type path error\")\n\t}\n\n\tvar pathError *os.PathError\n\tif errors.As(err, &pathError) {\n\t\tfmt.Printf(\"Using As function: Error e is of type path error. Path: %v\\n\", pathError.Path)\n\t}\n}\n\nfunc openFile(fileName string) error {\n\t_, err := os.Open(\"non-existing.txt\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n```", "```\nUsing Assert: Error e is of type path error. Path: non-existing.txt\nUsing As function: Error e is of type path error. Path: non-existing.txt\n```", "```\ne,ok := err.(*os.PathError); ok\n```", "```\nerrors.As(err, &pathError)\n```", "```\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar pathError *os.PathError\n\terr := openFile(\"non-existing.txt\")\n\n\tif e, ok := err.(*os.PathError); ok {\n\t\tfmt.Printf(\"Using Assert: Error e is of type path error. Error: %v\\n\", e)\n\t} else {\n\t\tfmt.Println(\"Using Assert: Error not of type path error\")\n\t}\n\n\tif errors.As(err, &pathError) {\n\t\tfmt.Printf(\"Using As function: Error e is of type path error. Error: %v\\n\", pathError)\n\t}\n}\n\nfunc openFile(fileName string) error {\n\t_, err := os.Open(\"non-existing.txt\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error opening: %w\", err)\n\t}\n\treturn nil\n}\n```", "```\nUsing Assert: Error not of type path error\nUsing As function: Error e is of type path error. Error: open non-existing.txt: no such file or directory\n```", "```\nreturn fmt.Errorf(\"Error opening: %w\", err)\n```", "```\nUsing Assert: Error not of type path error\n```", "```\nUsing As function: Error e is of type path error. Error: open non-existing.txt: no such file or directory\n```"]