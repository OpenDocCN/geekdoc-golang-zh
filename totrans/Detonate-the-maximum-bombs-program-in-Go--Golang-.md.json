["```\nInput: [[1,0,3],[5,0,4]]\nOutput: 2\n```", "```\nInput:  [[2,2,2],[10,10,5]]\nOutput: 1\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc maximumDetonation(bombs [][]int) int {\n\n\tif len(bombs) == 0 {\n\t\treturn 0\n\t}\n\tmax := 1\n\tdetonationMap := make(map[int][]int)\n\n\tfor i := 0; i < len(bombs); i++ {\n\t\tfor j := 0; j < len(bombs); j++ {\n\t\t\tif i != j {\n\t\t\t\tif float64(bombs[i][2]) >= distance(bombs[i], bombs[j]) {\n\t\t\t\t\tif arr, ok := detonationMap[i]; ok {\n\t\t\t\t\t\tarr = append(arr, j)\n\t\t\t\t\t\tdetonationMap[i] = arr\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar arr []int\n\t\t\t\t\t\tarr = append(arr, j)\n\t\t\t\t\t\tdetonationMap[i] = arr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor key := range detonationMap {\n\t\tdetonated := 1\n\t\tqueue := []int{key}\n\t\tvisited := make(map[int]bool)\n\t\tvisited[key] = true\n\n\t\tfor len(queue) > 0 {\n\t\t\tcur := queue[0]\n\t\t\tqueue = queue[1:]\n\n\t\t\tfor _, val := range detonationMap[cur] {\n\t\t\t\tif !visited[val] {\n\t\t\t\t\tdetonated++\n\t\t\t\t\tvisited[val] = true\n\t\t\t\t\tqueue = append(queue, val)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif detonated == len(bombs) {\n\t\t\treturn len(bombs)\n\t\t}\n\n\t\tif detonated > max {\n\t\t\tmax = detonated\n\t\t}\n\t}\n\treturn max\n}\n\nfunc distance(a []int, b []int) float64 {\n\tret := math.Sqrt(math.Pow(float64(a[0]-b[0]), 2) + math.Pow(float64(a[1]-b[1]), 2))\n\treturn ret\n}\n\nfunc main() {\n\toutput := maximumDetonation([][]int{{1, 0, 3}, {5, 0, 4}})\n\tfmt.Println(output)\n\n\toutput = maximumDetonation([][]int{{2, 2, 2}, {10, 10, 5}})\n\tfmt.Println(output)\n\n}\n```", "```\n2\n1\n```"]