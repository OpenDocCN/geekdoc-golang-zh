- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-10-13 06:08:44'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-10-13 06:08:44
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: All data types in Golang with examples
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Golang中的所有数据类型及示例
- en: 来源：[https://golangbyexample.com/all-data-types-in-golang-with-examples/](https://golangbyexample.com/all-data-types-in-golang-with-examples/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://golangbyexample.com/all-data-types-in-golang-with-examples/](https://golangbyexample.com/all-data-types-in-golang-with-examples/)
- en: '**Note:** If you are interested in learning Golang, then for that we have a
    golang comprehensive tutorial series. Do check it out – [Golang Comprehensive
    Tutorial Series](https://golangbyexample.com/golang-comprehensive-tutorial/).
    Now let’s see the current tutorial. Below is the table of contents.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 如果你对学习Golang感兴趣，我们有一个全面的Golang教程系列，欢迎查看 – [Golang综合教程系列](https://golangbyexample.com/golang-comprehensive-tutorial/)。现在让我们来看一下当前的教程。以下是目录。'
- en: Table of Contents
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: '**   [Overview](#Overview "Overview")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**   [概述](#Overview "Overview")'
- en: '[Basic Types](#Basic_Types "Basic Types")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[基本类型](#Basic_Types "Basic Types")'
- en: '[Integers (Signed and UnSigned)](#Integers_Signed_and_UnSigned "Integers (Signed
    and UnSigned)")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[整数（有符号和无符号）](#Integers_Signed_and_UnSigned "Integers (Signed and UnSigned)")'
- en: '[Floats](#Floats "Floats")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浮点数](#Floats "Floats")'
- en: '[Complex Numbers](#Complex_Numbers "Complex Numbers")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[复数](#Complex_Numbers "Complex Numbers")'
- en: '[Byte](#Byte "Byte")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字节](#Byte "Byte")'
- en: '[Rune](#Rune "Rune")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rune](#Rune "Rune")'
- en: '[String](#String "String")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串](#String "String")'
- en: '[Booleans](#Booleans "Booleans")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[布尔值](#Booleans "Booleans")'
- en: '[Composite Types](#Composite_Types "Composite Types")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[复合类型](#Composite_Types "Composite Types")'
- en: '[Non-Reference Types](#Non-Reference_Types "Non-Reference Types")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[非引用类型](#Non-Reference_Types "Non-Reference Types")'
- en: '[Arrays](#Arrays "Arrays")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数组](#Arrays "Arrays")'
- en: '[Structs](#Structs "Structs")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结构体](#Structs "Structs")'
- en: '[Reference Types](#Reference_Types "Reference Types")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[引用类型](#Reference_Types "Reference Types")'
- en: '[Slices](#Slices "Slices")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[切片](#Slices "Slices")'
- en: '[Channels](#Channels "Channels")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通道](#Channels "Channels")'
- en: '[Maps](#Maps "Maps")'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射](#Maps "Maps")'
- en: '[Pointers](#Pointers "Pointers")'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指针](#Pointers "Pointers")'
- en: '[Functions](#Functions "Functions")'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数](#Functions "Functions")'
- en: '[Interface](#Interface "Interface")'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接口](#Interface "Interface")'
- en: '[Special case of empty interface](#Special_case_of_empty_interface "Special
    case of empty interface")'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[空接口的特殊情况](#Special_case_of_empty_interface "Special case of empty interface")'
- en: '[Conclusion](#Conclusion "Conclusion")*  *# Overview'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#Conclusion "Conclusion")*  *# 概述'
- en: Golang is statically typed programming language meaning that each variable has
    a type. Go has several built in types that we will look into in this article.
    Data types in Go can be categorized into two types
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Golang是一种静态类型编程语言，意味着每个变量都有一个类型。Go有几种内置类型，我们将在本文中探讨。Go中的数据类型可以分为两种类型。
- en: Basic Types
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本类型
- en: Composite Types
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复合类型
- en: Basic Types
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型
- en: Integers
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: Signed
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号
- en: int
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int
- en: int8
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int8
- en: int16
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int16
- en: int32
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int32
- en: int64
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int64
- en: Unsigned
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号
- en: uint
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint
- en: uint8
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint8
- en: uint16
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint16
- en: uint32
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint32
- en: uint64
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint64
- en: uintptr
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uintptr
- en: Floats
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: float32
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: float32
- en: float64
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: float64
- en: Complex Numbers
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复数
- en: complex64
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: complex64
- en: complex128
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: complex128
- en: Byte
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节
- en: Rune
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rune
- en: String
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Composite Types
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合类型
- en: Collection/Aggregation or Non-Reference Types
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合/聚合或非引用类型
- en: Arrays
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Structs
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Reference Types
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: Slices
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Maps
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Channels
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Pointers
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针
- en: Function/Methods
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法
- en: Interface
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Special case of empty Interface
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空接口的特殊情况
- en: '**Basic Types**'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**基本类型**'
- en: Let’s first discuss the basic types in GO.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下GO中的基本类型。
- en: '**Integers** (Signed and UnSigned)'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**整数**（有符号和无符号）'
- en: Integers can be signed or unsigned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以是有符号或无符号。
- en: '**Signed**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**有符号**'
- en: Signed integers are of 5 types as below
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号整数有如下五种类型：
- en: '| **Type** | **Size** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** |'
- en: '| int | Platform Dependent |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| int | 平台依赖 |'
- en: '| int8 | 8 bits/1 byte |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| int8 | 8位/1字节 |'
- en: '| int16 | 16 bits/2 byte |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| int16 | 16位/2字节 |'
- en: '| int32 | 32 bits/4 byte |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| int32 | 32位/4字节 |'
- en: '| int64 | 64 bits/8 byte |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| int64 | 64位/8字节 |'
- en: '**int**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**int**'
- en: '**Size:** Platform Dependent.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 平台依赖。'
- en: On 32 bit machines, the size of an int will be 32 bits or 4 bytes.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位机器上，int的大小为32位或4字节。
- en: On 64 bit machines, the size of an int will be 64 bits or 8 bytes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的大小为64位或8字节。
- en: '**Range**: Again Platform dependent'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：再次依赖于平台。'
- en: On 32 bit machines, the range of int will be -2^(31) to 2^(31) -1.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位机器上，int的范围为-2^(31)到2^(31)-1。
- en: On 64 bit machines, the range of int will be -2^(63) to 2^(63) -1
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的范围为-2^(63)到2^(63)-1。
- en: '**When to Use:**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: It is a good idea to use int whenever using signed Integer other than the cases
    mentioned below
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用有符号整数时，建议使用int，除非在以下提到的情况下。
- en: When the machine is a 32 bit and range needed is greater than -2^(31) to 2^(31) -1,
    then use **int64** instead **int**. Note that in this case for int64,  2 32-bit
    memory addresses to form a 64-bit number together.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当机器为 32 位且所需范围大于 -2^(31) 到 2^(31) - 1 时，使用 **int64** 而不是 **int**。请注意，在这种情况下，int64
    需要 2 个 32 位内存地址来组合成一个 64 位数字。
- en: When the range is less then use appropriate integer type.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当范围较小时，使用适当的整数类型。
- en: '**Properties:**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: Declare an int
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 int
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: int is default type for **integer.** When you don’t specify a type the default
    will be int
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int 是**整数**的默认类型。当你不指定类型时，默认类型为 int
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**bits** package of golang can help know the size of an **int** on your system'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: golang 的 **bits** 包可以帮助了解系统上 **int** 的大小
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**unsafe.Sizeof()** function can also be used to see the size of int in bytes'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unsafe.Sizeof()** 函数也可以用来查看 int 的字节大小'
- en: '**Full Working Code**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整工作代码**'
- en: Below is the full working code of the above properties
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述属性的完整工作代码
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Output:**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**int8**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**int8**'
- en: '**Size:** 8 bits or 1 byte'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 8 位或 1 字节'
- en: '**Range**: -2⁷ to 2⁷ -1.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：-2⁷ 到 2⁷ - 1。'
- en: '**When to Use:**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: Use int8 when there it is known that the int range will be between -2⁷ to 2⁷ -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知 int 范围在 -2⁷ 到 2⁷ - 1 之间时使用 int8。对于临时值，如循环不变量，仍然建议使用 int，尽管它可能占用更多空间，因为在某些操作或库调用中，它可能会被提升为
    int。
- en: For array values which lies between -27 to 27 -1, is a good use case for using
    int8\. For eg if you are storing ASCII index for lowercase letters then int8 can
    be used
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于值范围在 -27 到 27 - 1 的数组，使用 int8 是一个好用例。例如，如果你存储小写字母的 ASCII 索引，则可以使用 int8。
- en: It is a good idea to use int8 for data values.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据值，使用 int8 是一个好主意。
- en: '**Example:**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点
- en: Declare an int8
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 int8
- en: Print size of int8 in bytes
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 int8 的字节大小
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Output:**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**int16**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**int16**'
- en: '**Size:** 16 bits or 2 byte'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 16 位或 2 字节'
- en: '**Range**: -2^(15) to 2^(15) -1.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：-2^(15) 到 2^(15) - 1。'
- en: '**When to Use:**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: Use int16 when there it is known that the int range will be between -2^(15) to
    2^(15) -1.  For temporary values such as loop invariants, it is still advisable
    to use int even though it might take more space because it is likely to be promoted
    to int in some operations or library calls.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知 int 范围在 -2^(15) 到 2^(15) - 1 之间时使用 int16。对于临时值，如循环不变量，仍然建议使用 int，尽管它可能占用更多空间，因为在某些操作或库调用中，它可能会被提升为
    int。
- en: For array values which lies between -215 to 215 -1, is a good use case for using
    int8\. For eg if you are storing ASCII index for lowercase letters than int16
    can be used.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于值范围在 -215 到 215 - 1 的数组，使用 int8 是一个好用例。例如，如果你存储小写字母的 ASCII 索引，则可以使用 int16。
- en: '**Example:**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点
- en: Declare an int16
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 int16
- en: Print size of int16 in bytes
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 int16 的字节大小
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Output:**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**int32**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**int32**'
- en: '**Size:** 32 bits or 4 byte'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 32 位或 4 字节'
- en: '**Range**: -2^(31) to 2^(31) -1.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：-2^(31) 到 2^(31) - 1。'
- en: '**Example:**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点
- en: Declare an int32
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 int32
- en: Print size of int8 in bytes
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 int8 的字节大小
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Output:**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**int64**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**int64**'
- en: '**Size:** 64 bits or 8 byte'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 64 位或 8 字节'
- en: '**Range**: -2^(63) to 2^(63) -1'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：-2^(63) 到 2^(63) - 1'
- en: '**When to Use:**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: '**int64** is used when the range is higher. For eg **time.Duration** is of
    type **int64**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int64** 用于范围较高的情况。例如，**time.Duration** 的类型是 **int64**'
- en: '**Example:**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点
- en: Declare an int64
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 int64
- en: Print size of int64 in bytes
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 int64 的字节大小
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Output:**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**UnSigned**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**无符号**'
- en: UnSigned integers are of 5 types as below
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数有 5 种类型，如下所示
- en: '| **Type** | **Size** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** |'
- en: '| uint | Platform Dependent |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| uint | 平台相关 |'
- en: '| uint8 | 8 bits/1 byte |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| uint8 | 8 位/1 字节 |'
- en: '| uint16 | 16 bits/2 byte |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| uint16 | 16 位/2 字节 |'
- en: '| uint32 | 32 bits/4 byte |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 32 位/4 字节 |'
- en: '| uint64 | 64 bits/8 byte |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 64 位/8 字节 |'
- en: '**uint**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint**'
- en: '**Size:** Platform Dependent.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 平台相关。'
- en: On 32 bit machines, the size of an int will be 32 bits or 4 byte.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位机器上，int 的大小将是 32 位或 4 字节。
- en: On 64 bit machines, the size of an int will be 64 bits or 8 byte
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 64 位机器上，int 的大小将是 64 位或 8 字节
- en: '**Range**: Again Platform dependent'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：再次平台相关'
- en: On 32 bit machines, the range of int will be -2^(31) to 2^(31) -1.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位机器上，int 的范围为 -2^(31) 到 2^(31) - 1。
- en: On 64 bit machines, the range of int will be -2^(63) to 2^(63) -1
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的范围将是 -2^(63) 到 2^(63) -1。
- en: '**When to Use:**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: It is a good idea to use uint  whenever using signed Integer other than the
    cases mention below
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用其他有符号整数的情况下，建议使用uint。
- en: When the machine is a 32 bit and range needed is greater than -231 to 231 -1,
    then use int64 instead int. Note that in this case for int64,  2 32-bit memory
    addresses to form a 64-bit number together.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当机器为32位且所需范围大于 -231 到 231 -1 时，请使用int64而不是int。请注意，在这种情况下，两个32位内存地址合成一个64位数字。
- en: When the range is less than use the appropriate int type
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当范围较小时，请使用适当的int类型。
- en: '**Properties:**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: Declare a uint
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个uint。
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**bits** package of golang can help know the size of an **uint** on your system'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: golang的**bits**包可以帮助了解系统上**uint**的大小。
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**unsafe.Sizeof()** function can also be used to see the size of uint in bytes'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unsafe.Sizeof()** 函数也可用于查看uint的字节大小。'
- en: '**Full Working Code**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整工作代码**'
- en: Below is the full working code of above properties
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述属性的完整工作代码。
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Output:**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**uintptr**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**uintptr**'
- en: This is an unsigned integer type that is large enough to hold any pointer address.
    Therefore is size and range are platform dependent.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种无符号整数类型，足够大以容纳任何指针地址。因此，其大小和范围依赖于平台。
- en: '**Size:** Platform Dependent.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 依赖于平台。'
- en: On 32 bit machines, the size of int will be 32 bits or 4 byte.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位机器上，int的大小将为32位或4字节。
- en: On 64 bit machines, the size of int will be 64 bits or 8 byte
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的大小将为64位或8字节。
- en: '**Range**: Again Platform dependent'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：再次依赖于平台。'
- en: On 32 bit machines, the range of int will be -2^(31) to 2^(31) -1.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位机器上，int的范围将是 -2^(31) 到 2^(31) -1。
- en: On 64 bit machines, the range of int will be -2^(63) to 2^(63) -1
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的范围将是 -2^(63) 到 2^(63) -1。
- en: '**Properties:**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: A uintptr can be converted to **unsafe.Pointer** and viceversa
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uintptr可以转换为**unsafe.Pointer**，反之亦然。
- en: Arithmetic can be performed on the uintptr
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对uintptr执行算术运算。
- en: uintptr even though it holds a pointer address, is just a value and does not
    references any object. Therefore
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uintptr虽然存储指针地址，但只是一个值，不引用任何对象。因此。
- en: Its value will not be updated if the corresponding object moves. Eg When goroutine
    stack changes
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果相应对象移动，其值将不会更新。例如，当goroutine栈变化时。
- en: The corresponding object can be garbage collected.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应对象可以被垃圾收集。
- en: '****When to Use:****'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '****何时使用：****'
- en: '***   Its purpose is to be used along with unsafe.Pointer mainly used for unsafe
    memory access.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '***其目的主要是与unsafe.Pointer一起使用，以便进行不安全的内存访问。'
- en: When you want to save the pointer address value for printing it or storing it.
    Since the address is just stored and does not reference anything, the corresponding
    object can be garbage collected.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想保存指针地址值以进行打印或存储时。由于地址只是被存储并不引用任何东西，相应的对象可以被垃圾收集。
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Output:**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**uint8**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint8**'
- en: '**Size:** 8 bits or 1 byte'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 8位或1字节。'
- en: '**Range**:  0 to 255 or 0 to 2⁸ -1.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0 到 255 或 0 到 2⁸ -1。'
- en: '**When to Use:**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: Use uint8 when there it is known that the int range will be between 2⁸ -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知int范围将在 2⁸ -1之间时，使用uint8。对于临时值，如循环不变量，尽管可能占用更多空间，但仍建议使用int，因为在某些操作或库调用中可能会提升为int。
- en: For array values which lies between  2⁸ -1\. is a good use case for using uint8\.
    For eg if you are storing ASCII index in an array then **uint8** can be used.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于位于 2⁸ -1 之间的数组值，使用uint8是一个不错的用例。例如，如果你在数组中存储ASCII索引，则可以使用**uint8**。
- en: '**Example:**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点。
- en: Declare a uint8
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个uint8。
- en: Print size of uint8 in bytes
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印uint8的字节大小。
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Output:**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**uint16**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint16**'
- en: '**Size:** 16 bits or 2 byte'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 16位或2字节。'
- en: '**Range**: 0 to 2^(16) -1'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0 到 2^(16) -1。'
- en: '**When to Use:**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: Use int16 when there it is known that the int range will be between 0 to 2^(16) -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知int范围将在0到2^(16) -1之间时，使用int16。对于临时值，如循环不变量，尽管可能占用更多空间，但仍建议使用int，因为在某些操作或库调用中可能会提升为int。
- en: For array values which lies between -0 to 2^(16) -1, is a good use case for
    using int8\.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于位于 -0 到 2^(16) -1 之间的数组值，使用int8是一个不错的用例。
- en: '**Example:**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下要点
- en: Declare a uint16
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个uint16
- en: Print size of uint16 in bytes
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印uint16的字节大小
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Output:**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**uint32**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint32**'
- en: '**Size:** 32 bits or 4 byte'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 32位或4字节'
- en: '**Range**: 0 to 2^(32) -1'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0到2^(32) -1'
- en: '**Example:**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下要点
- en: Declare a uint32
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个uint32
- en: Print size of uint32 in bytes
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印uint32的字节大小
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Output:**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**uint64**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint64**'
- en: '**Size:** 64 bits or 8 byte'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 64位或8字节'
- en: '**Range**: 0 to 2^(64) -1'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0到2^(64) -1'
- en: '**When to Use:**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用时机：**'
- en: uint64 is used when the range is higher.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint64在范围更高时使用。
- en: '**Example:**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下要点
- en: Declare a uint64
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个uint64
- en: Print size of uint64 in bytes
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印uint64的字节大小
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Output:**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Floats**'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**浮点数**'
- en: Floats are numbers with decimals. It is of two types
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是带小数的数字。它有两种类型
- en: '| **Type** | **Size** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** |'
- en: '| float32 | 32 bits or 4 bytes |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| float32 | 32位或4字节 |'
- en: '| float64 | 64 bits or 8 bytes |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| float64 | 64位或8字节 |'
- en: '**float64** is the default float type. When you initialize a variable with
    a decimal value and don’t specify the float type, the default type inferred will
    be **float64**.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**float64**是默认的浮点类型。当你用小数值初始化变量而不指定浮点类型时，推断的默认类型将是**float64**。'
- en: '**float32**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**float32**'
- en: '**float32** uses single-precision floating point format to store values. Basically
    it is the set of all IEEE-754 32-bit floating-point numbers. The 32 bits are divided
    into – 1 bit sign, 8 bits exponent, and 23 bits mantissa. float 32 take half much
    size as float 64 and are comparatively faster on some machine architectures.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**float32**使用单精度浮点格式存储值。基本上，它是所有IEEE-754 32位浮点数的集合。32位被划分为– 1位符号位，8位指数，和23位尾数。float32占用的空间是float64的一半，在某些机器架构上速度相对较快。'
- en: '**Size**: 32 bits or 4 bytes'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：32位或4字节'
- en: '**Range**: 1.2E-38 to 3.4E+38′'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：1.2E-38到3.4E+38'
- en: '**DefaultValue**: 0.0'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**：0.0'
- en: '**When to Use:**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用时机：**'
- en: If in your system memory is a bottleneck and range is less, then **float32**
    can be used.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统内存是瓶颈且范围较小，则可以使用**float32**。
- en: '**Example:**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下要点
- en: Declare a float32
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个float32
- en: Print size of float32 in bytes
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印float32的字节大小
- en: '**Code:**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Output:**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**float64**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**float64**'
- en: float64 uses a double-precision floating-point format to store values. Basically
    it is the set of all IEEE-754 64-bit floating-point numbers. The 64 bits are divided
    into – 1-bit sign, 11 bits exponent, 52 bits mantissa. float64 takes twice as
    much size compared to float32 but can represent numbers more accurately than float32.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: float64使用双精度浮点格式存储值。基本上，它是所有IEEE-754 64位浮点数的集合。64位被划分为– 1位符号位，11位指数，52位尾数。float64占用的空间是float32的两倍，但可以比float32更准确地表示数字。
- en: '**Size**: 32 bits or 4 bytes'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：32位或4字节'
- en: '**Range**: 1.2E-38 to 3.4E+38'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：1.2E-38到3.4E+38'
- en: '**DefaultValue**: 0.0'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**：0.0'
- en: '**When to Use:**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用时机：**'
- en: When the precision needed is high
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要高精度时
- en: '**Example:**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下要点
- en: Declare a float64
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个float64
- en: Print size of float64 in bytes
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印float64的字节大小
- en: Default is float64 when you don’t specify a type
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不指定类型时，默认是float64
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Output:**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Complex Numbers**'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**复数**'
- en: Complex Numbers are of two types
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 复数有两种类型
- en: '| **Type** | **Property** |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **属性** |'
- en: '| complex64 | Both real and imaginary part are float32 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| complex64 | 实部和虚部都是float32 |'
- en: '| complex128 | Both real and imaginary part are float64 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| complex128 | 实部和虚部都是float64 |'
- en: The default complex type is complex128
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的复数类型是complex128。
- en: '**Initialization**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化**'
- en: Complex Numbers can be initialized in two ways
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 复数可以通过两种方式初始化
- en: Using complex function. It has below signature. Do make sure that both a and
    b should be of same type , meaning either they both should be float32 or both
    should be float64
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复数函数。它具有以下签名。请确保a和b的类型相同，意味着它们要么都是float32，要么都是float64。
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the shorthand syntax. This is used when creating a complex number with
    direct numbers. The complex type created using below method will be of type **complex128**
    if type is not specified
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简写语法。这在使用直接数字创建复数时使用。如果未指定类型，则使用下面的方法创建的复数类型将为**complex128**。
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**complex64**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**complex64**'
- en: For complex 64 both real and imaginary part are float32
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于complex 64，实部和虚部都是float32
- en: '**Size**: Both real and imaginary part are of same size as float32\. It is
    of size 32 bits or 4 bytes'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：实部和虚部的大小与 float32 相同。大小为 32 位或 4 字节'
- en: '**Range**: Both real and imaginary part range is same as float32 i.e 1.2E-38
    to 3.4E+38'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：实部和虚部的范围与 float32 相同，即 1.2E-38 到 3.4E+38'
- en: '**Example**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: Below is a sample code that shows
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示的示例代码
- en: How to create a complex64 number using the above two method
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用上述两种方法创建 complex64 数字
- en: Print size of a complex64 number. Size will be  8 bytes(4 +4) which is equivalent
    to two float32 numbers
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 complex64 数字的大小。大小将为 8 字节（4 + 4），相当于两个 float32 数字
- en: Print type of a complex64 number
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 complex64 数字的类型
- en: + operation on complex number
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: + 操作符在复数上
- en: '**Code:**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE33]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Output:**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE34]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**complex128**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**complex128**'
- en: For complex128 both **real** and **imaginary** part are **float64**
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 complex128，实部和虚部都是 **float64**
- en: '**Size**: Both **real** and **imaginary** part are of same size as float64\.
    It is of size 64 bits or 8 bytes'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：实部和虚部的大小与 float64 相同。大小为 64 位或 8 字节'
- en: '**Range**: Both **real** and **imaginary** part range is same as **float64**
    i.e -1.7E+308 to +1.7E+308'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：实部和虚部的范围与 **float64** 相同，即 -1.7E+308 到 +1.7E+308'
- en: '**Example**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: Below is a sample code that shows
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示的示例代码
- en: How to create a complex128 number using above two method. It also shows when
    type is not specified, the default type will be **complex128**
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用上述两种方法创建 complex128 数字。它还显示当类型未指定时，默认类型将为 **complex128**
- en: Print size of a complex128 number. Size will be  16 bytes(8 +8) which is equivalent
    to two float64 numbers
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 complex128 数字的大小。大小将为 16 字节（8 + 8），相当于两个 float64 数字
- en: Print type of a complex128 number
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 complex128 数字的类型
- en: Different operations on complex number
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对复数进行不同操作
- en: '**Code:**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Output:**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE36]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Byte**'
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**字节**'
- en: byte in Go is an alias for **uint8** meaning it is an integer value. This integer
    value is of 8 bits and it represents one byte i.e number between 0-255). A single
    byte therefore can represent ASCII characters. Golang does not have any data type
    of ‘char’. Therefore
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的字节是 **uint8** 的别名，意味着它是一个整数值。这个整数值为 8 位，表示一个字节，即 0-255 之间的数字。因此，一个字节可以表示
    ASCII 字符。Golang 没有 ‘char’ 的数据类型。因此
- en: byte is used to represent the ASCII character
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节用于表示 ASCII 字符
- en: rune is used to represent all UNICODE characters which include every character
    that exists. We will study about rune later in this tutorial.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rune 用于表示所有 Unicode 字符，包括所有存在的字符。我们将在本教程后面学习 rune。
- en: '**Define Byte**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义字节**'
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While declaring byte we have specify the type, as we have in the program above.
    If we don’t specify the type, then the default type is meant as a **rune.**
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明字节时，我们必须指定类型，如上面的程序所示。如果不指定类型，则默认类型被视为 **rune。**
- en: '**Example**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'In below code example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中：
- en: How to define a byte
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义字节
- en: Print the byte type
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字节类型
- en: Print size of byte
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字节大小
- en: '[PRE38]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Output:**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE39]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Rune**'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**符文**'
- en: rune in Go is  an alias for **int32** meaning it is an integer value. This integer
    value is meant to represent a Unicode Code Point. To understand rune you have
    to know what Unicode is. Below is short description but you can refer to famous
    blog post about it – [The Absolute Minimum Every Software Developer Absolutely,
    Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 rune 是 **int32** 的别名，意味着它是一个整数值。这个整数值用来表示 Unicode 代码点。要理解 rune，您必须了解 Unicode。下面是简短的描述，您可以参考著名的博客文章
    – [每个软件开发人员绝对必须了解的 Unicode 和字符集的绝对最小知识（没有借口！）](http://www.joelonsoftware.com/articles/Unicode.html)
- en: '**What is UniCode**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 Unicode**'
- en: Unicode is a superset of ASCII characters which assigns a unique number to every
    character that exists. This unique number is called Unicode Code Point.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 是 ASCII 字符的超集，它为每个存在的字符分配一个唯一的数字。这个唯一的数字称为 Unicode 代码点。
- en: For eg
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: Digit **0** is represented as Unicode Point **U+0030 (Decimal Value – 48)**
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 **0** 表示为 Unicode 点 **U+0030 (十进制值 – 48)**
- en: Small Case **b** is represented as Unicode Point  **U+0062 (Decimal Value –
    98)**
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写 **b** 表示为 Unicode 点 **U+0062 (十进制值 – 98)**
- en: A pound symbol **£ **is represented as Unicode Point **U+00A3 (Decimal Value
    – 163)**
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英镑符号 **£** 表示为 Unicode 点 **U+00A3 (十进制值 – 163)**
- en: Visit [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)
    to know about Unicode Point of other characters. But Unicode doesn’t talk about
    how these code points will be saved in memory. This is where **utf-8** comes into
    picture
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)
    了解其他字符的 Unicode 点。但是 Unicode 不讨论这些代码点如何保存在内存中。这就是 **utf-8** 进入的地方。
- en: '**UTF-8**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-8**'
- en: utf-8 saves every Unicode Point either using 1, 2, 3 or 4 bytes. ASCII points
    are stored using 1 byte. That is why rune is an alias for int32 because a Unicode
    Point can be of max 4 bytes in Go as in GO every string is encoded using utf-8.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: utf-8 使用 1、2、3 或 4 个字节保存每个 Unicode 点。ASCII 点使用 1 个字节存储。这就是为什么 rune 是 int32 的别名，因为在
    Go 中，Unicode 点的最大字节数为 4，而 Go 中的每个字符串都是使用 utf-8 编码的。
- en: Every rune is intended to refer to one Unicode Point.  For eg if you print a
    string after typecasting it to a rune array then it will print the Unicode Point
    for each of character. For for below string **“0b£”** output will be – **[U+0030
    U+0062 U+00A3]**
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 rune 旨在指代一个 Unicode 点。例如，如果你在将字符串强制转换为 rune 数组后打印它，则会打印每个字符的 Unicode 点。对于下面的字符串
    **“0b£”**，输出将是 – **[U+0030 U+0062 U+00A3]**。
- en: '[PRE40]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Declare Rune**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明 Rune**'
- en: A rune is declared using a character between single quotes like below declaring
    a variable named **‘rPound’**
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 rune 是通过在单引号中声明的字符，例如声明一个名为 **‘rPound’** 的变量。
- en: '[PRE41]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After declaring Rune you can perform below things as well
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 Rune 后，你还可以执行以下操作。
- en: '**Print Type –** Output will be **int32**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印类型 –** 输出将是 **int32**。'
- en: '[PRE42]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Print Unicode Code Point –** Output will be **U+00A3**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印 Unicode 代码点 –** 输出将是 **U+00A3**。'
- en: '[PRE43]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Print Character –** Output will be **£**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印字符 –** 输出将是 **£**。'
- en: '[PRE44]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**When to Use**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用**'
- en: You should use a rune when you intend to save Unicode Code Point in the value.
    A rune array should be used when all values in the array are meant to be a Unicode
    Code Point.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打算在值中保存 Unicode 代码点时，应使用一个 rune。当数组中的所有值都旨在表示 Unicode 代码点时，应使用 rune 数组。
- en: '**Code:**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: Below is the code illustrating each point we discussed
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是说明我们讨论的每一点的代码。
- en: '[PRE45]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Output:**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE46]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**String**'
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: string is a read only slice of bytes in golang. String can be initialized in
    two ways
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 golang 中只读的字节切片。字符串可以通过两种方式初始化。
- en: using double quotes “” eg “this”
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双引号 “” 例如 “this”。
- en: string in double quotes honors the escape sequences. For eg if the string contains
    a \n then while printing there will be a new line
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号中的字符串会遵循转义序列。例如，如果字符串包含 \n，那么在打印时会产生新的一行。
- en: using back quotes ` eg  \`this`
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反引号 ` 例如 \`this`。
- en: String in back quotes is just a raw string and it does not honor any kind of
    escape sequences.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号中的字符串只是一个原始字符串，不会遵循任何类型的转义序列。
- en: Each character in a string will occupy some bytes depending upon encoding used.
    For eg in utf-8 encoded string, each character will occupy between 1-4 bytes.
    You can read about utf-8 in this must read famous blog-[The Absolute Minimum Every
    Software Developer Absolutely, Positively Must Know About Unicode and Character
    Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html).   In
    utf-8 , the characters **a** or **b** are encoded using 1  byte while the character
    pound sign **£** is encoded using two bytes . Therefore the string “ab£” will
    output 4 bytes when you will convert the string to byte array and print it like
    below
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的每个字符将根据使用的编码占用一些字节。例如，在 utf-8 编码的字符串中，每个字符将占用 1 到 4 个字节。你可以阅读关于 utf-8 的必读博客——[每个软件开发者必须了解的
    Unicode 和字符集的绝对最小知识（没有借口！）](http://www.joelonsoftware.com/articles/Unicode.html)。在
    utf-8 中，字符 **a** 或 **b** 使用 1 个字节编码，而字符英镑符号 **£** 使用 2 个字节编码。因此，字符串 “ab£” 在转换为字节数组并打印时将输出
    4 个字节。
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Output**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE48]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Also when you try to print the length of the above string using **len(“ab£”),**
    it will output 4 and not 3 because it contains 4 bytes.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用 **len(“ab£”)** 打印上述字符串的长度时，它将输出 4 而不是 3，因为它包含 4 个字节。
- en: Also note that **range** loops over sequences of byte which form each character,
    therefore for the below range loop
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，**range** 循环遍历每个字符形成的字节序列，因此对于下面的 range 循环。
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Output will be
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是
- en: '[PRE50]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are many operations that can be performed on a string. One such operation
    is concatenation which combines two string. The sign ‘+’ is used for concatenation.
    Let’s see full working  code for all above things that we discussed
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对字符串执行许多操作。其中一种操作是连接，它将两个字符串合并。连接使用符号 ‘+’。让我们看看我们讨论的所有内容的完整工作代码。
- en: '**Code:**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE51]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Output:**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE52]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Booleans**'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**布尔值**'
- en: The data type is **bool** and has two possible values true or false.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是**bool**，有两个可能的值：true 或 false。
- en: 'Default Value: false'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值：false。
- en: 'Operations:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 操作：
- en: AND – &&
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和 – &&
- en: OR  – ||
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或 – ||
- en: Negation – !
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取反 – !
- en: '**Example**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: The below code example shows
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了。
- en: If not initialized the default value is **false**
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未初始化，默认值为**false**。
- en: All the above operations on the bool
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有上述操作在 bool 上。
- en: '**Code**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '[PRE53]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Output:**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE54]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Composite Types**'
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**复合类型**'
- en: '**Non-Reference Types**'
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**非引用类型**'
- en: '**Arrays**'
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组**'
- en: Arraysin go are values. They are fixed-length sequences of the same type. Since
    arrays in Go are values, that is why
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的数组是值。它们是固定长度的同类型序列。由于 Go 中的数组是值，这就是原因。
- en: When you assign an array to another variable, it copies the entire array
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个数组赋值给另一个变量时，它会复制整个数组。
- en: When you pass an array as an argument to a function, it makes an entire copy
    of the array instead of passing just the address
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将数组作为参数传递给一个函数时，它会复制整个数组，而不仅仅是传递地址。
- en: An array is declared as below. Assume N is the size of the array
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的声明如下。假设 N 是数组的大小。
- en: Specifying size  and values both
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时指定大小和数值。
- en: '[PRE55]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Specifying size  – No values. Values are set to default zero value of that type
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定大小 – 无数值。值被设置为该类型的默认零值。
- en: '[PRE56]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As we said arrays have fixed length. Therefore
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所说，数组的长度是固定的。因此。
- en: We cannot assign an array to a different array of the same type but different
    length
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能将一个数组赋值给同类型但长度不同的另一个数组。
- en: When you pass an array as a function argument, then size is also part of it.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将数组作为函数参数传递时，大小也是其中的一部分。
- en: Let’s see an example of array. Below example
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个数组的例子。以下示例。
- en: Illustrates how to declare an array
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示如何声明一个数组。
- en: Pass array as a function argument
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组作为函数参数传递。
- en: '[PRE57]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Output:**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE58]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Structs**'
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结构体**'
- en: In GO struct is named collection of fields. These fields can be of different
    types. Struct acts as a container of related data of heterogeneous data type.
    For example, different attributes are used to represent and employee in an organization.
    Employee can have
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，结构体是字段的集合。这些字段可以是不同类型的。结构体作为异构数据类型相关数据的容器。例如，不同的属性用来表示组织中的员工。员工可以有。
- en: Name of string type
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类型的名称。
- en: Age of int type
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型的年龄。
- en: DOB of time.Time type
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间类型的出生日期（DOB）。
- en: .. and so on. A struct can be used to represent an employee
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ..等等。结构体可以用来表示一个员工。
- en: '[PRE59]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The below program depicts
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序描述了。
- en: Declare a struct
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个结构体。
- en: Initializing a struct in different ways
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同方式初始化结构体。
- en: Size of a struct is the sum of the size of its fields
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的大小是其字段大小的总和。
- en: '[PRE60]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Output:**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE61]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Reference Types**'
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**引用类型**'
- en: '**Slices**'
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**切片**'
- en: Slices are dynamically sized, reference into the elements of an array. As mentioned
    above arrays are of fixed size, so slices give a more flexible interface to arrays.
    A slice is a reference type as it internally references an array. It is internally
    represented by three fields
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的大小是动态的，引用数组的元素。如上所述，数组是固定大小的，因此切片为数组提供了更灵活的接口。切片是一种引用类型，因为它内部引用一个数组。它内部由三个字段表示。
- en: Address to the underlying array
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向基础数组的地址。
- en: Length of the slice
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片的长度。
- en: Capacity of the slice
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片的容量。
- en: Slices are typed by the type of the underlying array element, not by its length
    or capacity. Thus two slices will be of the same type if the type of the underlying
    array is same irrespective of its length and capacity. The built in **append**
    function can be used to add more values to the underlying array. If on using **append**
    function the length of the slice increases by current capacity, then a new slice
    is allocated of double the capacity and elements of the current slice are copied
    to that.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的类型由基础数组元素的类型决定，而不是由其长度或容量决定。因此，如果基础数组的类型相同，不论其长度和容量如何，两个切片将具有相同的类型。内置的**append**函数可以用来向基础数组添加更多值。如果在使用**append**函数时切片的长度超过当前容量，则分配一个新的切片，容量为当前容量的两倍，当前切片的元素被复制到该新切片中。
- en: The built in function **len** can you used to get the current length of the
    sliceInitialising a slice
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数**len**可以用来获取当前切片的长度，初始化切片。
- en: Using make – it helps you create a slice specifying the type of array, its length
    and capacity. Specifying length and capacity is optional. If length is specified
    and capacity is not, then capacity will be equal to length
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 make – 它帮助你创建一个切片，指定数组的类型、长度和容量。指定长度和容量是可选的。如果指定了长度而未指定容量，则容量将等于长度。
- en: '[PRE62]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Direct initialization. The below example creates a slice of string.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接初始化。以下示例创建一个字符串的切片。
- en: '[PRE63]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Slices can be also be created from an array or from a different slice.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也可以从数组或其他切片创建。
- en: Below is a program showing an example of a slice showing
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个程序，展示了一个切片的示例
- en: Declare a slice using the above ways
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上述方法声明一个切片
- en: Showing append function
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示追加函数
- en: How to iterate over a slice
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何遍历一个切片
- en: '[PRE64]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Output:**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE65]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Channels**'
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通道**'
- en: Channels provide synchronization and communication between goroutines. You can
    think of it as a pipe through which goroutines can send values and receive values.
    The operation <- is used to send or receive, with direction of arrow specifying
    the direction of flow of data
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通道提供了goroutine之间的同步和通信。你可以将其视为一个管道，通过这个管道，goroutine可以发送和接收值。操作符<-用于发送或接收，箭头的方向指定了数据流的方向。
- en: '[PRE66]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Channel are of two types
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 通道有两种类型
- en: '**Unbuffered Channel**- It doesn''t have any capacity to hold and values and
    thus'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缓冲通道** - 它没有任何容量来存储值，因此'
- en: Send on a channel is block unless there is another goroutine to receive.
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通道上发送操作会阻塞，除非有另一个goroutine来接收。
- en: Receive is block until there is another goroutine on the other side to send.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收在另一侧有另一个goroutine发送之前会阻塞。
- en: '**Buffered Channel-** You can specify the size of buffer here and for them'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲通道** - 你可以在这里指定缓冲区的大小'
- en: Send on a buffer channel only blocks if the buffer is full
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当缓冲区满时，发送到缓冲通道才会阻塞
- en: Receive is the only block is buffer of the channel is empty
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道的缓冲区为空时，接收是唯一会阻塞的操作
- en: A  channel holds data of a particular type at a time. While creating a channel,
    the type of data l has to be specified while initializing a new channel. Channel
    can be created using make. In the below example, we are creating a channel which
    holds data of type string.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通道一次只能持有特定类型的数据。在创建通道时，必须在初始化新通道时指定数据类型。在下面的示例中，我们创建了一个持有字符串类型数据的通道。
- en: '[PRE67]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Closing a channel
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭通道
- en: The **close()** function can be used to close a channel. Closing a channel means
    that no more values can be sent to the channel
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**close()** 函数可用于关闭通道。关闭通道意味着不能再向通道发送值'
- en: Let's see a working code example of both buffered and unbuffered channel
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个同时使用缓冲和无缓冲通道的工作代码示例
- en: '**Buffered Channel Example:**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲通道示例：**'
- en: '[PRE68]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Output:**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE69]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**UnBuffered Channel Example:**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**无缓冲通道示例：**'
- en: '[PRE70]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**Output:**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE71]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '**Maps**'
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**映射**'
- en: maps are golang builtin datatype similar to a hash which map key to a value.
    maps are referenced data types. When you assign one map to another both refer
    to the same underlying map.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是Go语言内置的数据类型，类似于哈希，映射键到值。映射是引用数据类型。当你将一个映射赋值给另一个映射时，两个映射都引用同一个底层映射。
- en: '**Zero Value**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**零值**'
- en: zero value of a map is nil
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的零值是nil
- en: '**Declare**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明**'
- en: A map can be declared using the var keyword specifying the type of both it's
    key and value. For eg below map declares a map with the name
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用var关键字声明一个映射，并指定其键和值的类型。例如，下面的映射声明了一个名称为
- en: '[PRE72]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Initialize**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化**'
- en: Using make
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用make
- en: '[PRE73]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using curly braces. You can specify map literal value in the map or can also
    leave empty curly braces
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大括号。你可以在映射中指定映射字面量值，也可以留空的大括号
- en: '[PRE74]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Operations**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**'
- en: Add to a map
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加到一个映射
- en: '[PRE75]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Get from a map
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从映射中获取
- en: '[PRE76]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Delete a key from the map
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从映射中删除一个键
- en: '[PRE77]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**Example**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: The below example shows all the points we discussed above
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了我们讨论过的所有要点
- en: '[PRE78]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Output**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE79]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**Pointers**'
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指针**'
- en: Pointer is a variable that holds a memory address of another variable. The zero
    value of a pointer is nil.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是一个变量，它保存另一个变量的内存地址。指针的零值是nil。
- en: '**Declare a pointer**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明一个指针**'
- en: In the below example ex is int pointer.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，ex是int指针。
- en: '[PRE80]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**Initialize**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化**'
- en: '**&** used to get the address of a variable'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**&** 用于获取变量的地址'
- en: '[PRE81]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '* operator can be used to dereference a pointer which means getting the value
    at address stored in the pointer.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '* 运算符可用于解引用指针，这意味着获取存储在指针地址中的值。'
- en: '[PRE82]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Pointers can also be initialized using **new** operator
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 指针也可以使用 **new** 运算符初始化
- en: '[PRE83]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Let's see a working code covering all the above points
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个涵盖上述所有要点的工作代码
- en: '[PRE84]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '**Output:**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE85]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**Functions**'
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数**'
- en: In Go function are values and can be passed around like a value. Basically,
    function can be used as first-order objects and can be passed around.  The signature
    of a function is
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，函数是值，可以像值一样传递。基本上，函数可以作为一等对象使用并被传递。函数的签名是
- en: '[PRE86]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: A function has a name, arguments and returns values. Also, note that there are
    some important differences between method and function in Go. Let's see the signature
    of a method
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有一个名称、参数和返回值。此外，请注意 Go 中方法和函数之间的一些重要区别。让我们看看一个方法的签名。
- en: '**Method:**'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法：**'
- en: '[PRE87]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: From the above signature, it is clear that the method has a receiver argument.
    A receiver can be a struct or any other type. The method will have access to the
    properties of the receiver and can call the receiver's other methods.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述签名可以看出，该方法有一个接收者参数。接收者可以是一个结构体或其他任何类型。该方法将访问接收者的属性，并可以调用接收者的其他方法。
- en: Below is a working example of function
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个函数的工作示例。
- en: '[PRE88]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**Output:**'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE89]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Interface**'
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**接口**'
- en: Interface is a type in Go which is a collection of method signatures. Any type
    which implements all methods of the interface is of that interface type. Zero
    value of an interface is nil.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是 Go 中的一种类型，是方法签名的集合。任何实现了接口所有方法的类型都属于该接口类型。接口的零值是 nil。
- en: '**Signature of Interface**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口的签名**'
- en: '[PRE90]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Interface are implemented implicitly**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口是隐式实现的**'
- en: There is no explicit declaration that a type implements an interface. In fact,
    in Go there doesn't exist any **"implements"** keyword similar to Java.  A type
    implements an interface if it implements all the methods of the interface.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 类型实现接口没有明确的声明。事实上，在 Go 中并没有类似于 Java 的 **“implements”** 关键字。如果一个类型实现了接口的所有方法，那么它就实现了该接口。
- en: It is correct to define a variable of an interface type and we can assign any
    concrete type value to this variable if the concrete type implements all the methods
    of the interface. Let's see a working example of interface. In the below program
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个接口类型的变量是正确的，如果具体类型实现了接口的所有方法，我们可以将任何具体类型的值分配给该变量。让我们来看一个接口的工作示例。在下面的程序中。
- en: We declare an interface of name shape with one method **area**
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明一个名为 shape 的接口，其中包含一个方法 **area**。
- en: square struct implements the area method, hence it implicitly implements the
    shape interface
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: square 结构体实现了 area 方法，因此它隐式实现了 shape 接口。
- en: we declare the variable of name "s" of type shape.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明一个名为 "s" 的 shape 类型变量。
- en: s is assigned a concrete value of type square. This works because square struct
    implements all methods of shape interface
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: s 被分配了具体类型 square 的值。这是可行的，因为 square 结构体实现了 shape 接口的所有方法。
- en: '[PRE91]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**Output:**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE92]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**Special case of empty interface**'
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**空接口的特殊情况**'
- en: 'An empty interface has no methods, hence by default all concrete types implement
    the empty interface. If you write a function that accepts an empty interface then
    you can pass any type to that function. See working code below:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空接口没有方法，因此默认情况下所有具体类型都实现了空接口。如果您编写一个接受空接口的函数，那么您可以将任何类型传递给该函数。请参见下面的工作代码：
- en: '[PRE93]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '**Output:**'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE94]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '**Conclusion**'
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This is all about the builtin data types that exist in Go. Hopefully by going
    through this article you will have better undertstanding of data types in Go.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Go 中存在的内置数据类型。希望通过阅读本文，您能更好地理解 Go 中的数据类型。
- en: '[sidetoc](https://golangbyexample.com/tag/sidetoc/)***'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[侧边目录](https://golangbyexample.com/tag/sidetoc/)***'
