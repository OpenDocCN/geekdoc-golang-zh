["```\n var a int\n```", "```\nb := 2 //The default is also int\nfmt.Println(reflect.TypeOf(b)) => int\n```", "```\n//This is computed as const uintSize = 32 << (^uint(0) >> 32 & 1) // 32 or 64\nsizeOfIntInBits := bits.UintSize\nfmt.Println(sizeOfIntInBits) => 32 0r 34\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"math/bits\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //This is computed as const uintSize = 32 << (^uint(0) >> 32 & 1) // 32 or 64\n    sizeOfIntInBits := bits.UintSize\n    fmt.Printf(\"%d bits\\n\", sizeOfIntInBits)\n\n    var a int\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n\n    b := 2\n    fmt.Printf(\"b's typs is %s\\n\", reflect.TypeOf(b))\n}\n```", "```\n64 bits\n8 bytes\na's type is int\nb's typs is int\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a int 8\n    var a int8 = 2\n\n    //Size of int8 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n1 bytes\na's type is int8\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a int16\n    var a int16 = 2\n\n    //Size of int8 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n2 bytes\na's type is int16\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a int32\n    var a int32 = 2\n\n    //Size of int32 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n4 bytes\na's type is int32\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a int64\n    var a int64 = 2\n\n    //Size of int64 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n8 bytes\na's type is int64\n```", "```\n var a uint\n```", "```\n//This is computed as const uintSize = 32 << (^uint(0) >> 32 & 1) // 32 or 64\nsizeOfUintInBits := bits.UintSize\nfmt.Println(sizeOfIntInBits) => 32 or 64\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"math/bits\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //This is computed as const uintSize = 32 << (^uuint(0) >> 32 & 1) // 32 or 64\n    sizeOfuintInBits := bits.UintSize\n    fmt.Printf(\"%d bits\\n\", sizeOfuintInBits)\n\n    var a uint\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n64 bits\n8 bytes\na's type is uint\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\ntype sample struct {\n    a int\n    b string\n}\nfunc main() {\n    s := &sample{a: 1, b: \"test\"}\n\n   //Getting the address of field b in struct s\n    p := unsafe.Pointer(uintptr(unsafe.Pointer(s)) + unsafe.Offsetof(s.b))\n\n    //Typecasting it to a string pointer and printing the value of it\n    fmt.Println(*(*string)(p))\n}\n```", "```\ntest\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a uint8\n\n    var a uint8 = 2\n\n    //Size of uint8 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n1 bytes\na's type is uint8\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    //Declare a uint16\n    var a uint16 = 2\n\n    //Size of uint16 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n2 bytes\na's type is uint16\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a uint32\n    var a uint32 = 2\n\n    //Size of uint32 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n1 bytes\na's type is uint32\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a uint64\n    var a uint64 = 2\n\n//Size of uint64 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n8 bytes\na's type is uint64\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a float32\n    var a float32 = 2\n\n    //Size of float32 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n4 bytes\na's type is float32\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a float64\n    var a float64 = 2\n\n    //Size of float64 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n\n    //Default is float64 when you don't specify a type\n    b := 2.3\n    fmt.Printf(\"b's type is %s\\n\", reflect.TypeOf(b))\n}\n```", "```\n8 bytes\na's type is float64\nb's type is float64\n```", "```\ncomplext(a, b)\n```", "```\na := 5 + 6i\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    var a float32 = 3\n    var b float32 = 5\n\n    //Initialize-1\n    c := complex(a, b)\n\n    //Initialize-2\n    var d complex64\n    d = 4 + 5i\n\n    //Print Size\n    fmt.Printf(\"c's size is %d bytes\\n\", unsafe.Sizeof(c))\n    fmt.Printf(\"d's size is %d bytes\\n\", unsafe.Sizeof(d))\n\n    //Print type\n    fmt.Printf(\"c's type is %s\\n\", reflect.TypeOf(c))\n    fmt.Printf(\"d's type is %s\\n\", reflect.TypeOf(d))\n\n    //Operations on complex number\n    fmt.Println(c+d, c-d, c*d, c/d)\n}\n```", "```\nc's size is 8 bytes\nd's size is 8 bytes\nc's type is complex64\nd's type is complex64\n(7+10i) (-1+0i) (-13+35i) (0.902439+0.12195122i)\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    var a float64 = 3\n    var b float64 = 5\n\n    //Initialize-1\n    c := complex(a, b)\n\n    //Initialize-2\\. When don't specify a type , the default type will be complex128\n    d := 4 + 5i\n\n    //Print Size\n    fmt.Printf(\"c's size is %d bytes\\n\", unsafe.Sizeof(c))\n    fmt.Printf(\"d's size is %d bytes\\n\", unsafe.Sizeof(d))\n\n    //Print type\n    fmt.Printf(\"c's type is %s\\n\", reflect.TypeOf(c))\n    fmt.Printf(\"d's type is %s\\n\", reflect.TypeOf(d))\n\n    //Operations on complex number\n    fmt.Println(c+d, c-d, c*d, c/d)\n}\n```", "```\nc's size is 16 bytes\nd's size is 16 bytes\nc's type is complex128\nd's type is complex128\n(7+10i) (-1+0i) (-13+35i) (0.902439024390244+0.12195121951219513i)\n```", "```\nvar rbyte byte := 'a'\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    var r byte = 'a'\n\n    //Print Size\n    fmt.Printf(\"Size: %d\\n\", unsafe.Sizeof(r))\n\n    //Print Type\n    fmt.Printf(\"Type: %s\\n\", reflect.TypeOf(r))\n\n    //Print Character\n    fmt.Printf(\"Character: %c\\n\", r)\n    s := \"abc\"\n\n    //This will the decimal value of byte\n    fmt.Println([]byte(s))\n}\n```", "```\nSize: 1\nType: uint8\nCharacter: a\n[97 98 99]\n```", "```\nfmt.Printf(\"%U\\n\", []rune(\"0b£\"))\n```", "```\nrPound := '£'\n```", "```\nfmt.Printf(\"Type: %s\\n\", reflect.TypeOf(rPound))\n```", "```\nfmt.Printf(\"Unicode CodePoint: %U\\n\", rPound)\n```", "```\nfmt.Printf(\"Character: %c\\n\", r)\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    r := 'a'\n\n    //Print Size\n    fmt.Printf(\"Size: %d\\n\", unsafe.Sizeof(r))\n\n    //Print Type\n    fmt.Printf(\"Type: %s\\n\", reflect.TypeOf(r))\n\n    //Print Code Point\n    fmt.Printf(\"Unicode CodePoint: %U\\n\", r)\n\n    //Print Character\n    fmt.Printf(\"Character: %c\\n\", r)\n    s := \"0b£\"\n\n    //This will print the Unicode Points\n    fmt.Printf(\"%U\\n\", []rune(s))\n\n    //This will the decimal value of Unicode Code Point\n    fmt.Println([]rune(s))\n}\n```", "```\nSize: 4\nType: int32\nUnicode CodePoint: U+0061\nCharacter: a\n[U+0030 U+0062 U+00A3]\n[48 98 163]\n```", "```\ns := \"ab£\"\nfmt.Println([]byte(s))\n```", "```\n[48 98 194 163]\n```", "```\nfor _, c := range s {\n   fmt.Println(string(c))\n}\n```", "```\na\nb\n£\n```", "```\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    //String in double quotes\n    x := \"this\\nthat\"\n    fmt.Printf(\"x is: %s\\n\", x)\n\n    //String in back quotes\n    y := `this\\nthat`\n    fmt.Printf(\"y is: %s\\n\", y)\n    s := \"ab£\"\n\n    //This will print the byte sequence. \n    //Since character a and b occupies 1 byte each and £ character occupies 2 bytes. \n    //The final output will 4 bytes\n    fmt.Println([]byte(s))\n\n    //The output will be 4 for same reason as above\n    fmt.Println(len(s))\n\n    //range loops over sequences of byte which form each character\n    for _, c := range s {\n        fmt.Println(string(c))\n    }\n\n    //Concatenation\n    fmt.Println(\"c\" + \"d\")\n}\n```", "```\nx is: this\nthat\ny is: this\\nthat\n[97 98 194 163]\n4\na\nb\n£\ncd\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Default value will be false it not initialized\n    var a bool\n    fmt.Printf(\"a's value is %t\\n\", a)\n\n    //And operation on one true and other false\n    andOperation := 1 < 2 && 1 > 3\n    fmt.Printf(\"Ouput of AND operation on one true and other false %t\\n\", andOperation)\n\n    //OR operation on one true and other false\n    orOperation := 1 < 2 || 1 > 3\n    fmt.Printf(\"Ouput of OR operation on one true and other false: %t\\n\", orOperation)\n\n    //Negation Operation on a false value\n    negationOperation := !(1 > 2)\n    fmt.Printf(\"Ouput of NEGATION operation on false value: %t\\n\", negationOperation)\n}\n```", "```\na's value is false\nOuput of AND operation on one true and other false false\nOuput of OR operation on one true and other false: true\nOuput of NEGATION operation on false value: true\n```", "```\nnewArray := [n]Type{val1, val2, val3}\n```", "```\nnewArray := [len]Type{}\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Declare a array\n    sample := [3]string{\"a\", \"b\", \"c\"}\n    print(sample)\n}\n\nfunc print(sample [3]string) {\n    fmt.Println(sample)\n}\n```", "```\n[a b c]\n```", "```\ntype employee struct {\n    name string\n    age  int\n    dob  time.Time\n}\n```", "```\npackage main\nimport (\n    \"fmt\"\n)\n//Declare a struct\ntype employee struct {\n    name   string\n    age    int\n    salary float64\n}\nfunc main() {\n    //Initialize a struct without named fields\n    employee1 := employee{\"John\", 21, 1000}\n    fmt.Println(employee1)\n\n    //Initialize a struct with named fields\n    employee2 := employee{\n        name:   \"Sam\",\n        age:    22,\n        salary: 1100,\n    }\n    fmt.Println(employee2)\n\n    //Initializing only some fields. Other values are initialized to default zero value of that type\n    employee3 := employee{name: \"Tina\", age: 24}\n    fmt.Println(employee3)\n}\n```", "```\n{John 21 1000}\n{Sam 22 1100}\n{Tina 24 0}\n```", "```\nmake([]TYPE, length, capacity)\n```", "```\np := []string{\"a\", \"b\", \"c\"}\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Declare a slice using make\n    s := make([]string, 2, 3)\n    fmt.Println(s)\n\n    //Direct intialization\n    p := []string{\"a\", \"b\", \"c\"}\n    fmt.Println(p)\n\n    //Append function\n    p = append(p, \"d\")\n    fmt.Println(p)\n\n    //Iterate over a slcie\n    for _, val := range p {\n        fmt.Println(val)\n    }\n}\n```", "```\n[ ]\n[a b c]\n[a b c d]\na\nb\nc\nd\n```", "```\nch <- val    //Sending a value present in var variable to channel\nval := <-cha  //Receive a value from  the channel and assign it to val variable\n```", "```\nevents := make(chan string)  //Unbuffered channel\nevents2 := make(chan string, 2)  //Buffered channel of length 2\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Creating a buffered channel of length 3\n    eventsChan := make(chan string, 3)\n    eventsChan <- \"a\"\n    eventsChan <- \"b\"\n    eventsChan <- \"c\"\n    //Closing the channel\n    close(eventsChan)\n    for event := range eventsChan {\n        fmt.Println(event)\n    }\n}\n```", "```\na\nb\nc\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    eventsChan := make(chan string)\n    go sendEvents(eventsChan)\n    for event := range eventsChan {\n        fmt.Println(event)\n    }\n}\n\nfunc sendEvents(eventsChan chan<- string) {\n    eventsChan <- \"a\"\n    eventsChan <- \"b\"\n    eventsChan <- \"c\"\n    close(eventsChan)\n}\n```", "```\na\nb\nc\n```", "```\nvar employeeSalary map[string]int\n```", "```\nvar employeeSalary make(map[string]int)\n```", "```\n//Empty braces\nemployeeSalary := map[string]int{}\n\n//Specify values\nemployeeSalary := map[string]int{\n\"John\": 1000\n\"Sam\": 2000\n} \n```", "```\nemployeeSalary[\"John\"] = 1000\n```", "```\nsalary := employeeSalary[\"John\"]\n```", "```\ndelete(employeeSalary, \"John\")\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Declare\n    var employeeSalary map[string]int\n    fmt.Println(employeeSalary)\n\n    //Intialize using make\n    employeeSalary2 := make(map[string]int)\n    fmt.Println(employeeSalary2)\n\n    //Intialize using map lieteral\n    employeeSalary3 := map[string]int{\n        \"John\": 1000,\n        \"Sam\":  1200,\n    }\n    fmt.Println(employeeSalary3)\n\n    //Operations\n    //Add\n    employeeSalary3[\"Carl\"] = 1500\n\n    //Get\n    fmt.Printf(\"John salary is %d\\n\", employeeSalary3[\"John\"])\n\n    //Delete\n    delete(employeeSalary3, \"Carl\")\n\n    //Print map\n    fmt.Println(\"\\nPrinting employeeSalary3 map\")\n    fmt.Println(employeeSalary3)\n}\n```", "```\nmap[]\nmap[]\nmap[John:1000 Sam:1200]\nJohn salary is 1000\n\nPrinting employeeSalary3 map\nmap[John:1000 Sam:1200]\n```", "```\nvar ex *int\n```", "```\na := 2\nb := &b\n```", "```\nfmt.Println(*b) //Print the value stored at address b \n```", "```\na := new(int)\n*a = 10\nfmt.Println(*a) //Output will be 10\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Declare\n    var b *int\n    a := 2\n    b = &a\n\n    //Will print a address. Output will be different everytime.\n    fmt.Println(b)\n    fmt.Println(*b)\n    b = new(int)\n    *b = 10\n    fmt.Println(*b) \n}\n```", "```\n0xc000018080\n2\n10\n```", "```\nfunc some_func_name(arguments) return_values\n```", "```\nfunc (receiver receiver_type) some_func_name(arguments) return_values\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    add := func(x, y int) int {\n        return x + y\n    }\n    fmt.Println(add(1, 2))\n}\n\nfunc doOperation(fn func(int, int) int, x, y int) int {\n    return fn(x, y)\n}\n```", "```\n3\n```", "```\ntype name_of_interface interface{\n//Method signature 1\n//Method signature 2\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype shape interface {\n    area() int\n}\n\ntype square struct {\n    side int\n}\n\nfunc (s *square) area() int {\n    return s.side * s.side\n}\n\nfunc main() {\n    var s shape\n    s = &square{side: 4}\n    fmt.Println(s.area())\n}\n```", "```\n16\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    test(\"thisisstring\")\n    test(\"10\")\n    test(true)\n}\n\nfunc test(a interface{}) {\n    fmt.Printf(\"(%v, %T)\\n\", a, a)\n}\n```", "```\n(thisisstring, string)\n(10, string)\n(true, bool)\n```"]