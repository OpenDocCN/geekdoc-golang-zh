# 01. 从文件到数据库

让我们从文件开始，检查我们面临的挑战。

## 1.1 就地更新文件

假设你需要将一些数据保存到磁盘上；这是典型的做法：

```go
func SaveData1(path string, data []byte) error {
    fp, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0664)
    if err != nil {
        return err
    }
    defer fp.Close()

    _, err = fp.Write(data)
    if err != nil {
        return err
    }
    return fp.Sync() // fsync
}
```

这段代码如果文件不存在则创建文件，或者在写入内容之前截断现有文件。最重要的是，除非你调用`fsync`（在 Go 中为`fp.Sync()`），否则数据不是持久的。

它有一些严重的限制：

1.  它作为整体更新内容；仅适用于小型数据。这就是为什么你不使用 Excel 作为数据库。

1.  如果你需要更新旧文件，你必须读取并修改它内存中的内容，然后覆盖旧文件。如果在覆盖旧文件时应用程序崩溃怎么办？

1.  如果应用程序需要并发访问数据，你如何防止读者获得混合数据，以及写者发生冲突操作？这就是为什么大多数数据库都是客户端-服务器架构，你需要一个服务器来协调并发客户端。（没有服务器，并发会更复杂，参见 SQLite）。

## 1.2 原子性重命名

### 通过重命名文件原子性地替换数据

通过不就地更新数据解决了许多问题。你可以写一个新的文件并删除旧文件。

不接触旧文件数据意味着：

1.  如果更新被中断，你可以从旧文件中恢复，因为它保持完好无损。

1.  并发读者不会获得半写数据。

问题在于读者将如何找到新文件。一个常见的模式是将新文件重命名为旧文件路径。

```go
func SaveData2(path string, data []byte) error {
    tmp := fmt.Sprintf("%s.tmp.%d", path, randomInt())
    fp, err := os.OpenFile(tmp, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0664)
    if err != nil {
        return err
    }
    defer func() {
        fp.Close()
        if err != nil {
            os.Remove(tmp)
        }
    }()

    _, err = fp.Write(data)
    if err != nil {
        return err
    }
    err = fp.Sync() // fsync
    if err != nil {
        return err
    }

    return os.Rename(tmp, path)
}
```

将文件重命名为现有文件是*原子性*的替换；删除旧文件是不必要的（也是不正确的）。

注意术语的含义，无论何时看到“X 是原子的”，你应该问“X 相对于什么是原子的？”在这种情况下：

+   重命名相对于并发读者是原子的；读者打开的是旧文件或新文件。

+   重命名在断电方面不是原子的；它甚至不是持久的。你需要对父*目录*进行额外的`fsync`，这将在后面讨论。

### 为什么重命名会起作用？

文件系统维护从文件名到文件数据的映射，因此通过重命名替换文件只是将文件名指向新数据而不接触旧数据。这就是为什么在文件系统中原子性重命名是可能的。并且操作成本是常数，无论数据大小如何。

在 Linux 上，如果旧文件仍然被读者打开，那么替换后的旧文件可能仍然存在；只是无法通过文件名访问。读者可以安全地处理他们获取的数据的任何版本，而写者则不会被读者阻塞。然而，必须有一种方法来防止并发写者。并发级别是多读单写，这是我们将会实现的。

## 1.3 只追加日志

### 使用日志进行安全的增量更新

增量更新的一个方法是将更新追加到文件中。这被称为“日志”，因为它只允许追加。这比就地更新更安全，因为没有数据被覆盖；在崩溃后，你总是可以恢复旧数据。

读者在使用日志时必须考虑所有日志条目。例如，这里有一个基于日志的 KV，有 4 个条目：

```go
 0         1         2        3
| set a=1 | set b=2 | set a=3 | del b |
```

最终状态是`a=3`。

日志是许多数据库的一个基本组件。然而，日志只是每个更新的描述，这意味着：

+   它不是一个索引数据结构；读者必须阅读所有条目。

+   它没有从已删除数据中回收空间的方法。

因此，仅日志本身不足以构建数据库，它们必须与其他索引数据结构结合。

### 带校验和的原子日志更新

虽然日志不会损坏旧数据，但如果在崩溃后最后一条条目被损坏，你仍然需要处理。许多可能性：

1.  最后的追加根本就没有发生；日志仍然是好的。

1.  最后一条条目只写了一半。

1.  日志的大小增加了，但最后一条条目不在那里。

处理这些情况的方法是为每个日志条目添加校验和。如果校验和错误，则更新没有发生，使得日志更新原子化（相对于读者和持久性）。

这个场景是关于在成功的`fsync`之前发生的未完成写入（数据库术语中的*torn writes*）。校验和也可以检测`fsync`之后的其他形式的损坏，但这不是数据库可以恢复的情况。

## 1.4 `fsync`的注意事项

在重命名文件或创建新文件后，你必须对父目录调用`fsync`。目录是从文件名到文件的映射，就像文件数据一样，除非你使用`fsync`，否则它不是持久的。参见[这个`fsync`示例](https://www.usenix.org/sites/default/files/conference/protected-files/osdi14_slides_pillai.pdf#page=31)。

`fsync`的另一个问题是错误处理。如果`fsync`失败，数据库更新也会失败，但之后你读取文件会怎样？即使`fsync`失败（因为操作系统页面缓存），你也可能得到新数据！这种行为[取决于文件系统](https://www.usenix.org/conference/atc20/presentation/rebello)。

## 1.5 数据库挑战的总结

我们学到的东西：

1.  原地更新的问题。

    +   通过重命名文件来避免原地更新。

    +   使用日志避免原地更新。

1.  只追加日志。

    +   增量更新。

    +   不是一个完整的解决方案；没有索引和空间重用。

1.  `fsync`的使用。

剩下的一个问题：

1.  索引数据结构及其更新方法。

1.  从只追加文件中重用空间。

1.  将日志与索引数据结构结合。

1.  并发。
