- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:00:55'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract Class in GO: Complete Guide'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/go-abstract-class/](https://golangbyexample.com/go-abstract-class/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Go Interface doesn’t have fields and also it doesn’t allow the definition of
    methods inside it. Any type needs to implements all methods of interface to become
    of that interface type. There are use cases where it is useful to have a default
    implementation of a method and also default fields in GO. Before understanding
    how to do it lets first understand the requirements of an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract class should have default fields
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstract class should have the default method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should not be possible to create a direct instance of the abstract class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use a combination of a **interface (abstract interface)** and **struct
    (abstract concrete type).** Together they can provide the functionalities of an
    abstract class. See the below program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In above program:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an abstract interface **iAlpha**, an abstract concrete struct **alpha,**
    and an implementor struct **beta**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**alpha** struct is embedded in **beta** struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beta struct is able to access default field **“name”**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beta struct is able to access the default method **“common”**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not able to create a direct instance of **iAlpha ** as **alpha** struct
    only implement only one of the method of **iAlpha.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So it fulfills all three requirements but there is also one limitation of the
    above method. It is not possible to call the “**work**” method from **“common”**
    method of alpha. Basically there is no way to call an undefined method of the
    abstract interface from default methods of an abstract concrete type. There is
    one way to fix it, though. See below program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above program:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a new field **“work”** of type func in alpha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We assigned alpha’s **“work”** method to beta **“work”** method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only problem with the above program is that it is possible to create a direct
    instantiation of **alpha** struct and by providing the definition of **work**
    method, an instance of type **iAlpha** is created. This violates point 3 of the
    above Abstract class requirement as without creating our own new type we are able
    to create a type of **iAlpha.** Let’s try to fix this problem. The below program
    additionally also solves the problem where it was not possible to call the undefined
    methods from default methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above program:'
  prefs: []
  type: TYPE_NORMAL
- en: All the default methods will accept the first argument of interface type **iAlpha.**
    All the undefined methods of **alpha** struct will be called using this argument
    from default methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conclusion:** We can see in the above program that we are able to fulfill
    all three requirements of an abstract class. This is one of the ways to simulate
    abstract class in GO.'
  prefs: []
  type: TYPE_NORMAL
- en: '[abstract](https://golangbyexample.com/tag/abstract/)*   [abstract class](https://golangbyexample.com/tag/abstract-class/)*   [class](https://golangbyexample.com/tag/class/)*   [complete](https://golangbyexample.com/tag/complete/)*   [go](https://golangbyexample.com/tag/go/)*   [guide](https://golangbyexample.com/tag/guide/)*   [oop](https://golangbyexample.com/tag/oop/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
