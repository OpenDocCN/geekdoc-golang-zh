["```go\nexport GODEBUG=netdns=go \n```", "```go\nexport GODEBUG=netdns=cgo \n```", "```go\n$ ldd ./app-cgo\n    linux-vdso.so.1 (0x0000fa34ddbad000)\n    libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000fa34dd9b0000)\n    /lib/ld-linux-aarch64.so.1 (0x0000fa34ddb70000) \n```", "```go\n$ ldd ./app-pure\n    not a dynamic executable \n```", "```go\nimport (\n    \"github.com/patrickmn/go-cache\"\n    \"net\"\n    \"time\"\n)\n\nvar dnsCache = cache.New(5*time.Minute, 10*time.Minute)\n\nfunc LookupWithCache(host string) ([]net.IP, error) {\n    if cachedIPs, found := dnsCache.Get(host); found {\n        return cachedIPs.([]net.IP), nil\n    }\n\n    ips, err := net.LookupIP(host)\n    if err != nil {\n        return nil, err\n    }\n    dnsCache.Set(host, ips, cache.DefaultExpiration)\n    return ips, nil\n} \n```", "```go\nvar serviceAddr string\n\nfunc init() {\n    ips, err := net.LookupIP(\"api.example.com\")\n    if err != nil || len(ips) == 0 {\n        panic(\"Unable to resolve api.example.com\")\n    }\n    serviceAddr = ips[0].String() // in real code, consider picking an IP randomly, prefer IPv4 if needed, or iterate over ips with checks as appropriate\n} \n```", "```go\nimport (\n    \"net\"\n    \"context\"\n    \"time\"\n)\n\nvar dialer = &net.Dialer{\n    Timeout:   5 * time.Second,\n    KeepAlive: 30 * time.Second,\n    Resolver: &net.Resolver{\n        PreferGo: true,\n        Dial: func(ctx context.Context, network, address string) (net.Conn, error) {\n            return net.Dial(network, \"8.8.8.8:53\")\n        },\n    },\n}\n\nfunc ConnectWithCustomDialer(ctx context.Context, address string) (net.Conn, error) {\n    return dialer.DialContext(ctx, \"tcp\", address)\n} \n```", "```go\nstart := time.Now()\nips, err := net.LookupIP(\"example.com\")\nduration := time.Since(start)\n\nrecordDNSLookupDuration(\"example.com\", duration) \n```", "```go\nexport GODEBUG=netdns=2 \n```"]