["```\ntype Interface interface {\n    // Len is the number of elements in the collection.\n    Len() int\n\n    // Less reports whether the element with\n    // index i should sort before the element with index j.\n    Less(i, j int) bool\n\n    // Swap swaps the elements with indexes i and j.\n    Swap(i, j int)\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype employee struct {\n    name   string\n    salary int\n}\n\ntype employeeList []employee\n\nfunc (e employeeList) Len() int {\n    return len(e)\n}\n\nfunc (e employeeList) Less(i, j int) bool {\n    return e[i].salary > e[j].salary\n}\n\nfunc (e employeeList) Swap(i, j int) {\n    e[i], e[j] = e[j], e[i]\n}\n\nfunc main() {\n    eList := []employee{\n        employee{name: \"John\", salary: 3000},\n        employee{name: \"Bill\", salary: 4000},\n        employee{name: \"Sam\", salary: 1000},\n    }\n    sort.Sort(employeeList(eList))\n    for _, employee := range eList {\n        fmt.Printf(\"Name: %s Salary %d\\n\", employee.name, employee.salary)\n    }\n}\n```", "```\nName: Bill Salary 4000\nName: John Salary 3000\nName: Sam Salary 1000\n```", "```\nfunc (e employeeList) Less(i, j int) bool {\n    return e[i].salary > e[j].salary\n}\n```", "```\nName: Sam Salary 1000\nName: John Salary 3000\nName: Bill Salary 4000\n```"]