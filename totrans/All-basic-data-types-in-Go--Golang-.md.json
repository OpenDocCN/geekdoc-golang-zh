["```\nvar a int\n```", "```\nb := 2 //The default is also intfmt.Println(reflect.TypeOf(b)) => int\n```", "```\n//This is computed as const uintSize = 32 << (^uint(0) >> 32 & 1) // 32 or 64sizeOfIntInBits := bits.UintSizefmt.Println(sizeOfIntInBits) => 32 0r 34\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"math/bits\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //This is computed as const uintSize = 32 << (^uint(0) >> 32 & 1) // 32 or 64\n    sizeOfIntInBits := bits.UintSize\n    fmt.Printf(\"%d bits\\n\", sizeOfIntInBits)\n\n    var a int\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n\n    b := 2\n    fmt.Printf(\"b's typs is %s\\n\", reflect.TypeOf(b))\n}\n```", "```\n64 bits\n8 bytes\na's type is int\nb's typs is int\n```", "```\nvar a uint\n```", "```\n//This is computed as const uintSize = 32 << (^uint(0) >> 32 & 1) // 32 or 64sizeOfUintInBits := bits.UintSizefmt.Println(sizeOfIntInBits) => 32 or 64\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"math/bits\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //This is computed as const uintSize = 32 << (^uuint(0) >> 32 & 1) // 32 or 64\n    sizeOfuintInBits := bits.UintSize\n    fmt.Printf(\"%d bits\\n\", sizeOfuintInBits)\n\n    var a uint\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n64 bits\n8 bytes\na's type is uint\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype sample struct {\n    a int\n    b string\n}\n\nfunc main() {\n    s := &sample{a: 1, b: \"test\"}\n\n   //Getting the address of field b in struct s\n    p := unsafe.Pointer(uintptr(unsafe.Pointer(s)) + unsafe.Offsetof(s.b))\n\n    //Typecasting it to a string pointer and printing the value of it\n    fmt.Println(*(*string)(p))\n}\n```", "```\ntest\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a float32\n    var a float32 = 2\n\n    //Size of float32 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n}\n```", "```\n4 bytes\na's type is float32\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    //Declare a float64\n    var a float64 = 2\n\n    //Size of float64 in bytes\n    fmt.Printf(\"%d bytes\\n\", unsafe.Sizeof(a))\n    fmt.Printf(\"a's type is %s\\n\", reflect.TypeOf(a))\n\n    //Default is float64 when you don't specify a type\n    b := 2.3\n    fmt.Printf(\"b's type is %s\\n\", reflect.TypeOf(b))\n}\n```", "```\n8 bytes\na's type is float64\nb's type is float64\n```", "```\ncomplext(a, b)\n```", "```\na := 5 + 6i\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    var a float32 = 3\n    var b float32 = 5\n\n    //Initialize-1\n    c := complex(a, b)\n\n    //Initialize-2\n    var d complex64\n    d = 4 + 5i\n\n    //Print Size\n    fmt.Printf(\"c's size is %d bytes\\n\", unsafe.Sizeof(c))\n    fmt.Printf(\"d's size is %d bytes\\n\", unsafe.Sizeof(d))\n\n    //Print type\n    fmt.Printf(\"c's type is %s\\n\", reflect.TypeOf(c))\n    fmt.Printf(\"d's type is %s\\n\", reflect.TypeOf(d))\n\n    //Operations on complex number\n    fmt.Println(c+d, c-d, c*d, c/d)\n}\n```", "```\nc's size is 8 bytes\nd's size is 8 bytes\nc's type is complex64\nd's type is complex64\n(7+10i) (-1+0i) (-13+35i) (0.902439+0.12195122i)\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    var a float64 = 3\n    var b float64 = 5\n\n    //Initialize-1\n    c := complex(a, b)\n\n    //Initialize-2\\. When don't specify a type , the default type will be complex128\n    d := 4 + 5i\n\n    //Print Size\n    fmt.Printf(\"c's size is %d bytes\\n\", unsafe.Sizeof(c))\n    fmt.Printf(\"d's size is %d bytes\\n\", unsafe.Sizeof(d))\n\n    //Print type\n    fmt.Printf(\"c's type is %s\\n\", reflect.TypeOf(c))\n    fmt.Printf(\"d's type is %s\\n\", reflect.TypeOf(d))\n\n    //Operations on complex number\n    fmt.Println(c+d, c-d, c*d, c/d)\n}\n```", "```\nc's size is 16 bytes\nd's size is 16 bytes\nc's type is complex128\nd's type is complex128\n(7+10i) (-1+0i) (-13+35i) (0.902439024390244+0.12195121951219513i)\n```", "```\nvar rbyte byte := 'a'\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    var r byte = 'a'\n\n    //Print Size\n    fmt.Printf(\"Size: %d\\n\", unsafe.Sizeof(r))\n\n    //Print Type\n    fmt.Printf(\"Type: %s\\n\", reflect.TypeOf(r))\n\n    //Print Character\n    fmt.Printf(\"Character: %c\\n\", r)\n    s := \"abc\"\n\n    //This will the decimal value of byte\n    fmt.Println([]byte(s))\n}\n```", "```\nSize: 1\nType: uint8\nCharacter: a\n[97 98 99]\n```", "```\nfmt.Printf(\"%U\\n\", []rune(\"0b£\"))\n```", "```\nrPound := '£'\n```", "```\nfmt.Printf(\"Type: %s\\n\", reflect.TypeOf(rPound))\n```", "```\nfmt.Printf(\"Unicode CodePoint: %U\\n\", rPound)\n```", "```\nfmt.Printf(\"Character: %c\\n\", r)\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\nfunc main() {\n    r := 'a'\n\n    //Print Size\n    fmt.Printf(\"Size: %d\\n\", unsafe.Sizeof(r))\n\n    //Print Type\n    fmt.Printf(\"Type: %s\\n\", reflect.TypeOf(r))\n\n    //Print Code Point\n    fmt.Printf(\"Unicode CodePoint: %U\\n\", r)\n\n    //Print Character\n    fmt.Printf(\"Character: %c\\n\", r)\n    s := \"0b£\"\n\n    //This will print the Unicode Points\n    fmt.Printf(\"%U\\n\", []rune(s))\n\n    //This will the decimal value of Unicode Code Point\n    fmt.Println([]rune(s))\n}\n```", "```\nSize: 4\nType: int32\nUnicode CodePoint: U+0061\nCharacter: a\n[U+0030 U+0062 U+00A3]\n[48 98 163]\n```", "```\ns := \"ab£\"\nfmt.Println([]byte(s))\n```", "```\n[48 98 194 163]\n```", "```\nfor _, c := range s {\n   fmt.Println(string(c))\n}\n```", "```\na\nb\n£\n```", "```\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    //String in double quotes\n    x := \"this\\nthat\"\n    fmt.Printf(\"x is: %s\\n\", x)\n\n    //String in back quotes\n    y := `this\\nthat`\n    fmt.Printf(\"y is: %s\\n\", y)\n    s := \"ab£\"\n\n    //This will print the byte sequence. \n    //Since character a and b occupies 1 byte each and £ character occupies 2 bytes. \n    //The final output will 4 bytes\n    fmt.Println([]byte(s))\n\n    //The output will be 4 for same reason as above\n    fmt.Println(len(s))\n\n    //range loops over sequences of byte which form each character\n    for _, c := range s {\n        fmt.Println(string(c))\n    }\n\n    //Concatenation\n    fmt.Println(\"c\" + \"d\")\n}\n```", "```\nx is: this\nthat\ny is: this\\nthat\n[97 98 194 163]\n4\na\nb\n£\ncd\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    //Default value will be false it not initialized\n    var a bool\n    fmt.Printf(\"a's value is %t\\n\", a)\n\n    //And operation on one true and other false\n    andOperation := 1 < 2 && 1 > 3\n    fmt.Printf(\"Ouput of AND operation on one true and other false %t\\n\", andOperation)\n\n    //OR operation on one true and other false\n    orOperation := 1 < 2 || 1 > 3\n    fmt.Printf(\"Ouput of OR operation on one true and other false: %t\\n\", orOperation)\n\n    //Negation Operation on a false value\n    negationOperation := !(1 > 2)\n    fmt.Printf(\"Ouput of NEGATION operation on false value: %t\\n\", negationOperation)\n}\n```", "```\na's value is false\nOuput of AND operation on one true and other false false\nOuput of OR operation on one true and other false: true\nOuput of NEGATION operation on false value: true\n```"]