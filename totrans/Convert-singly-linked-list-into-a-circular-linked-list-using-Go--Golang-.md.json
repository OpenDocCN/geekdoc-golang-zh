["```\n\"A\" -> \"B\" -> \"C\" -> \"D\"\n```", "```\n\"A\" -> \"B\" -> \"C\" -> \"D\"\n ^                               |\n|____________________|\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype node struct {\n\tdata string\n\tnext *node\n}\n\ntype singlyLinkedList struct {\n\tlen  int\n\thead *node\n}\n\nfunc initList() *singlyLinkedList {\n\treturn &singlyLinkedList{}\n}\n\nfunc (s *singlyLinkedList) AddFront(data string) {\n\tnode := &node{\n\t\tdata: data,\n\t}\n\n\tif s.head == nil {\n\t\ts.head = node\n\t} else {\n\t\tnode.next = s.head\n\t\ts.head = node\n\t}\n\ts.len++\n\treturn\n}\n\nfunc (s *singlyLinkedList) Traverse() error {\n\tif s.head == nil {\n\t\treturn fmt.Errorf(\"TraverseError: List is empty\")\n\t}\n\tcurrent := s.head\n\tfor current != nil {\n\t\tfmt.Println(current.data)\n\t\tcurrent = current.next\n\t}\n\treturn nil\n}\n\n//Function to convert singly linked list to circular linked list\nfunc (s *singlyLinkedList) ToCircular() {\n\tcurrent := s.head\n\tfor current.next != nil {\n\t\tcurrent = current.next\n\t}\n\tcurrent.next = s.head\n}\n\nfunc (s *singlyLinkedList) IsCircular() bool {\n\tif s.head == nil {\n\t\treturn true\n\t}\n\tcurrent := s.head.next\n\tfor current.next != nil && current != s.head {\n\t\tcurrent = current.next\n\t}\n\treturn current == s.head\n}\n\nfunc main() {\n\tsingleList := initList()\n\tfmt.Printf(\"AddFront: D\\n\")\n\tsingleList.AddFront(\"D\")\n\tfmt.Printf(\"AddFront: C\\n\")\n\tsingleList.AddFront(\"C\")\n\tfmt.Printf(\"AddFront: B\\n\")\n\tsingleList.AddFront(\"B\")\n\tfmt.Printf(\"AddFront: A\\n\")\n\tsingleList.AddFront(\"A\")\n\n\terr := singleList.Traverse()\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n\n\tfmt.Printf(\"Size: %d\\n\", singleList.len)\n\tsingleList.ToCircular()\n\n\tisCircular := singleList.IsCircular()\n\tfmt.Printf(\"Is Circular: %t\\n\", isCircular)\n}\n```", "```\nAddFront: D\nAddFront: C\nAddFront: B\nAddFront: A\nA\nB\nC\nD\nSize: 4\nIs Circular: true\n```"]