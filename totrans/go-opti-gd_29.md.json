["```go\nsequenceDiagram\n    participant App as Application\n    participant TCP as TCP Stack\n    participant Net as Network\n\n    App->>TCP: Send 1 byte\n    note right of TCP: Buffering (no ACK received)\n    App->>TCP: Send 1 byte\n    note right of TCP: Still buffering...\n\n    TCP-->>Net: Send 2 bytes (batched)\n    Net-->>TCP: ACK received\n\n    App->>TCP: Send 1 byte\n    TCP-->>Net: Immediately send (ACK received, buffer clear)\n```", "```go\n`func  SetTCPNoDelay(conn  *net.TCPConn)  error  {   return  conn.SetNoDelay(true) }` \n```", "```go\n`listenerConfig  :=  &net.ListenConfig{   Control:  func(network,  address  string,  c  syscall.RawConn)  error  {   return  c.Control(func(fd  uintptr)  {   syscall.SetsockoptInt(int(fd),  syscall.SOL_SOCKET,  syscall.SO_REUSEPORT,  1)   })   }, } listener,  err  :=  listenerConfig.Listen(context.Background(),  \"tcp\",  \":8080\")` \n```", "```go\n`func  SetSocketBuffers(conn  *net.TCPConn,  recvBuf,  sendBuf  int)  error  {   if  err  :=  conn.SetReadBuffer(recvBuf);  err  !=  nil  {   return  err   }   return  conn.SetWriteBuffer(sendBuf) }` \n```", "```go\n`func  SetKeepAlive(conn  *net.TCPConn,  idleTime  time.Duration)  error  {   if  err  :=  conn.SetKeepAlive(true);  err  !=  nil  {   return  err   }   return  conn.SetKeepAlivePeriod(idleTime) }` \n```", "```go\n`# System-level setting sysctl  -w  net.core.somaxconn=4096` \n```", "```go\n`listenerConfig  :=  net.ListenConfig{   Control:  func(network,  address  string,  c  syscall.RawConn)  error  {   return  c.Control(func(fd  uintptr)  {   // Custom syscall here; safely handled means it executes within the correct context,   // before the socket is handed over to the Go runtime, with proper error checking and synchronization   })   }, }` \n```"]