["```\npackage main\n\ntype iPoolObject interface {\n    getID() string //This is any id which can be used to compare two different pool objects\n}\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype pool struct {\n    idle   []iPoolObject\n    active []iPoolObject\n    capacity int\n    mulock   *sync.Mutex\n}\n\n//InitPool Initialize the pool\nfunc initPool(poolObjects []iPoolObject) (*pool, error) {\n    if len(poolObjects) == 0 {\n        return nil, fmt.Errorf(\"Cannot craete a pool of 0 length\")\n    }\n    active := make([]iPoolObject, 0)\n    pool := &pool{\n        idle:     poolObjects,\n        active:   active,\n        capacity: len(poolObjects),\n        mulock:   new(sync.Mutex),\n    }\n    return pool, nil\n}\n\nfunc (p *pool) loan() (iPoolObject, error) {\n    p.mulock.Lock()\n    defer p.mulock.Unlock()\n    if len(p.idle) == 0 {\n        return nil, fmt.Errorf(\"No pool object free. Please request after sometime\")\n    }\n    obj := p.idle[0]\n    p.idle = p.idle[1:]\n    p.active = append(p.active, obj)\n    fmt.Printf(\"Loan Pool Object with ID: %s\\n\", obj.getID())\n    return obj, nil\n}\n\nfunc (p *pool) receive(target iPoolObject) error {\n    p.mulock.Lock()\n    defer p.mulock.Unlock()\n    err := p.remove(target)\n    if err != nil {\n        return err\n    }\n    p.idle = append(p.idle, target)\n    fmt.Printf(\"Return Pool Object with ID: %s\\n\", target.getID())\n    return nil\n}\n\nfunc (p *pool) remove(target iPoolObject) error {\n    currentActiveLength := len(p.active)\n    for i, obj := range p.active {\n        if obj.getID() == target.getID() {\n            p.active[currentActiveLength-1], p.active[i] = p.active[i], p.active[currentActiveLength-1]\n            p.active = p.active[:currentActiveLength-1]\n            return nil\n        }\n    }\n    return fmt.Errorf(\"Targe pool object doesn't belong to the pool\")\n}\n```", "```\npackage main\n\ntype connection struct {\n    id string\n}\n\nfunc (c *connection) getID() string {\n    return c.id\n}\n```", "```\npackage main\n\nimport (\n    \"log\"\n    \"strconv\"\n)\n\nfunc main() {\n    connections := make([]iPoolObject, 0)\n    for i := 0; i < 3; i++ {\n        c := &connection{id: strconv.Itoa(i)}\n        connections = append(connections, c)\n    }\n    pool, err := initPool(connections)\n    if err != nil {\n        log.Fatalf(\"Init Pool Error: %s\", err)\n    }\n    conn1, err := pool.loan()\n    if err != nil {\n        log.Fatalf(\"Pool Loan Error: %s\", err)\n    }\n    conn2, err := pool.loan()\n    if err != nil {\n        log.Fatalf(\"Pool Loan Error: %s\", err)\n    }\n    pool.receive(conn1)\n    pool.receive(conn2)\n}\n```", "```\nLoan Pool Object with ID: 0\nLoan Pool Object with ID: 1\nReturn Pool Object with ID: 0\nReturn Pool Object with ID: 1\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"strconv\"\n    \"sync\"\n)\n\ntype iPoolObject interface {\n    getID() string //This is any id which can be used to compare two different pool objects\n}\n\ntype pool struct {\n    idle   []iPoolObject\n    active []iPoolObject\n    capacity int\n    mulock   *sync.Mutex\n}\n\n//InitPool Initialize the pool\nfunc initPool(poolObjects []iPoolObject) (*pool, error) {\n    if len(poolObjects) == 0 {\n        return nil, fmt.Errorf(\"Cannot craete a pool of 0 length\")\n    }\n    active := make([]iPoolObject, 0)\n    pool := &pool{\n        idle:     poolObjects,\n        active:   active,\n        capacity: len(poolObjects),\n        mulock:   new(sync.Mutex),\n    }\n    return pool, nil\n}\n\nfunc (p *pool) loan() (iPoolObject, error) {\n    p.mulock.Lock()\n    defer p.mulock.Unlock()\n    if len(p.idle) == 0 {\n        return nil, fmt.Errorf(\"No pool object free. Please request after sometime\")\n    }\n    obj := p.idle[0]\n    p.idle = p.idle[1:]\n    p.active = append(p.active, obj)\n    fmt.Printf(\"Loan Pool Object with ID: %s\\n\", obj.getID())\n    return obj, nil\n}\n\nfunc (p *pool) receive(target iPoolObject) error {\n    p.mulock.Lock()\n    defer p.mulock.Unlock()\n    err := p.remove(target)\n    if err != nil {\n        return err\n    }\n    p.idle = append(p.idle, target)\n    fmt.Printf(\"Return Pool Object with ID: %s\\n\", target.getID())\n    return nil\n}\n\nfunc (p *pool) remove(target iPoolObject) error {\n    currentActiveLength := len(p.active)\n    for i, obj := range p.active {\n        if obj.getID() == target.getID() {\n            p.active[currentActiveLength-1], p.active[i] = p.active[i], p.active[currentActiveLength-1]\n            p.active = p.active[:currentActiveLength-1]\n            return nil\n        }\n    }\n    return fmt.Errorf(\"Targe pool object doesn't belong to the pool\")\n}\n\ntype connection struct {\n    id string\n}\n\nfunc (c *connection) getID() string {\n    return c.id\n}\n\nfunc main() {\n    connections := make([]iPoolObject, 0)\n    for i := 0; i < 3; i++ {\n        c := &connection{id: strconv.Itoa(i)}\n        connections = append(connections, c)\n    }\n    pool, err := initPool(connections)\n    if err != nil {\n        log.Fatalf(\"Init Pool Error: %s\", err)\n    }\n    conn1, err := pool.loan()\n    if err != nil {\n        log.Fatalf(\"Pool Loan Error: %s\", err)\n    }\n    conn2, err := pool.loan()\n    if err != nil {\n        log.Fatalf(\"Pool Loan Error: %s\", err)\n    }\n    pool.receive(conn1)\n    pool.receive(conn2)\n}\n```", "```\nLoan Pool Object with ID: 0\nLoan Pool Object with ID: 1\nReturn Pool Object with ID: 0\nReturn Pool Object with ID: 1\n```"]