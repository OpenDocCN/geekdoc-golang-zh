- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:24:13'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Select statement with timeout in Go (Golang)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/select-statement-with-timeout-go/](https://golangbyexample.com/select-statement-with-timeout-go/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Code](#Code "Code")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Timeout with infinite for loop outside select statement](#Timeout_with_infinite_for_loop_outside_select_statement
    "Timeout with infinite for loop outside select statement")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeout in select can be achieved by using **After()** function of time package.
    Below  is the signature of **After()** function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The **After** function waits for d duration  to finish and then it returns the
    current time on a channel -
  prefs: []
  type: TYPE_NORMAL
- en: '[https://golang.org/pkg/time/#Time.After](https://golang.org/pkg/time/#Time.After)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a program
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above select statement we are waiting for for the receive operation to
    complete on **ch1**. In other case statement we have **time.After** with the duration
    of 1 second. So essentially this select statement will wait for at least 1 second
    for receive operation to complete on **ch1** and after that the **time.After**
    case statement will be executed.  We have put a timeout of more than 1 seconds
    in the **goOne** function and hence we  see the **time.After** statement getting
    executed and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: getting printed as output.
  prefs: []
  type: TYPE_NORMAL
- en: So time.After() is a channel operation that gets unblocked after some time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeout with infinite for loop outside select statement**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can have infinite for loop outside a select statement. This will cause the
    select statement to execute indefinite number of times.So when using for statement
    with infinite loop outside the select statement, we need to have a way yo break
    out of the for loop. One of the use case of having infinite for look outside select
    statement could be that you are waiting for multiple operations to receive on
    a particular channel for a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: See below example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we have created a channel named **news**  which will hold
    data of string type. Then we pass this channel to the **newsfeed** function which
    is pushing the news feed to this channel . In the select statement, we are receiving
    the news feed from the **news** channel. This select statement is inside an infinite
    for loop  so the select statement will be executed multiple times until we  exit
    out of for loop . We also have **time.After** with a duration for 1 second as
    one of the case statements. So this set up will receive all the news from the
    **news** channel for  1  second and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
