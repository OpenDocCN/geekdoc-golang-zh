<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch002.xhtml</title>
  <style>
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #fffadf; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #008080; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #556622; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #008080; font-style: italic; } /* Comment */
    code span.cv { color: #008080; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #008080; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #008080; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="from-files-to-databases" class="level1">
<h1>01. From Files To Databases</h1>
<p>Let’s start with files, and examine the challenges we face.</p>
<section id="updating-files-in-place" class="level2">
<h2>1.1 Updating files in-place</h2>
<p>Let’s say you need to save some data to disk; this is a typical way to do it:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> SaveData1<span class="op">(</span>path <span class="dt">string</span><span class="op">,</span> data <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    fp<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>OpenFile<span class="op">(</span>path<span class="op">,</span> os<span class="op">.</span>O_WRONLY<span class="op">|</span>os<span class="op">.</span>O_CREATE<span class="op">|</span>os<span class="op">.</span>O_TRUNC<span class="op">,</span> <span class="bn">0664</span><span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">defer</span> fp<span class="op">.</span>Close<span class="op">()</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> err <span class="op">=</span> fp<span class="op">.</span>Write<span class="op">(</span>data<span class="op">)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fp<span class="op">.</span>Sync<span class="op">()</span> <span class="co">// fsync</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code creates the file if it does not exist, or truncates the existing one before writing the content. And most importantly, the data is not persistent unless you call <code>fsync</code> (<code>fp.Sync()</code> in Go).</p>
<p>It has some serious limitations:</p>
<ol type="1">
<li>It updates the content as a whole; only usable for tiny data. This is why you don’t use Excel as a database.</li>
<li>If you need to update the old file, you must read and modify it in memory, then overwrite the old file. What if the app crashes while overwriting the old file?</li>
<li>If the app needs concurrent access to the data, how do you prevent readers from getting mixed data and writers from conflicting operations? That’s why most databases are client-server, you need a server to coordinate concurrent clients. (Concurrency is more complicated without a server, see SQLite).</li>
</ol>
</section>
<section id="atomic-renaming" class="level2">
<h2>1.2 Atomic renaming</h2>
<section id="replacing-data-atomically-by-renaming-files" class="level3">
<h3>Replacing data atomically by renaming files</h3>
<p>Many problems are solved by not updating data <em>in-place</em>. You can write a new file and delete the old file.</p>
<p>Not touching the old file data means:</p>
<ol type="1">
<li>If the update is interrupted, you can recover from the old file since it remains intact.</li>
<li>Concurrent readers won’t get half written data.</li>
</ol>
<p>The problem is how readers will find the new file. A common pattern is to rename the new file to the old file path.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> SaveData2<span class="op">(</span>path <span class="dt">string</span><span class="op">,</span> data <span class="op">[]</span><span class="dt">byte</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    tmp <span class="op">:=</span> fmt<span class="op">.</span>Sprintf<span class="op">(</span><span class="st">&quot;%s.tmp.%d&quot;</span><span class="op">,</span> path<span class="op">,</span> randomInt<span class="op">())</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    fp<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>OpenFile<span class="op">(</span>tmp<span class="op">,</span> os<span class="op">.</span>O_WRONLY<span class="op">|</span>os<span class="op">.</span>O_CREATE<span class="op">|</span>os<span class="op">.</span>O_EXCL<span class="op">,</span> <span class="bn">0664</span><span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">defer</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        fp<span class="op">.</span>Close<span class="op">()</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            os<span class="op">.</span>Remove<span class="op">(</span>tmp<span class="op">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}()</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> err <span class="op">=</span> fp<span class="op">.</span>Write<span class="op">(</span>data<span class="op">)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    err <span class="op">=</span> fp<span class="op">.</span>Sync<span class="op">()</span> <span class="co">// fsync</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> os<span class="op">.</span>Rename<span class="op">(</span>tmp<span class="op">,</span> path<span class="op">)</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Renaming a file to an existing one replaces it <em>atomically</em>; deleting the old file is not needed (and not correct).</p>
<p>Pay attention to the meaning of the jargon, whenever you see “X is atomic”, you should ask “X is atomic <em>with respect to</em> what?” In this case:</p>
<ul>
<li>Rename is atomic w.r.t. concurrent readers; a reader opens either the old or the new file.</li>
<li>Rename is NOT atomic w.r.t. power loss; it’s not even durable. You need an extra <code>fsync</code> on the parent <em>directory</em>, which is discussed later.</li>
</ul>
</section>
<section id="why-does-renaming-work" class="level3">
<h3>Why does renaming work?</h3>
<p>Filesystems keep a mapping from file names to file data, so replacing a file by renaming simply points the file name to the new data without touching the old data. That’s why atomic renaming is possible in filesystems. And the operation cost is constant regardless of the data size.</p>
<p>On Linux, the replaced old file may still exist if it’s still being opened by a reader; it’s just not accessible from a file name. Readers can safely work on whatever version of the data it got, while writer won’t be blocked by readers. However, there must be a way to prevent concurrent writers. The level of concurrency is multi-reader-single-writer, which is what we will implement.</p>
</section>
</section>
<section id="append-only-logs" class="level2">
<h2>1.3 Append-only logs</h2>
<section id="safe-incremental-updates-with-logs" class="level3">
<h3>Safe incremental updates with logs</h3>
<p>One way to do incremental updates is to just append the updates to a file. This is called a “log” because it’s append-only. It’s safer than in-place updates because no data is overwritten; you can always recover the old data after a crash.</p>
<p>The reader must consider all log entries when using the log. For example, here is a log-based KV with 4 entries:</p>
<pre><code>     0         1         2        3
| set a=1 | set b=2 | set a=3 | del b |</code></pre>
<p>The final state is <code>a=3</code>.</p>
<p>Logs are an essential component of many databases. However, a log is only a description of each update, which means:</p>
<ul>
<li>It’s not an indexing data structure; readers must read all entries.</li>
<li>It has no way to reclaim space from deleted data.</li>
</ul>
<p>So logs alone are not enough to build a DB, they must be combined with other indexing data structures.</p>
</section>
<section id="atomic-log-updates-with-checksums" class="level3">
<h3>Atomic log updates with checksums</h3>
<p>While a log won’t corrupt old data, you still have to deal with the last entry if it gets corrupted after a crash. Many possibilities:</p>
<ol type="1">
<li>The last append simply does not happen; the log is still good.</li>
<li>The last entry is half written.</li>
<li>The size of the log is increased but the last entry is not there.</li>
</ol>
<p>The way to deal with these cases is to add a checksum to each log entry. If the checksum is wrong, the update did not happen, making log updates atomic (w.r.t. both readers and durability).</p>
<p>This scenario is about incomplete writes (<em>torn writes</em> in DB jargon) that occur before a successful <code>fsync</code>. Checksums can also detect other forms of corruption after <code>fsync</code>, but that’s not something a DB can recover from.</p>
</section>
</section>
<section id="fsync-gotchas" class="level2">
<h2>1.4 `fsync` gotchas</h2>
<p>After renaming files or creating new files, you must call <code>fsync</code> on the parent directory. A directory is a mapping from file names to files, and like file data, it’s not durable unless you use <code>fsync</code>. See <a href="https://www.usenix.org/sites/default/files/conference/protected-files/osdi14_slides_pillai.pdf#page=31">this example</a> of <code>fsync</code> on the directory.</p>
<p>Another issue with <code>fsync</code> is error handling. If <code>fsync</code> fails, the DB update fails, but what if you read the file afterwards? You may get the new data even if <code>fsync</code> failed (because of the OS page cache)! This behavior is <a href="https://www.usenix.org/conference/atc20/presentation/rebello">filesystem dependent</a>.</p>
</section>
<section id="summary-of-database-challenges" class="level2">
<h2>1.5 Summary of database challenges</h2>
<p>What we have learned:</p>
<ol type="1">
<li>Problems with in-place updates.
<ul>
<li>Avoid in-place updates by renaming files.</li>
<li>Avoid in-place updates using logs.</li>
</ul></li>
<li>Append-only logs.
<ul>
<li>Incremental updates.</li>
<li>Not a full solution; no indexing and space reuse.</li>
</ul></li>
<li><code>fsync</code> usage.</li>
</ol>
<p>What remains a question:</p>
<ol type="1">
<li>Indexing data structures and how to update them.</li>
<li>Reuse space from append-only files.</li>
<li>Combining a log with an indexing data structure.</li>
<li>Concurrency.</li>
</ol>
</section>
</section>
</body>
</html>
