["```go\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: ClientHello (supported ciphers, random)\n    Server->>Client: ServerHello (chosen cipher, random)\n    Server->>Client: Certificate\n    Server->>Client: ServerKeyExchange\n    Client->>Server: ClientKeyExchange\n    Client->>Server: ChangeCipherSpec\n    Server->>Client: ChangeCipherSpec\n    Note over Client,Server: Handshake Complete â€“ Encrypted communication begins\n```", "```go\n`tlsConfig  :=  &tls.Config{   SessionTicketsDisabled:  false,  // Enable session tickets explicitly   SessionTicketKey:  [32]byte{...},  // Persist securely and rotate periodically }` \n```", "```go\n`tlsConfig  :=  &tls.Config{   CipherSuites:  []uint16{   tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,   tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,   tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,   tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,   },   PreferServerCipherSuites:  true, }` \n```", "```go\n`tlsConfig  :=  &tls.Config{   NextProtos:  []string{\"h2\",  \"http/1.1\"}, }` \n```", "```go\n`tlsConfig  :=  &tls.Config{   ClientAuth:  tls.RequireAndVerifyClientCert,   ClientCAs:  certPool,  // pre-verified CA pool   VerifyPeerCertificate:  cachedCertVerifier,  // custom verifier with caching }` \n```", "```go\n`// Cache to avoid re-verifying the same certificate repeatedly var  verificationCache  sync.Map  // cachedCertVerifier verifies a peer certificate chain and caches successful leaf fingerprints func  cachedCertVerifier(rawCerts  [][]byte,  verifiedChains  [][]*x509.Certificate)  error  {   // Compute SHA-256 fingerprint of the leaf certificate   fingerprint  :=  sha256.Sum256(rawCerts[0])   if  _,  exists  :=  verificationCache.Load(fingerprint);  exists  {   // Already verified earlier; skip full verification   return  nil   }    // Parse the leaf certificate   leafCert,  err  :=  x509.ParseCertificate(rawCerts[0])   if  err  !=  nil  {   return  fmt.Errorf(\"failed to parse leaf certificate: %w\",  err)   }    // Build pool of intermediate certificates provided by peer   intermediatePool  :=  x509.NewCertPool()   for  _,  raw  :=  range  rawCerts[1:]  {   intermediateCert,  err  :=  x509.ParseCertificate(raw)   if  err  !=  nil  {   return  fmt.Errorf(\"failed to parse intermediate certificate: %w\",  err)   }   intermediatePool.AddCert(intermediateCert)   }    // Prepare verification options with trusted roots & intermediates   opts  :=  x509.VerifyOptions{   Roots:  certPool,  // trusted root CAs   Intermediates:  intermediatePool,  // peer-provided intermediates   KeyUsages:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},   }    // Verify the full chain starting from leaf   chains,  err  :=  leafCert.Verify(opts)   if  err  ==  nil  {   // Store successful verification in cache   verificationCache.Store(fingerprint,  struct{}{})   }   return  err }` \n```", "```go\n`tlsConfig  :=  &tls.Config{   SessionTicketsDisabled:  false,   SessionTicketKey:  [32]byte{...},   CipherSuites:  []uint16{   tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,   tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,   tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,   tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,   },   PreferServerCipherSuites:  true,   NextProtos:  []string{\"h2\",  \"http/1.1\"},   ClientAuth:  tls.RequireAndVerifyClientCert,   ClientCAs:  certPool,   VerifyPeerCertificate:  cachedCertVerifier,   MinVersion:  tls.VersionTLS12,   CurvePreferences:  []tls.CurveID{tls.CurveP256,  tls.X25519}, }` \n```"]