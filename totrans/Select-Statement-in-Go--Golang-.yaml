- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:23:23'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Select Statement in Go (Golang)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/select-statement-golang/](https://golangbyexample.com/select-statement-golang/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the  chapter 25 of the golang comprehensive tutorial series. Refer to
    this link for other chapters of the series – [Golang Comprehensive Tutorial Series](https://golangbyexample.com/golang-comprehensive-tutorial/)
  prefs: []
  type: TYPE_NORMAL
- en: '**Next Tutorial** – [Error](https://golangbyexample.com/error-in-golang/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Previous Tutorial** – [Channel](https://golangbyexample.com/channel-golang/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s check out the current tutorial. Below is the table of contents for
    current tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use of  select statement](#Use_of_select_statement "Use of  select statement")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Select with send operation example](#Select_with_send_operation_example "Select
    with send operation example")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Select with default case](#Select_with_default_case "Select with default case")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Select with blocking timeout](#Select_with_blocking_timeout "Select with blocking
    timeout")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Empty select](#Empty_select "Empty select")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Select statement with an infinite for loop outside](#Select_statement_with_an_infinite_for_loop_outside
    "Select statement with an infinite for loop outside")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Select statement with a nil channel](#Select_statement_with_a_nil_channel
    "Select statement with a nil channel")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Break keyword in Select](#Break_keyword_in_Select "Break keyword in Select")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select is similar to switch statement, the difference being that in select each
    of the case statement waits for a send or receive operation from a channel. Select
    statement will wait until send or receive operation is completed on any one of
    the case statements. It is different from the switch statement in the way that
    each of the case statements will either send or receive operation on a channel
    whereas in switch each of the case statements is an expression.  So a select statement
    lets you wait on multiple send and receive operations from different channels. 
    Two important points to note about set a statement is
  prefs: []
  type: TYPE_NORMAL
- en: The select blocks until any of the case statements are ready.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple case statements are ready then it selects one at random and proceeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below is the format of **select**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Select chooses  the case on which send or receive operation on a channel is
    not blocked and is ready to be executed. If multiple cases are ready to be executed
    then one is choosen at random.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a simple example. We will study about default case later in this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we created two channels that are passed to two different
    goroutines. Then each of the goroutines is sending one value to the channel. In
    the select, we have two case statements. Each of the two **case** statements is
    waiting for a receive operation to complete on one of the channels. Once any receive
    operation is complete on any of the channels it is executed and **select** exits.
    So as seen from the output, in the above program, it prints the received value
    from one of the channels and exits.
  prefs: []
  type: TYPE_NORMAL
- en: So in the above program since it is not deterministic which of the send operation
    will complete earlier that is why you will see different outputs if you run the
    program multiple times. Let's see another program where we will put timeout in
    the goroutine goTwo before sending the value to the **ch2** channel. This will
    make sure that the send operation on **ch1** will be executed earlier than send
    operation to **ch2**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, in select statement the receive operation on **ch1** is
    completed earlier and hence select will always be executing that case statement
    as also evident from the output
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to wait for receive operation to complete on both the channels
    by using a for loop across the select statement. Let's see a program for that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we put a for loop of length two across the select statement.
    Hence the select statement is executed twice and prints the received value from
    each of the case statements.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that select can block if any of the case statement is not
    ready. Let's see an example for that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we created a channel named **ch1**.  We then receive from
    this channel in the select statement.  Since no goroutine  is sending to this
    channel hence it results in a deadlock and select statement blocks indefinitely. 
    That is why it gives  below output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Use of  select statement**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The select statement is useful if there are multiple goroutines that are sending
    data to multiple channels concurrently. The select statement can then receive
    the data concurrently from any of one goroutine and execute the statement which
    is ready. So select along with channels and goroutines become a very powerful
    tool for managing synchronization and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Select with send operation example**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen examples of receive operation in select case statements.
    Let's see an example of send operation as well
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Select with default case**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to switch select can also have a default case.  This default case will
    be executed if no send it or receive operation is ready on any of the case statements.
    So in a way default statement prevents the select from blocking forever.  So a
    very important point to note is that the default statement makes the select non-blocking.
    If the select statement doesn't contain a default case then it can block forever
    until one send or receive operation is ready on any case statement. Let's see
    an example to fully understand it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above program have a select statement which is waiting for receive operation
    on **ch1** and a default statement. Since no goroutine is sending to channel **ch1**,
    hence the default case is executed and select exits. If default case were not
    there the select would have blocked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Select with blocking timeout**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blocking timeout in select can be achieved by using **After()** function of
    **time** package. Below  is the signature of **After()** function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The **After** function waits for d duration  to finish and then it returns the
    current time on a channel
  prefs: []
  type: TYPE_NORMAL
- en: '[https://golang.org/pkg/time/#Time.After](https://golang.org/pkg/time/#Time.After)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a program of select with timeout
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the above select statement we are waiting for receive operation to complete
    on **ch1**. In other case statement we have **time.After** with the duration of
    1 second. So essentially this select statement will wait for at least 1 second
    for receive operation to complete on **ch1** and after that the **time.After**
    case statement will be executed.  We have put a timeout of more than 1 seconds
    in the **goOne** function and hence we  see the **time.After** statement getting
    executed and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: getting printed as output
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty select**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select block without any case statement is empty select. The empty select will
    block forever as there is no case statement  to execute. It is also one of the
    way for a goroutine to wait indefinitely. But if this empty select is put in the
    main goroutine then it will cause a deadlock. Let's see a program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the above program we have empty select and hence it results in a deadlock
    that is why you see the output as below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Select statement with an infinite for loop outside**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can have infinite for loop outside a select statement. This will cause the
    select statement to execute indefinite number of times.So when using for statement
    with infinite loop outside the select statement, we need to have a way yo break
    out of the for loop. One of the use case of having infinite for loop outside select
    statement could be that you are waiting for multiple operations to receive on
    the same channel for a certain time. See below example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, we have created a channel named **news**  which will hold
    data of string type. Then we pass this channel to the **newsfeed** function which
    is pushing the news feed to this channel . In the select statement, we are receiving
    the news feed from the **news** channel. This select statement is inside an infinite
    for loop  so the select statement will be executed multiple times until we  exit
    out of for loop . We also have **time.After** with a duration for 1 second as
    one of the case statements. So this set up will receive all the news from the
    **news** channel for  1  second and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Select statement with a nil channel**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Send or receive operation on nil channel blocks forever. Hence a use case of
    having a nil channel in the select statement is to disable that case statement
    after the the send or receive operation is completed on that case statement. The
    channel then can simply be set to nil. That case statement will be  ignored when
    the select statement is executed again and receive or send operation will be waited
    on another case statement. So it is meant to ignore that case statement and execute
    the other case statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The above program is pretty much similar to the program we studied above related
    to having a select statement inside infinite for loop. The only change being that 
    after we receive the first news, we disabled the case statement by setting the
    news channel to nil.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Hence  we only received the first news and after that, it times out.  This is
    the use case of nil channel in the select statement
  prefs: []
  type: TYPE_NORMAL
- en: '**Break keyword in Select**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below is the **break** keyword example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**break** statement will terminate the execution of innermost statement and
    below line below will never be executed'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is all about the select statement in golang. Hope you have liked this article.
    Please share feedback/improvements/mistakes in comments
  prefs: []
  type: TYPE_NORMAL
- en: '**Next Tutorial** – [Error](https://golangbyexample.com/error-in-golang/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Previous Tutorial** – [Channel](https://golangbyexample.com/channel-golang/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
