<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Optimizing TLS for Speed: Handshake, Reuse, and Cipher Choice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Optimizing TLS for Speed: Handshake, Reuse, and Cipher Choice</h1>
<blockquote>原文：<a href="https://goperf.dev/02-networking/tls-for-speed/">https://goperf.dev/02-networking/tls-for-speed/</a></blockquote>
                
                  


  
  



<p>TLS does what it’s supposed to: it keeps your connections private and trustworthy. But it also slows things down — a lot more than most people realize. In Go, if you care about how quickly your service responds, you can squeeze out better performance by tuning how TLS negotiates and what it negotiates.</p>
<h2 id="understanding-tls-overhead-where-performance-suffers">Understanding TLS Overhead: Where Performance Suffers</h2>
<p>Most of the slowdown in TLS happens right at the start. The handshake is a back-and-forth process: picking algorithms, swapping keys, proving identities, and setting up the session. That back-and-forth usually takes two full trips across the network. In something like a trading platform or a real-time app, that delay is noticeable.</p>
<p>To make TLS faster, the most effective place to start is cutting down the handshake steps and making the crypto work less expensive.</p>
<pre class="mermaid"><code>sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: ClientHello (supported ciphers, random)
    Server-&gt;&gt;Client: ServerHello (chosen cipher, random)
    Server-&gt;&gt;Client: Certificate
    Server-&gt;&gt;Client: ServerKeyExchange
    Client-&gt;&gt;Server: ClientKeyExchange
    Client-&gt;&gt;Server: ChangeCipherSpec
    Server-&gt;&gt;Client: ChangeCipherSpec
    Note over Client,Server: Handshake Complete – Encrypted communication begins</code></pre>
<h2 id="session-resumption-cutting-handshake-latency">Session Resumption: Cutting Handshake Latency</h2>
<p>Because every new TLS connection runs the entire handshake — negotiating ciphers, exchanging keys, verifying certificates — it introduces noticeable latency. Session resumption sidesteps most of that by reusing the cryptographic state from an earlier session, making reconnects much faster.</p>
<p>Session resumption is a mechanism in TLS to avoid repeating the full handshake on reconnect. There are two main approaches: session IDs and session tickets. Both rely on the idea that the server remembers (or encodes) the session’s cryptographic state from a prior connection. When a client reconnects, it presents either the session ID or the session ticket, allowing the server to restore the session state and skip expensive asymmetric key exchange.</p>
<p>A session ticket is a data blob issued by the server to the client at the end of the handshake. This ticket contains the encrypted session state (such as negotiated cipher suite, keys, and session parameters) and is opaque to the client. On reconnect, the client sends the ticket back, and the server decrypts it to resume the session without performing a full handshake.</p>
<p>In Go, you enable session resumption by setting up session ticket keys. The server uses these keys to encrypt and decrypt the session state that clients send back when resuming a connection. You can generate a secure 32‑byte key at startup with crypto/rand and reuse it if your service is running across multiple instances behind a load balancer. Just make sure to rotate the key now and then to keep it secure.</p>
<div class="highlight"><pre><span/><code><span class="nx">tlsConfig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">    </span><span class="nx">SessionTicketsDisabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="c1">// Enable session tickets explicitly</span>
<span class="w">    </span><span class="nx">SessionTicketKey</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="o">...</span><span class="p">},</span><span class="w"> </span><span class="c1">// Persist securely and rotate periodically</span>
<span class="p">}</span>
</code></pre></div>
<p>What makes session resumption effective is that it avoids re‑doing the slowest parts of TLS. Instead of negotiating everything from scratch, the server decrypts the ticket, verifies it, and restores the session. That eliminates at least one full round trip and all the heavy asymmetric operations, which saves both time and resources.</p>
<h2 id="choosing-cipher-suites-wisely">Choosing Cipher Suites Wisely</h2>
<p>Cipher suites define the combination of algorithms used for key exchange, authentication, encryption, and integrity checking. Selecting efficient cipher suites significantly impacts performance.</p>
<p>Why prefer one over another? Some suites use RSA for key exchange, which is much slower than elliptic-curve Diffie–Hellman (ECDHE) and lacks forward secrecy. Suites with AES-GCM are faster on modern CPUs thanks to hardware acceleration, whereas older CBC-mode suites are slower and more error-prone. ECC-based authentication (ECDSA) also provides shorter signatures and lower computational cost compared to RSA.</p>
<p>To choose wisely:</p>
<ul>
<li>Prioritize suites with ECDHE for forward secrecy and better performance.</li>
<li>Prefer AES-GCM over AES-CBC or ChaCha20 unless targeting hardware that lacks AES acceleration (where ChaCha20 may win).</li>
<li>Avoid suites using only RSA for key exchange, because they lack forward secrecy and require more expensive computations on the server side.</li>
</ul>
<p>The Go standard library ships with a solid set of secure and reasonably fast defaults. For most applications, you can stick with those and be fine. But if you’re tuning for a high‑performance environment, defining your own preferred cipher suites gives you tighter control over what gets negotiated.</p>
<p>An optimized config favors AES‑GCM for its hardware acceleration and ECC for its efficiency.</p>
<div class="highlight"><pre><span/><code><span class="nx">tlsConfig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">    </span><span class="nx">CipherSuites</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint16</span><span class="p">{</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">PreferServerCipherSuites</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>These suites strike a good balance between security and speed, leveraging forward secrecy and hardware-accelerated encryption. The second option, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, is a reasonable choice when clients may not support ECDSA certificates — it still provides forward secrecy and efficient AES-GCM encryption while relying on the more widely deployed RSA for authentication.</p>
<h2 id="using-alpn-wisely">Using ALPN Wisely</h2>
<p>Application-Layer Protocol Negotiation (ALPN) lets clients and servers agree upon the application protocol (like HTTP/2, HTTP/1.1, or gRPC) during the TLS handshake, avoiding additional round trips or guessing after establishing the connection. Without ALPN, a client would have to fall back to slower or less efficient methods to detect the server’s supported protocol.</p>
<p>In Go, the <code>NextProtos</code> field in <code>tls.Config</code> defines which application protocols the server supports and in what order of preference. During the TLS handshake, the client sends its own list, and the server picks the highest‑priority protocol that both sides support, then confirms it.</p>
<p>If you want to support <code>HTTP/2</code> with a fallback to <code>HTTP/1.1</code>, you should set <code>NextProtos</code> explicitly, like this:</p>
<div class="highlight"><pre><span/><code><span class="nx">tlsConfig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">    </span><span class="nx">NextProtos</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"h2"</span><span class="p">,</span><span class="w"> </span><span class="s">"http/1.1"</span><span class="p">},</span>
<span class="p">}</span>
</code></pre></div>
<p>The sequence of entries in <code>NextProtos</code> matters because the server walks the list in order and chooses the first protocol also offered by the client. By putting HTTP/2 (<code>h2</code>) at the top, the server ensures it prefers HTTP/2 when supported, falling back to HTTP/1.1 only when necessary. If the order is incorrect, the server may settle on a slower protocol or fail to agree entirely.</p>
<p>When <code>NextProtos</code> is left empty, ALPN is effectively disabled. The client assumes HTTP/1.1 because it never sees an indication of HTTP/2 support during the handshake. Explicitly setting <code>NextProtos</code> advertises the server’s capabilities and avoids unnecessary protocol downgrades.</p>
<h2 id="minimizing-certificate-verification-overhead">Minimizing Certificate Verification Overhead</h2>
<p>Certificate verification tends to be CPU‑heavy because it involves several expensive asymmetric cryptographic operations, which directly increase connection latency. This cost can be reduced in two ways: by using smaller, faster‑to‑verify ECC‑based (ECDSA) certificates instead of RSA, and by caching already‑validated certificate chains to avoid repeating the same verification work on subsequent connections.</p>
<div class="highlight"><pre><span/><code><span class="nx">tlsConfig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">    </span><span class="nx">ClientAuth</span><span class="p">:</span><span class="w"> </span><span class="nx">tls</span><span class="p">.</span><span class="nx">RequireAndVerifyClientCert</span><span class="p">,</span>
<span class="w">    </span><span class="nx">ClientCAs</span><span class="p">:</span><span class="w"> </span><span class="nx">certPool</span><span class="p">,</span><span class="w"> </span><span class="c1">// pre-verified CA pool</span>
<span class="w">    </span><span class="nx">VerifyPeerCertificate</span><span class="p">:</span><span class="w"> </span><span class="nx">cachedCertVerifier</span><span class="p">,</span><span class="w"> </span><span class="c1">// custom verifier with caching</span>
<span class="p">}</span>
</code></pre></div>
<p>A basic caching mechanism stores verification outcomes temporarily:</p>
<div class="highlight"><pre><span/><code><span class="c1">// Cache to avoid re-verifying the same certificate repeatedly</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">verificationCache</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>

<span class="c1">// cachedCertVerifier verifies a peer certificate chain and caches successful leaf fingerprints</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">cachedCertVerifier</span><span class="p">(</span><span class="nx">rawCerts</span><span class="w"> </span><span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span><span class="w"> </span><span class="nx">verifiedChains</span><span class="w"> </span><span class="p">[][]</span><span class="o">*</span><span class="nx">x509</span><span class="p">.</span><span class="nx">Certificate</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Compute SHA-256 fingerprint of the leaf certificate</span>
<span class="w">    </span><span class="nx">fingerprint</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sha256</span><span class="p">.</span><span class="nx">Sum256</span><span class="p">(</span><span class="nx">rawCerts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">exists</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">verificationCache</span><span class="p">.</span><span class="nx">Load</span><span class="p">(</span><span class="nx">fingerprint</span><span class="p">);</span><span class="w"> </span><span class="nx">exists</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Already verified earlier; skip full verification</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Parse the leaf certificate</span>
<span class="w">    </span><span class="nx">leafCert</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">x509</span><span class="p">.</span><span class="nx">ParseCertificate</span><span class="p">(</span><span class="nx">rawCerts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"failed to parse leaf certificate: %w"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Build pool of intermediate certificates provided by peer</span>
<span class="w">    </span><span class="nx">intermediatePool</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">x509</span><span class="p">.</span><span class="nx">NewCertPool</span><span class="p">()</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">raw</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">rawCerts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">intermediateCert</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">x509</span><span class="p">.</span><span class="nx">ParseCertificate</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">"failed to parse intermediate certificate: %w"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">intermediatePool</span><span class="p">.</span><span class="nx">AddCert</span><span class="p">(</span><span class="nx">intermediateCert</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Prepare verification options with trusted roots &amp; intermediates</span>
<span class="w">    </span><span class="nx">opts</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">x509</span><span class="p">.</span><span class="nx">VerifyOptions</span><span class="p">{</span>
<span class="w">        </span><span class="nx">Roots</span><span class="p">:</span><span class="w">         </span><span class="nx">certPool</span><span class="p">,</span><span class="w">                            </span><span class="c1">// trusted root CAs</span>
<span class="w">        </span><span class="nx">Intermediates</span><span class="p">:</span><span class="w"> </span><span class="nx">intermediatePool</span><span class="p">,</span><span class="w">                    </span><span class="c1">// peer-provided intermediates</span>
<span class="w">        </span><span class="nx">KeyUsages</span><span class="p">:</span><span class="w">     </span><span class="p">[]</span><span class="nx">x509</span><span class="p">.</span><span class="nx">ExtKeyUsage</span><span class="p">{</span><span class="nx">x509</span><span class="p">.</span><span class="nx">ExtKeyUsageServerAuth</span><span class="p">},</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Verify the full chain starting from leaf</span>
<span class="w">    </span><span class="nx">chains</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">leafCert</span><span class="p">.</span><span class="nx">Verify</span><span class="p">(</span><span class="nx">opts</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Store successful verification in cache</span>
<span class="w">        </span><span class="nx">verificationCache</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">fingerprint</span><span class="p">,</span><span class="w"> </span><span class="kd">struct</span><span class="p">{}{})</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span>
<span class="p">}</span>
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While the snippet illustrates key concepts, it should not be used in production as-is. Cryptographic code demands careful analysis and adaptation to the specific environment and threat model. Always validate and test security-related code before deployment to avoid introducing weaknesses.</p>
</div>
<h2 id="tls-best-practices-in-go">TLS Best Practices in Go</h2>
<p>The following configuration brings together these techniques into a tls.Config that is optimized for both performance and security.</p>
<p>The <code>MinVersion</code> setting tells the server to reject older, broken versions of TLS. Anything below TLS 1.2 — like SSLv3, TLS 1.0, or 1.1 — is riddled with weaknesses and no longer considered safe. TLS 1.2 fixed many of those problems by introducing AEAD ciphers like AES‑GCM and defenses against attacks such as BEAST and POODLE.</p>
<p>The <code>CurvePreferences</code> field prioritizes fast and secure elliptic curves supported by most clients. P-256 and X25519 are efficient, widely-supported, and often hardware-accelerated. P-256 (also known as secp256r1) is an NIST-recommended curve with broad compatibility and native support in most CPUs for fast computation. X25519 is a modern curve designed for both speed and simplicity, offering constant-time operations to resist side-channel attacks, and performs especially well on low-power or embedded devices.</p>
<p>Te rest parts were discussed in details above.</p>
<div class="highlight"><pre><span/><code><span class="nx">tlsConfig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">    </span><span class="nx">SessionTicketsDisabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nx">SessionTicketKey</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="o">...</span><span class="p">},</span>
<span class="w">    </span><span class="nx">CipherSuites</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="kt">uint16</span><span class="p">{</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</span><span class="p">,</span>
<span class="w">        </span><span class="nx">tls</span><span class="p">.</span><span class="nx">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nx">PreferServerCipherSuites</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nx">NextProtos</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"h2"</span><span class="p">,</span><span class="w"> </span><span class="s">"http/1.1"</span><span class="p">},</span>
<span class="w">    </span><span class="nx">ClientAuth</span><span class="p">:</span><span class="w"> </span><span class="nx">tls</span><span class="p">.</span><span class="nx">RequireAndVerifyClientCert</span><span class="p">,</span>
<span class="w">    </span><span class="nx">ClientCAs</span><span class="p">:</span><span class="w"> </span><span class="nx">certPool</span><span class="p">,</span>
<span class="w">    </span><span class="nx">VerifyPeerCertificate</span><span class="p">:</span><span class="w"> </span><span class="nx">cachedCertVerifier</span><span class="p">,</span>
<span class="w">    </span><span class="nx">MinVersion</span><span class="p">:</span><span class="w"> </span><span class="nx">tls</span><span class="p">.</span><span class="nx">VersionTLS12</span><span class="p">,</span>
<span class="w">    </span><span class="nx">CurvePreferences</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="nx">tls</span><span class="p">.</span><span class="nx">CurveID</span><span class="p">{</span><span class="nx">tls</span><span class="p">.</span><span class="nx">CurveP256</span><span class="p">,</span><span class="w"> </span><span class="nx">tls</span><span class="p">.</span><span class="nx">X25519</span><span class="p">},</span>
<span class="p">}</span>
</code></pre></div>
<p>TLS optimization is about balancing performance and security effectively. By reducing handshake overhead through session reuse, wisely selecting cipher suites with ECC and hardware acceleration, efficiently leveraging ALPN, and minimizing certificate verification overhead through caching, Go applications can achieve both security and speed. This approach makes TLS less a performance bottleneck and more a seamless security foundation for modern network services.</p>









  




                
                  
</body>
</html>