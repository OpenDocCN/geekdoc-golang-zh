["```go\n[](#cb1-1)create table t1 (\n[](#cb1-2)    k1 string,\n[](#cb1-3)    k2 int,\n[](#cb1-4)    v1 string,\n[](#cb1-5)    v2 string,\n[](#cb1-6)    primary key (k1, k2)\n[](#cb1-7));\n```", "```go\n[](#cb2-1)create table t1 (\n[](#cb2-2)    k1 string,\n[](#cb2-3)    k2 int,\n[](#cb2-4)    v1 string,\n[](#cb2-5)    v2 string,\n[](#cb2-6)    primary key (k1, k2),\n[](#cb2-7)    index idx1 (v1),\n[](#cb2-8)    index idx2 (v2, v1)\n[](#cb2-9));\n```", "```go\n[](#cb3-1)create table idx1 (\n[](#cb3-2)    -- indexed key (v1)\n[](#cb3-3)    v1 string,\n[](#cb3-4)    -- primary key (k1, k2)\n[](#cb3-5)    k1 string,\n[](#cb3-6)    k2 int\n[](#cb3-7));\n[](#cb3-8)create table idx2 (\n[](#cb3-9)    -- indexed key (v2, v1)\n[](#cb3-10)    v2 string,\n[](#cb3-11)    v1 string,\n[](#cb3-12)    -- primary key (k1, k2)\n[](#cb3-13)    k1 string,\n[](#cb3-14)    k2 int\n[](#cb3-15));\n```", "```go\n[](#cb4-1)const (\n[](#cb4-2)    TYPE_BYTES = 1 // string (of arbitrary bytes)\n[](#cb4-3)    TYPE_INT64 = 2 // integer; 64-bit signed\n[](#cb4-4))\n[](#cb4-5)\n[](#cb4-6)// table cell\n[](#cb4-7)type Value struct {\n[](#cb4-8)    Type uint32 // tagged union\n[](#cb4-9)    I64  int64\n[](#cb4-10)    Str  []byte\n[](#cb4-11)}\n```", "```go\n[](#cb5-1)// table row\n[](#cb5-2)type Record struct {\n[](#cb5-3)    Cols []string\n[](#cb5-4)    Vals []Value\n[](#cb5-5)}\n[](#cb5-6)\n[](#cb5-7)func (rec *Record) AddStr(col string, val []byte) *Record {\n[](#cb5-8)    rec.Cols = append(rec.Cols, col)\n[](#cb5-9)    rec.Vals = append(rec.Vals, Value{Type: TYPE_BYTES, Str: val})\n[](#cb5-10)    return rec\n[](#cb5-11)}\n[](#cb5-12)func (rec *Record) AddInt64(col string, val int64) *Record\n[](#cb5-13)func (rec *Record) Get(col string) *Value\n```", "```go\n[](#cb6-1)type TableDef struct {\n[](#cb6-2)    // user defined\n[](#cb6-3)    Name  string\n[](#cb6-4)    Types []uint32 // column types\n[](#cb6-5)    Cols  []string // column names\n[](#cb6-6)    PKeys int      // the first `PKeys` columns are the primary key\n[](#cb6-7)    // auto-assigned B-tree key prefixes for different tables\n[](#cb6-8)    Prefix uint32\n[](#cb6-9)}\n```", "```go\n[](#cb7-1)var TDEF_TABLE = &TableDef{\n[](#cb7-2)    Prefix: 2,\n[](#cb7-3)    Name:   \"@table\",\n[](#cb7-4)    Types:  []uint32{TYPE_BYTES, TYPE_BYTES},\n[](#cb7-5)    Cols:   []string{\"name\", \"def\"},\n[](#cb7-6)    PKeys:  1,\n[](#cb7-7)}\n```", "```go\n[](#cb8-1)create table `@table` (\n[](#cb8-2)    `name` string,  -- table name\n[](#cb8-3)    `def` string,   -- schema\n[](#cb8-4)    primary key (`name`)\n[](#cb8-5));\n```", "```go\n[](#cb9-1)var TDEF_META = &TableDef{\n[](#cb9-2)    Prefix: 1,\n[](#cb9-3)    Name:   \"@meta\",\n[](#cb9-4)    Types:  []uint32{TYPE_BYTES, TYPE_BYTES},\n[](#cb9-5)    Cols:   []string{\"key\", \"val\"},\n[](#cb9-6)    PKeys:  1,\n[](#cb9-7)}\n```", "```go\n[](#cb10-1)func (db *DB) Get(table string, rec *Record) (bool, error)\n[](#cb10-2)func (db *DB) Insert(table string, rec Record) (bool, error)\n[](#cb10-3)func (db *DB) Update(table string, rec Record) (bool, error)\n[](#cb10-4)func (db *DB) Upsert(table string, rec Record) (bool, error)\n[](#cb10-5)func (db *DB) Delete(table string, rec Record) (bool, error)\n```", "```go\n[](#cb11-1)type DB struct {\n[](#cb11-2)    Path string\n[](#cb11-3)    kv KV\n[](#cb11-4)}\n```", "```go\n[](#cb12-1)// get a single row by the primary key\n[](#cb12-2)func dbGet(db *DB, tdef *TableDef, rec *Record) (bool, error) {\n[](#cb12-3)    // 1\\. reorder the input columns according to the schema\n[](#cb12-4)    values, err := checkRecord(tdef, *rec, tdef.PKeys)\n[](#cb12-5)    if err != nil {\n[](#cb12-6)        return false, err\n[](#cb12-7)    }\n[](#cb12-8)    // 2\\. encode the primary key\n[](#cb12-9)    key := encodeKey(nil, tdef.Prefix, values[:tdef.PKeys])\n[](#cb12-10)    // 3\\. query the KV store\n[](#cb12-11)    val, ok := db.kv.Get(key)\n[](#cb12-12)    if !ok {\n[](#cb12-13)        return false, nil\n[](#cb12-14)    }\n[](#cb12-15)    // 4\\. decode the value into columns\n[](#cb12-16)    for i := tdef.PKeys; i < len(tdef.Cols); i++ {\n[](#cb12-17)        values[i].Type = tdef.Types[i]\n[](#cb12-18)    }\n[](#cb12-19)    decodeValues(val, values[tdef.PKeys:])\n[](#cb12-20)    rec.Cols = tdef.Cols\n[](#cb12-21)    rec.Vals = values\n[](#cb12-22)    return true, nil\n[](#cb12-23)}\n```", "```go\n[](#cb13-1)// reorder a record and check for missing columns.\n[](#cb13-2)// n == tdef.PKeys: record is exactly a primary key\n[](#cb13-3)// n == len(tdef.Cols): record contains all columns\n[](#cb13-4)func checkRecord(tdef *TableDef, rec Record, n int) ([]Value, error)\n```", "```go\n[](#cb14-1)// encode columns for the \"key\" of the KV\n[](#cb14-2)func encodeKey(out []byte, prefix uint32, vals []Value) []byte\n[](#cb14-3)// decode columns from the \"value\" of the KV\n[](#cb14-4)func decodeValues(in []byte, out []Value)\n```", "```go\n[](#cb15-1)// get a single row by the primary key\n[](#cb15-2)func (db *DB) Get(table string, rec *Record) (bool, error) {\n[](#cb15-3)    tdef := getTableDef(db, table)\n[](#cb15-4)    if tdef == nil {\n[](#cb15-5)        return false, fmt.Errorf(\"table not found: %s\", table)\n[](#cb15-6)    }\n[](#cb15-7)    return dbGet(db, tdef, rec)\n[](#cb15-8)}\n```", "```go\n[](#cb16-1)func getTableDef(db *DB, name string) *TableDef {\n[](#cb16-2)    rec := (&Record{}).AddStr(\"name\", []byte(name))\n[](#cb16-3)    ok, err := dbGet(db, TDEF_TABLE, rec)\n[](#cb16-4)    assert(err == nil)\n[](#cb16-5)    if !ok {\n[](#cb16-6)        return nil\n[](#cb16-7)    }\n[](#cb16-8)\n[](#cb16-9)    tdef := &TableDef{}\n[](#cb16-10)    err = json.Unmarshal(rec.Get(\"def\").Str, tdef)\n[](#cb16-11)    assert(err == nil)\n[](#cb16-12)    return tdef\n[](#cb16-13)}\n```", "```go\n[](#cb17-1)// update modes\n[](#cb17-2)const (\n[](#cb17-3)    MODE_UPSERT      = 0 // insert or replace\n[](#cb17-4)    MODE_UPDATE_ONLY = 1 // update existing keys\n[](#cb17-5)    MODE_INSERT_ONLY = 2 // only add new keys\n[](#cb17-6))\n[](#cb17-7)\n[](#cb17-8)type UpdateReq struct {\n[](#cb17-9)    tree *BTree\n[](#cb17-10)    // out\n[](#cb17-11)    Added   bool   // added a new key\n[](#cb17-12)    // in\n[](#cb17-13)    Key  []byte\n[](#cb17-14)    Val  []byte\n[](#cb17-15)    Mode int\n[](#cb17-16)}\n[](#cb17-17)\n[](#cb17-18)func (tree *BTree) Update(req *UpdateReq)\n```", "```go\n[](#cb18-1)func dbUpdate(db *DB, tdef *TableDef, rec Record, mode int) (bool, error) {\n[](#cb18-2)    values, err := checkRecord(tdef, rec, len(tdef.Cols))\n[](#cb18-3)    if err != nil {\n[](#cb18-4)        return false, err\n[](#cb18-5)    }\n[](#cb18-6)    key := encodeKey(nil, tdef.Prefix, values[:tdef.PKeys])\n[](#cb18-7)    val := encodeValues(nil, values[tdef.PKeys:])\n[](#cb18-8)    return db.kv.Update(key, val, mode)\n[](#cb18-9)}\n```", "```go\n[](#cb19-1)func (db *DB) TableNew(tdef *TableDef) error\n```"]