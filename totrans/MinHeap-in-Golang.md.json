["```\npackage main\n\nimport \"fmt\"\n\ntype minheap struct {\n    heapArray []int\n    size      int\n    maxsize   int\n}\n\nfunc newMinHeap(maxsize int) *minheap {\n    minheap := &minheap{\n        heapArray: []int{},\n        size:      0,\n        maxsize:   maxsize,\n    }\n    return minheap\n}\n\nfunc (m *minheap) leaf(index int) bool {\n    if index >= (m.size/2) && index <= m.size {\n        return true\n    }\n    return false\n}\n\nfunc (m *minheap) parent(index int) int {\n    return (index - 1) / 2\n}\n\nfunc (m *minheap) leftchild(index int) int {\n    return 2*index + 1\n}\n\nfunc (m *minheap) rightchild(index int) int {\n    return 2*index + 2\n}\n\nfunc (m *minheap) insert(item int) error {\n    if m.size >= m.maxsize {\n        return fmt.Errorf(\"Heap is full\")\n    }\n    m.heapArray = append(m.heapArray, item)\n    m.size++\n    m.upHeapify(m.size - 1)\n    return nil\n}\n\nfunc (m *minheap) swap(first, second int) {\n    temp := m.heapArray[first]\n    m.heapArray[first] = m.heapArray[second]\n    m.heapArray[second] = temp\n}\n\nfunc (m *minheap) upHeapify(index int) {\n    for m.heapArray[index] < m.heapArray[m.parent(index)] {\n        m.swap(index, m.parent(index))\n        index = m.parent(index)\n    }\n}\n\nfunc (m *minheap) downHeapify(current int) {\n    if m.leaf(current) {\n        return\n    }\n    smallest := current\n    leftChildIndex := m.leftchild(current)\n    rightRightIndex := m.rightchild(current)\n    //If current is smallest then return\n    if leftChildIndex < m.size && m.heapArray[leftChildIndex] < m.heapArray[smallest] {\n        smallest = leftChildIndex\n    }\n    if rightRightIndex < m.size && m.heapArray[rightRightIndex] < m.heapArray[smallest] {\n        smallest = rightRightIndex\n    }\n    if smallest != current {\n        m.swap(current, smallest)\n        m.downHeapify(smallest)\n    }\n    return\n}\nfunc (m *minheap) buildMinHeap() {\n    for index := ((m.size / 2) - 1); index >= 0; index-- {\n        m.downHeapify(index)\n    }\n}\n\nfunc (m *minheap) remove() int {\n    top := m.heapArray[0]\n    m.heapArray[0] = m.heapArray[m.size-1]\n    m.heapArray = m.heapArray[:(m.size)-1]\n    m.size--\n    m.downHeapify(0)\n    return top\n}\n\nfunc main() {\n    inputArray := []int{6, 5, 3, 7, 2, 8}\n    minHeap := newMinHeap(len(inputArray))\n    for i := 0; i < len(inputArray); i++ {\n        minHeap.insert(inputArray[i])\n    }\n    minHeap.buildMinHeap()\n    for i := 0; i < len(inputArray); i++ {\n        fmt.Println(minHeap.remove())\n    }\n    fmt.Scanln()\n}\n```", "```\n2\n3\n5\n6\n7\n8\n```"]