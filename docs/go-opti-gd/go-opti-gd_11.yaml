- en: Stack Allocations and Escape Analysis¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈分配和逃逸分析[¶](#stack-allocations-and-escape-analysis "永久链接")
- en: 原文：[https://goperf.dev/01-common-patterns/stack-alloc/](https://goperf.dev/01-common-patterns/stack-alloc/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/stack-alloc/](https://goperf.dev/01-common-patterns/stack-alloc/)
- en: When writing performance-critical Go applications, one of the subtle but significant
    optimizations you can make is encouraging values to be allocated on the stack
    rather than the heap. Stack allocations are cheaper, faster, and garbage-free—but
    Go doesn't always put your variables there automatically. That decision is made
    by the Go compiler during **escape analysis**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写性能关键型的 Go 应用程序时，您可以进行的微妙但重要的优化之一是鼓励值在栈上而不是在堆上分配。栈分配更便宜、更快，且无垃圾回收——但 Go 并不总是自动将您的变量放在那里。这个决定是在
    **逃逸分析** 期间由 Go 编译器做出的。
- en: In this article, we’ll explore what escape analysis is, how to read the compiler’s
    escape diagnostics, what causes values to escape, and how to structure your code
    to minimize unnecessary heap allocations. We'll also benchmark different scenarios
    to show the real-world impact.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将探讨逃逸分析是什么，如何阅读编译器的逃逸诊断，什么原因导致值逃逸，以及如何构建代码以最小化不必要的堆分配。我们还将对不同场景进行基准测试，以展示其在现实世界中的影响。
- en: What Is Escape Analysis?[¶](#what-is-escape-analysis "Permanent link")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是逃逸分析？[¶](#what-is-escape-analysis "永久链接")
- en: Escape analysis is a static analysis performed by the Go compiler to determine
    whether a variable can be safely allocated on the stack or if it must be moved
    ("escape") to the heap.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 逃逸分析是 Go 编译器执行的一种静态分析，用于确定变量是否可以安全地分配在栈上，或者是否必须移动（“逃逸”）到堆上。
- en: Why does it matter?[¶](#why-does-it-matter "Permanent link")
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这为什么很重要？[¶](#why-does-it-matter "永久链接")
- en: '**Stack allocations** are cheap: the memory is automatically freed when the
    function returns.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈分配**便宜：当函数返回时，内存会自动释放。'
- en: '**Heap allocations** are more expensive: they involve garbage collection overhead.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆分配**更昂贵：它们涉及垃圾回收开销。'
- en: The compiler decides where to place each variable based on how it's used. If
    a variable can be guaranteed to not outlive its declaring function, it can stay
    on the stack. If not, it escapes to the heap.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据变量的使用方式来决定每个变量的放置位置。如果一个变量可以保证不会超出其声明函数的生命周期，它就可以留在栈上。如果不能，它就会逃逸到堆上。
- en: 'Example: Stack vs Heap[¶](#example-stack-vs-heap "Permanent link")'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：栈与堆[¶](#example-stack-vs-heap "永久链接")
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In `allocate`, `x` is returned as a pointer. Since the pointer escapes the function,
    the Go compiler places `x` on the heap. In `noEscape`, `x` is a plain value and
    doesn’t escape.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `allocate` 中，`x` 作为指针返回。由于指针逃逸了函数，Go 编译器将 `x` 放在堆上。在 `noEscape` 中，`x` 是一个普通值，不会逃逸。
- en: How to View Escape Analysis Output[¶](#how-to-view-escape-analysis-output "Permanent
    link")
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何查看逃逸分析输出[¶](#how-to-view-escape-analysis-output "永久链接")
- en: 'You can inspect escape analysis with the `-gcflags` compiler option:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `-gcflags` 编译器选项来检查逃逸分析：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or for a specific file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于特定的文件：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print lines like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出类似以下的内容：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Look for messages like `moved to heap` to identify escape points.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找类似“移动到堆”的消息来识别逃逸点。
- en: What Causes Variables to Escape?[¶](#what-causes-variables-to-escape "Permanent
    link")
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么原因导致变量逃逸？[¶](#what-causes-variables-to-escape "永久链接")
- en: 'Here are common scenarios that force heap allocation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的场景，这些场景会强制进行堆分配：
- en: Returning Pointers to Local Variables[¶](#returning-pointers-to-local-variables
    "Permanent link")
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将指针返回给局部变量[¶](#returning-pointers-to-local-variables "永久链接")
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Capturing Variables in Closures[¶](#capturing-variables-in-closures "Permanent
    link")
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在闭包中捕获变量[¶](#capturing-variables-in-closures "永久链接")
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Interface Conversions[¶](#interface-conversions "Permanent link")
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口转换[¶](#interface-conversions "永久链接")
- en: 'When a value is stored in an interface, it may escape:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值存储在接口中时，它可能会逃逸：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assignments to Global Variables or Struct Fields[¶](#assignments-to-global-variables-or-struct-fields
    "Permanent link")
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将值赋给全局变量或结构体字段[¶](#assignments-to-global-variables-or-struct-fields "永久链接")
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Large Composite Literals[¶](#large-composite-literals "Permanent link")
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大型复合字面量[¶](#large-composite-literals "永久链接")
- en: Go may allocate large structs or slices on the heap even if they don’t strictly
    escape.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们没有严格逃逸，Go 也可能在堆上分配大的结构体或切片。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Benchmarking Stack vs Heap Allocations[¶](#benchmarking-stack-vs-heap-allocations
    "Permanent link")
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试栈与堆分配[¶](#benchmarking-stack-vs-heap-allocations "永久链接")
- en: Let’s run a benchmark to explore when heap allocations actually occur—and when
    they don’t, even if we return a pointer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个基准测试来探索堆分配实际上何时发生——以及即使我们返回指针，它们何时不会发生。
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Benchmark Results
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果
- en: '| Benchmark | Iterations | Time per op (ns) | Bytes per op | Allocs per op
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Benchmark | 迭代次数 | 每次操作时间 (ns) | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| BenchmarkStackAlloc-14 | 1,000,000,000 | 0.2604 ns | 0 B | 0 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkStackAlloc-14 | 1,000,000,000 | 0.2604 ns | 0 B | 0 |'
- en: '| BenchmarkHeapAlloc-14 | 1,000,000,000 | 0.2692 ns | 0 B | 0 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkHeapAlloc-14 | 1,000,000,000 | 0.2692 ns | 0 B | 0 |'
- en: 'You might expect `HeapAlloc` to always allocate memory on the heap—but it doesn’t
    here. That’s because the compiler is smart: in this isolated benchmark, the pointer
    returned by `HeapAlloc` doesn’t escape the function in any meaningful way. The
    compiler can see it’s only used within the benchmark and short-lived, so it safely
    places it on the stack too.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望 `HeapAlloc` 总是在堆上分配内存——但在这里不是。这是因为编译器很聪明：在这个独立的基准测试中，`HeapAlloc` 返回的指针以任何有意义的方式都没有逃出函数。编译器可以看到它只用于基准测试，并且是短命的，因此它安全地将它放在栈上。
- en: Forcing a Heap Allocation[¶](#forcing-a-heap-allocation "Permanent link")
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制堆分配[¶](#forcing-a-heap-allocation "永久链接")
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Benchmark | Iterations | Time per op (ns) | Bytes per op | Allocs per op
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Benchmark | 迭代次数 | 每次操作时间 (ns) | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| BenchmarkHeapAllocEscape-14 | 331,469,049 | 10.55 ns | 24 B | 1 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkHeapAllocEscape-14 | 331,469,049 | 10.55 ns | 24 B | 1 |'
- en: 'As shown in `BenchmarkHeapAllocEscape`, assigning the pointer to a global variable
    causes a real heap escape. This introduces real overhead: a 40x slower call, a
    24-byte allocation, and one garbage-collected object per call.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `BenchmarkHeapAllocEscape` 所示，将指针赋值给全局变量会导致真正的堆逃逸。这引入了真正的开销：40 倍更慢的调用、24 字节的分配以及每次调用一个垃圾回收对象。
- en: <details class="example"><summary>Show the benchmark file</summary>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示基准测试文件</summary>
- en: '[PRE11]</details>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]</details>'
- en: When to Optimize for Stack Allocation[¶](#when-to-optimize-for-stack-allocation
    "Permanent link")
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当何时优化栈分配[¶](#when-to-optimize-for-stack-allocation "永久链接")
- en: Not all escapes are worth preventing. Here’s when it makes sense to focus on
    stack allocation—and when it’s better to let values escape.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的逃逸都值得预防。以下是在关注栈分配时合理的情况，以及何时最好让值逃逸。
- en: When to Avoid Escape
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当何时避免逃逸
- en: In performance-critical paths. Reducing heap usage in tight loops or latency-sensitive
    code lowers GC pressure and speeds up execution.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能关键路径上。在紧密循环或延迟敏感的代码中减少堆的使用可以降低垃圾回收压力并加快执行速度。
- en: For short-lived, small objects. These can be efficiently stack-allocated without
    involving the garbage collector, reducing memory churn.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于短生命期、小对象。这些可以在不涉及垃圾回收器的情况下有效地在栈上分配，从而减少内存碎片。
- en: When you control the full call chain. If the object stays within your code and
    you can restructure it to avoid escape, it’s often worth the small refactor.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你控制完整的调用链。如果对象保持在你的代码中，并且你可以重构它以避免逃逸，那么进行小的重构通常是值得的。
- en: If profiling reveals GC bottlenecks. Escape analysis helps you target and shrink
    memory-heavy allocations identified in real-world traces.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分析显示存在垃圾回收瓶颈。逃逸分析帮助你针对并缩小在现实世界跟踪中识别出的内存密集型分配。
- en: When It’s Fine to Let Values Escape
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许值逃逸是可行的
- en: When returning values from constructors or factories. Returning a pointer from
    `NewThing()` is idiomatic Go—even if it causes an escape, it improves clarity
    and usability.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从构造函数或工厂返回值时。从 `NewThing()` 返回指针是 Go 语言的惯例——即使它会导致逃逸，但它提高了清晰度和可用性。
- en: When objects must outlive the function. If you're storing data in a global,
    sending to a goroutine, or saving it in a struct, escaping is necessary and correct.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象必须超出函数的生命周期。如果你在全局存储数据、发送到 goroutine 或将其保存在结构体中，逃逸是必要的且正确的。
- en: When allocation size is small and infrequent. If the heap allocation isn’t in
    a hot path, the benefit of avoiding it is often negligible.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当分配大小小且不频繁时。如果堆分配不在热点路径上，避免它的好处通常可以忽略不计。
- en: When preventing escape hurts readability. Writing awkward code to keep everything
    on the stack can reduce maintainability for a micro-optimization that won’t matter.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当防止逃逸损害可读性。为了保持所有内容在栈上而编写的尴尬代码可能会降低微优化带来的可维护性。
