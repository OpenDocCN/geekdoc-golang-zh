["```go\nstateDiagram-v2\n    [*] --> New : goroutine declared\n    New --> Runnable : go func() invoked\n    Runnable --> Running : scheduled on an available P\n    Running --> Waiting : blocking syscall, channel op, etc.\n    Waiting --> Runnable : event ready, rescheduled\n    Running --> Terminated : function exits or panics\n    Waiting --> Terminated : canceled or panicked\n    Terminated --> [*]\n\n    state \"Go Scheduler\\n(GOMAXPROCS = N)\" as Scheduler {\n        [*] --> P1\n        [*] --> P2\n        ...\n        [*] --> PN\n\n        P1 --> ScheduleGoroutine1 : pick from global/runq\n        P2 --> ScheduleGoroutine2\n        PN --> ScheduleGoroutineN\n    }\n\n    note right of Runnable\n        Ps (Processors) pick Runnable goroutines\n        based on availability up to GOMAXPROCS\n    end note\n\n    note right of Scheduler\n        GOMAXPROCS determines how many Ps\n        can execute goroutines in parallel.\n    end note\n```", "```go\nflowchart TD\n    A[\"Goroutine: conn.Read()\"] --> B[netpoller checks FD]\n    B --> C{FD ready?}\n    C -- No --> D[Park goroutine]\n    D --> E[FD registered with epoll]\n    E --> F[epoll_wait blocks]\n    F --> G[FD ready]\n    G --> H[Wake goroutine]\n    H --> I[Re-schedule]\n    C -- Yes --> H\n```", "```go\nflowchart TD\n    A[net.Listen] --> B[ListenTCP] --> C[listenFD]\n    C --> D[\"pollDesc (register with netpoll)\"]\n    D --> E[runtime-integrated non-blocking syscall wrappers]\n```", "```go\n`package  main  import  (   \"bufio\"   \"fmt\"   \"net\"   \"time\" )  func  main()  {   // Start listening on TCP port 9000   listener,  err  :=  net.Listen(\"tcp\",  \":9000\")   if  err  !=  nil  {   panic(err)  // Exit if the port can't be bound   }   fmt.Println(\"Echo server listening on :9000\")    // Accept incoming connections in a loop   for  {   conn,  err  :=  listener.Accept()  // Accept new client connection   if  err  !=  nil  {   fmt.Printf(\"Accept error: %v\\n\",  err)   continue  // Skip this iteration on error   }    // Handle the connection in a new goroutine for concurrency   go  handle(conn)   } }  // handle echoes data back to the client line-by-line func  handle(conn  net.Conn)  {   defer  conn.Close()  // Ensure connection is closed on exit    reader  :=  bufio.NewReader(conn)  // Wrap connection with buffered reader    for  {   // Set a read deadline to avoid hanging goroutines if client disappears   conn.SetReadDeadline(time.Now().Add(5  *  60  *  time.Second))  // 5 minutes timeout    // Read input until newline character   line,  err  :=  reader.ReadString('\\n')   if  err  !=  nil  {   fmt.Printf(\"Connection closed: %v\\n\",  err)   return  // Exit on read error (e.g. client disconnect)   }    // Echo the received line back to the client   _,  err  =  conn.Write([]byte(line))   if  err  !=  nil  {   fmt.Printf(\"Write error: %v\\n\",  err)   return  // Exit on write error   }   } }` \n```", "```go\n`import  (   \"bufio\"   \"fmt\"   \"net\"   \"time\"   \"sync/atomic\" )` \n```", "```go\n`listener,  err  :=  net.Listen(\"tcp\",  \":9000\") if  err  !=  nil  {   panic(err) } fmt.Println(\"Echo server listening on :9000\")` \n```", "```go\n`for  {   conn,  err  :=  listener.Accept()   if  err  !=  nil  {   fmt.Printf(\"Accept error: %v\\n\",  err)   continue   }   go  handle(conn) }` \n```", "```go\n`func  handle(conn  net.Conn)  {   defer  conn.Close()    reader  :=  bufio.NewReader(conn)    for  {   conn.SetReadDeadline(time.Now().Add(5  *  60  *  time.Second))    line,  err  :=  reader.ReadString('\\n')   if  err  !=  nil  {   fmt.Printf(\"Connection closed: %v\\n\",  err)   return   }    _,  err  =  conn.Write([]byte(line))   if  err  !=  nil  {   fmt.Printf(\"Write error: %v\\n\",  err)   return   }   } }` \n```", "```go\nsequenceDiagram\n    participant L as Listener Goroutine\n    participant N as netFD\n    participant P as Go Poller\n    participant S as syscall layer\n    participant H as Handler Goroutine\n\n    L->>N: Accept()\n    N->>P: Wait for connection (runtime_pollWait)\n    P->>S: syscall.accept\n    S-->>L: Return net.Conn\n    L->>H: go handle(conn)\n\n    H->>N: Read()\n    N->>P: Wait for data (runtime_pollWait)\n    P->>S: syscall.read\n    S-->>H: Return data\n    H->>N: Write()\n    N->>P: Check readiness\n    P->>S: syscall.write\n    S-->>H: Confirm write\n```"]