["```go\n`func  worker(id  int,  jobs  <-chan  int,  results  chan<-  [32]byte)  {   for  j  :=  range  jobs  {   results  <-  doWork(j)   } }  func  doWork(n  int)  [32]byte  {   data  :=  []byte(fmt.Sprintf(\"payload-%d\",  n))   return  sha256.Sum256(data)  // (1) }  func  main()  {   jobs  :=  make(chan  int,  100)   results  :=  make(chan  [32]byte,  100)    for  w  :=  1;  w  <=  5;  w++  {   go  worker(w,  jobs,  results)   }    for  j  :=  1;  j  <=  10;  j++  {   jobs  <-  j   }   close(jobs)    for  a  :=  1;  a  <=  10;  a++  {   <-results   } }` \n```", "```go\n`package  perf  import  (   // \"log\"   \"fmt\"   // \"os\"   \"runtime\"   \"sync\"   \"testing\"   \"crypto/sha256\" )  const  (   numJobs  =  10000   workerCount  =  10 )  func  doWork(n  int)  [32]byte  {   data  :=  []byte(fmt.Sprintf(\"payload-%d\",  n))   return  sha256.Sum256(data) }  func  BenchmarkUnboundedGoroutines(b  *testing.B)  {   for  b.Loop()  {   var  wg  sync.WaitGroup   wg.Add(numJobs)    for  j  :=  0;  j  <  numJobs;  j++  {   go  func(job  int)  {   _  =  doWork(job)   wg.Done()   }(j)   }   wg.Wait()   } }  func  worker(jobs  <-chan  int,  wg  *sync.WaitGroup)  {   for  job  :=  range  jobs  {   _  =  doWork(job)   wg.Done()   } }  func  BenchmarkWorkerPool(b  *testing.B)  {   for  b.Loop()  {   var  wg  sync.WaitGroup   wg.Add(numJobs)    jobs  :=  make(chan  int,  numJobs)   for  w  :=  0;  w  <  workerCount;  w++  {   go  worker(jobs,  &wg)   }    for  j  :=  0;  j  <  numJobs;  j++  {   jobs  <-  j   }    close(jobs)   wg.Wait()   } }` \n```"]