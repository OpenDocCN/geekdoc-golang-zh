["```\nInput: m=2 , n=2\nOutput: 2\n\nRobot can reach the right down corner in two ways. \n1\\. [0,0] -> [0,1]-> [1, 1]\n2\\. [0,0] -> [1,0]-> [1, 1]\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc uniquePaths(m int, n int) int {\n\tpaths := make([][]int, m)\n\n\tfor i := 0; i < m; i++ {\n\t\tpaths[i] = make([]int, n)\n\t}\n\n\tpaths[0][0] = 1\n\n\tfor i := 1; i < m; i++ {\n\t\tpaths[i][0] = 1\n\t}\n\n\tfor i := 1; i < n; i++ {\n\t\tpaths[0][i] = 1\n\t}\n\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tpaths[i][j] = paths[i-1][j] + paths[i][j-1]\n\t\t}\n\t}\n\n\treturn paths[m-1][n-1]\n}\n\nfunc main() {\n\toutput := uniquePaths(3, 7)\n\tfmt.Println(output)\n}\n```", "```\n6\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\n\n\tm := len(obstacleGrid)\n\tn := len(obstacleGrid[0])\n\tpaths := make([][]int, len(obstacleGrid))\n\n\tfor i := 0; i < m; i++ {\n\t\tpaths[i] = make([]int, n)\n\t}\n\n\tif obstacleGrid[0][0] != 1 {\n\t\tpaths[0][0] = 1\n\t}\n\n\tfor i := 1; i < m; i++ {\n\t\tif obstacleGrid[i][0] == 1 {\n\t\t\tbreak\n\t\t} else {\n\t\t\tpaths[i][0] = paths[i-1][0]\n\t\t}\n\n\t}\n\n\tfor i := 1; i < n; i++ {\n\t\tif obstacleGrid[0][i] == 1 {\n\t\t\tbreak\n\t\t} else {\n\t\t\tpaths[0][i] = paths[0][i-1]\n\t\t}\n\n\t}\n\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tif obstacleGrid[i][j] != 1 {\n\t\t\t\tpaths[i][j] = paths[i-1][j] + paths[i][j-1]\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn paths[m-1][n-1]\n}\n\nfunc main() {\n\toutput := uniquePathsWithObstacles([][]int{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}})\n\tfmt.Println(output)\n}\n```", "```\n2\n```"]