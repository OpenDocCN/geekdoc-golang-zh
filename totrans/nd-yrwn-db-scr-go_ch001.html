<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch001.xhtml</title>
  <style>
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="introduction" class="level1">
<h1>00. Introduction</h1>
<section id="master-fundamentals-by-building-your-own-db" class="level2">
<h2>Master fundamentals by building your own DB</h2>
<section id="what-to-learn" class="level3">
<h3>What to learn?</h3>
<p>Complex systems like databases are built on a few simple principles.</p>
<ol type="1">
<li><strong>Atomicity &amp; durability</strong>. A DB is more than files!
<ul>
<li>Persist data with <code>fsync</code>.</li>
<li>Crash recovery.</li>
</ul></li>
<li><strong>KV store</strong> based on <strong>B-tree</strong>.
<ul>
<li>Disk-based data structures.</li>
<li>Space management with a free list.</li>
</ul></li>
<li><strong>Relational DB</strong> on top of KV.
<ul>
<li>How tables and indexes are mapped to low-level B-trees.</li>
<li>SQL-like <strong>query language</strong>; parser &amp; interpreter.</li>
</ul></li>
<li><strong>Concurrency control</strong> for transactions.</li>
</ol>
</section>
<section id="code-a-database-in-3000-loc-incrementally" class="level3">
<h3>Code a database in 3000 LoC, incrementally</h3>
<p>It’s amazing that an interesting and broad topic can be captured in 3000 LoC. You may have experience with larger projects, but not all experience is equal.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">LoC</th>
<th style="text-align: left;">Step</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">366</td>
<td style="text-align: left;">B+tree data structure.</td>
</tr>
<tr class="even">
<td style="text-align: right;">601</td>
<td style="text-align: left;">Append-only KV.</td>
</tr>
<tr class="odd">
<td style="text-align: right;">731</td>
<td style="text-align: left;">Practical KV with a free list.</td>
</tr>
<tr class="even">
<td style="text-align: right;">1107</td>
<td style="text-align: left;">Tables on KV.</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1294</td>
<td style="text-align: left;">Range queries.</td>
</tr>
<tr class="even">
<td style="text-align: right;">1438</td>
<td style="text-align: left;">Secondary indexes.</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1461</td>
<td style="text-align: left;">Transactional interfaces.</td>
</tr>
<tr class="even">
<td style="text-align: right;">1702</td>
<td style="text-align: left;">Concurrency control.</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2795</td>
<td style="text-align: left;">SQL-like query language.</td>
</tr>
</tbody>
</table>
</section>
<section id="learn-by-doing-principles-instead-of-jargon" class="level3">
<h3>Learn by doing: principles instead of jargon</h3>
<p>Database literature is full of confusing, overloaded jargon with no consistent meaning. It’s easy to get lost when reading about it. On the other hand, Feymann once said, “what I can’t build, I don’t understand”. Can you build a database by reading about databases? Test your understanding!</p>
<p>While there is a lot to learn, not all knowledge is equally important, <strong>it takes only a few principles to build a DB</strong>, so anyone can try.</p>
</section>
</section>
<section id="topic-1-durability-and-atomicity" class="level2">
<h2>Topic 1: durability and atomicity</h2>
<section id="more-than-a-data-format" class="level3">
<h3>More than a data format</h3>
<p>Smartphones use SQLite (a file-based DB) heavily. Why store data in SQLite instead of some other format, say JSON? Because you risk data loss if it crashes during an update. The file can end up half-written, truncated, or even missing.</p>
<p>There are techniques to fix this, and they lead to databases.</p>
</section>
<section id="durability-and-atomicity-with-fsync" class="level3">
<h3>Durability and atomicity with `fsync`</h3>
<p>Atomicity means that data is either updated or not, not in between. Durability means that data is guaranteed to exist after a certain point. They are not separate concerns, because we must achieved both.</p>
<p>The first thing to learn is the <code>fsync</code> syscall. A file write doesn’t reach disk synchronously, there are multiple levels of buffering (OS page cache and on-device RAM). <code>fsync</code> flushes pending data and waits until it’s done. This makes writes durable, but what about atomicity?</p>
</section>
</section>
<section id="topic-2-indexing-data-structures" class="level2">
<h2>Topic 2: indexing data structures</h2>
<section id="control-latency-and-cost-with-indexes" class="level3">
<h3>Control latency and cost with indexes</h3>
<p>A DB turns a query into a result without the user knowing how. But the result is not the only concern, <em>latency</em> and <em>cost</em> (memory, IO, computation) are also relevant, hence the distinction between analytical (OLAP) and transactional (OLTP).</p>
<ul>
<li>OLAP can involve large amounts of data, with aggregation or join operations. Indexing can be limited or non-existent.</li>
<li>OLTP touches small amounts of data using indexes. Low latency &amp; cost.</li>
</ul>
<p>The word “transactional” is not about DB transactions, it’s just a funny jargon.</p>
</section>
<section id="in-memory-data-structures-vs.-on-disk-data-structures" class="level3">
<h3>In-memory data structures vs. on-disk data structures</h3>
<p>There are extra challenges when putting an indexing data structure on disk. (See my book “Build Your Own Redis” for a much easier in-memory DB).</p>
<p>One of the problems is updating disk data <em>in-place</em>, because you have to deal with corrupted states after a crash. Disks are not just slower RAM.</p>
<p>The R in RAM stands for “random”, which is another problem for disk-based data because random access is much slower than sequential access, even on SSDs. So data structures like binary trees are not viable while B-trees and LSM-trees are OK. <em>Concurrent</em> access to data structures is also a topic.</p>
</section>
</section>
<section id="topic-3-relational-db-on-kv" class="level2">
<h2>Topic 3: Relational DB on KV</h2>
<section id="two-layers-of-db-interfaces" class="level3">
<h3>Two layers of DB interfaces</h3>
<p>SQL is almost a synonym for database. But SQL is just a user interface, it’s not fundamental to a DB. What’s important is the <strong>functionalities</strong> underneath.</p>
<p>Another much simpler interface is key-value (KV). You can get, set, and delete a single key, and most importantly, list a range of keys in sorted order. KV is simpler than SQL because it’s one layer lower. Relational DBs are built on top of KV-like interfaces called <em>storage engines</em>.</p>
</section>
<section id="query-languages-parsers-and-interpreters" class="level3">
<h3>Query languages: parsers and interpreters</h3>
<p>The last step is easy, despite the larger LoC. Both the parser and the interpreter are coded with nothing but <em>recursion</em>! The lesson can be applied to almost any computer language, or creating your own programming language or DSL (See my book “From Source Code To Machine Code” for more challenges).</p>
</section>
</section>
<section id="build-your-own-x-book-series" class="level2">
<h2><em>Build Your Own X</em> book series</h2>
<p>X includes Redis, web server and compiler. Read the web version on the website.</p>
<p><a href="https://build-your-own.org" class="uri">https://build-your-own.org</a> </p>
</section>
</section>
</body>
</html>
