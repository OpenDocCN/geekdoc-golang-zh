["```go\nimport (\n\n    _ \"net/http/pprof\"\n\n)\n\n// ...\n\n    // Start pprof in a separate goroutine.\n    go func() {\n        log.Println(\"pprof listening on :6060\")\n        if err := http.ListenAndServe(\"localhost:6060\", nil); err != nil {\n            log.Fatalf(\"pprof server error: %v\", err)\n        }\n    }() \n```", "```go\npackage main\n\n// pprof-start\nimport (\n// pprof-end\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"math/rand/v2\"\n    \"net/http\"\n// pprof-start\n    _ \"net/http/pprof\"\n// pprof-end\n    \"os\"\n    \"os/signal\"\n    \"time\"\n// pprof-start\n)\n// pprof-end\n\nvar (\n    fastDelay   = flag.Duration(\"fast-delay\", 0, \"Fixed delay for fast handler (if any)\")\n    slowMin     = flag.Duration(\"slow-min\", 1*time.Millisecond, \"Minimum delay for slow handler\")\n    slowMax     = flag.Duration(\"slow-max\", 300*time.Millisecond, \"Maximum delay for slow handler\")\n    gcMinAlloc  = flag.Int(\"gc-min-alloc\", 50, \"Minimum number of allocations in GC heavy handler\")\n    gcMaxAlloc  = flag.Int(\"gc-max-alloc\", 1000, \"Maximum number of allocations in GC heavy handler\")\n)\n\nfunc randRange(min, max int) int {\n    return rand.IntN(max-min) + min\n}\n\nfunc fastHandler(w http.ResponseWriter, r *http.Request) {\n    if *fastDelay > 0 {\n        time.Sleep(*fastDelay)\n    }\n    fmt.Fprintln(w, \"fast response\")\n}\n\nfunc slowHandler(w http.ResponseWriter, r *http.Request) {\n    delayRange := int((*slowMax - *slowMin) / time.Millisecond)\n    delay := time.Duration(randRange(1, delayRange)) * time.Millisecond\n    time.Sleep(delay)\n    fmt.Fprintf(w, \"slow response with delay %d ms\\n\", delay.Milliseconds())\n}\n\n// heavy-start\nvar longLivedData [][]byte\n\nfunc gcHeavyHandler(w http.ResponseWriter, r *http.Request) {\n    numAllocs := randRange(*gcMinAlloc, *gcMaxAlloc)\n    var data [][]byte\n    for i := 0; i < numAllocs; i++ {\n        // Allocate 10KB slices. Occasionally retain a reference to simulate long-lived objects.\n        b := make([]byte, 1024*10)\n        data = append(data, b)\n        if i%100 == 0 { // every 100 allocations, keep the data alive\n            longLivedData = append(longLivedData, b)\n        }\n    }\n    fmt.Fprintf(w, \"allocated %d KB\\n\", len(data)*10)\n}\n// heavy-end\n\nfunc main() {\n    flag.Parse()\n\n    http.HandleFunc(\"/fast\", fastHandler)\n    http.HandleFunc(\"/slow\", slowHandler)\n    http.HandleFunc(\"/gc\", gcHeavyHandler)\n\n// pprof-start\n// ...\n\n    // Start pprof in a separate goroutine.\n    go func() {\n        log.Println(\"pprof listening on :6060\")\n        if err := http.ListenAndServe(\"localhost:6060\", nil); err != nil {\n            log.Fatalf(\"pprof server error: %v\", err)\n        }\n    }()\n// pprof-end\n\n    // Create a server to allow for graceful shutdown.\n    server := &http.Server{Addr: \":8080\"}\n\n    go func() {\n        log.Println(\"HTTP server listening on :8080\")\n        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n            log.Fatalf(\"HTTP server error: %v\", err)\n        }\n    }()\n\n    // Graceful shutdown on interrupt signal.\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, os.Interrupt)\n    <-sigCh\n    log.Println(\"Shutting down server...\")\n    if err := server.Shutdown(nil); err != nil {\n        log.Fatalf(\"Server Shutdown Failed:%+v\", err)\n    }\n    log.Println(\"Server exited\")\n} \n```", "```go\ngo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30 \n```", "```go\ngo tool pprof -http=:7070 cpu.prof # (1) \n```", "```go\ngo tool pprof -http=:7070 http://localhost:6060/debug/pprof/heap \n```", "```go\nvar longLivedData [][]byte\n\nfunc gcHeavyHandler(w http.ResponseWriter, r *http.Request) {\n    numAllocs := randRange(*gcMinAlloc, *gcMaxAlloc)\n    var data [][]byte\n    for i := 0; i < numAllocs; i++ {\n        // Allocate 10KB slices. Occasionally retain a reference to simulate long-lived objects.\n        b := make([]byte, 1024*10)\n        data = append(data, b)\n        if i%100 == 0 { // every 100 allocations, keep the data alive\n            longLivedData = append(longLivedData, b)\n        }\n    }\n    fmt.Fprintf(w, \"allocated %d KB\\n\", len(data)*10)\n} \n```"]