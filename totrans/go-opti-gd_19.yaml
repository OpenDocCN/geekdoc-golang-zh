- en: Benchmarking and Load Testing for Networked Go Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络化 Go 应用程序的基准测试和负载测试
- en: 原文：[https://goperf.dev/02-networking/bench-and-load/](https://goperf.dev/02-networking/bench-and-load/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/02-networking/bench-and-load/](https://goperf.dev/02-networking/bench-and-load/)
- en: Before you reach for a mutex-free queue or tune your goroutine pool, step back.
    Optimization without a baseline is just guesswork. In Go applications, performance
    tuning starts with understanding how your system behaves under pressure, which
    means benchmarking it under load.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你伸手去一个无锁队列或调整你的 goroutine 池之前，退一步。没有基线的优化只是猜测。在 Go 应用程序中，性能调整始于了解你的系统在压力下的行为，这意味着在负载下对其进行基准测试。
- en: Load testing isn't just about pushing requests until things break. It's about
    simulating realistic usage patterns to extract measurable, repeatable data. That
    data anchors every optimization that follows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试不仅仅是推动请求直到事物崩溃。它是模拟现实的使用模式以提取可测量、可重复的数据。这些数据是后续每个优化的基础。
- en: 'Test App: Simulating Fast/Slow Paths and GC pressure'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用：模拟快速/慢路径和 GC 压力
- en: To benchmark meaningfully, we need endpoints that reflect different workload
    characteristics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行有意义的基准测试，我们需要反映不同工作负载特性的端点。
- en: <details class="example"><summary>Show the benchmarking app</summary>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示基准测试应用</summary>
- en: '[PRE0]</details>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]</details>'
- en: '`/fast`: A quick response, ideal for throughput testing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/fast`：快速响应，非常适合吞吐量测试。'
- en: '`/slow`: Simulates latency and contention.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/slow`：模拟延迟和竞争。'
- en: '`/gc`: Simulate GC heavy workflow.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/gc`：模拟 GC 重量级工作流程。'
- en: '`net/http/pprof`: Exposes runtime profiling on `localhost:6060`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http/pprof`：在 `localhost:6060` 上公开运行时分析。'
- en: 'Run it with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行方式：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Simulating Load: Tools That Reflect Reality'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟负载：反映现实情况的工具
- en: When to Use What
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用什么
- en: Info
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: This is by no means an exhaustive list. The ecosystem of load-testing tools
    is broad and constantly evolving. Tools like Apache JMeter, Locust, Artillery,
    and Gatling each bring their own strengths—ranging from UI-driven test design
    to distributed execution or JVM-based scenarios. The right choice depends on your
    stack, test goals, and team workflow. The tools listed here are optimized for
    Go-based services and local-first benchmarking, but they’re just a starting point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一份详尽的列表。负载测试工具的生态系统很广泛，并且不断演变。像 Apache JMeter、Locust、Artillery 和 Gatling
    这样的工具各自带来了自己的优势——从基于 UI 的测试设计到分布式执行或 JVM 基于的场景。正确的选择取决于你的堆栈、测试目标和团队工作流程。这里列出的工具针对基于
    Go 的服务和本地优先基准测试进行了优化，但它们只是起点。
- en: At a glance, `vegeta`, `wrk`, and `k6` all hammer HTTP endpoints. But they serve
    different roles depending on what you're testing, how much precision you need,
    and how complex your scenario is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼望去，`vegeta`、`wrk` 和 `k6` 都在打击 HTTP 端点。但它们根据你测试的内容、所需的精度以及场景的复杂程度扮演着不同的角色。
- en: '| Tool | Focus | Scriptable | Metrics Depth | Ideal Use Case |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 侧重 | 可脚本化 | 指标深度 | 理想用例 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `vegeta` | Constant rate load generation | No (but composable) | High (histogram,
    percentiles) | Tracking latency percentiles over time; CI benchmarking |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `vegeta` | 恒定速率负载生成 | 否（但可组合） | 高（直方图、百分位数） | 跟踪随时间变化的延迟百分位数；CI 基准测试 |'
- en: '| `wrk` | Max throughput stress tests | Yes (Lua) | Medium | Measuring raw
    server capacity and concurrency limits |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `wrk` | 最大吞吐量压力测试 | 是（Lua） | 中等 | 测量原始服务器容量和并发限制 |'
- en: '| `k6` | Scenario-based simulation | Yes (JavaScript) | High (VU metrics, dashboards)
    | Simulating real-world user workflows and pacing |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `k6` | 基于场景的模拟 | 是（JavaScript） | 高（VU 指标、仪表板） | 模拟现实世界用户工作流程和节奏 |'
- en: 'Use `vegeta` when:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vegeta` 的情况：
- en: You need a consistent RPS load (e.g., 100 requests/sec for the 60s).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个一致的 RPS 负载（例如，60 秒内每秒 100 个请求）。
- en: You're observing latency degradation under controlled pressure.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在可控的压力下观察延迟下降。
- en: You want structured output (histograms, percentiles) for profiling.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要结构化的输出（直方图、百分位数）以进行性能分析。
- en: You want to verify local changes before deeper profiling.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在更深入的剖析之前验证本地更改。
- en: 'Use `wrk` when:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wrk` 的情况：
- en: You're exploring upper-bound throughput.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在探索上限吞吐量。
- en: You want raw, fast load with minimal setup.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要原始、快速的负载，设置最少。
- en: You’re profiling at high concurrency (e.g., 10k connections).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在高并发（例如，10k 个连接）下进行剖析。
- en: 'Use `k6` when:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `k6` 的情况：
- en: You must model complex flows like login → API call → wait → logout.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须模拟复杂的流程，如登录 → API 调用 → 等待 → 注销。
- en: You’re integrating performance tests into CI/CD.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在将性能测试集成到 CI/CD 中。
- en: You want thresholds, pacing, and visual feedback.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要阈值、节奏和视觉反馈。
- en: Each of these tools has a place in your benchmarking toolkit. Picking the right
    one depends on whether you're validating performance, exploring scaling thresholds,
    or simulating end-user behavior.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的每一个都在您的基准测试工具包中都有其位置。选择正确的工具取决于您是在验证性能、探索扩展阈值还是模拟最终用户行为。
- en: Vegeta
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vegeta
- en: '[Vegeta](https://github.com/tsenart/vegeta) is a flexible HTTP load testing
    tool written in Go, built for generating constant request rates. This makes it
    well-suited for simulating steady, sustained traffic patterns instead of sudden
    spikes.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vegeta](https://github.com/tsenart/vegeta) 是一个用Go编写的灵活的HTTP负载测试工具，用于生成恒定的请求速率。这使得它非常适合模拟稳定的、持续的流量模式，而不是突然的峰值。'
- en: We reach for Vegeta when precision matters. It maintains exact request rates
    and captures detailed latency distributions, which helps track how system behavior
    changes under load. It’s lightweight, easy to automate, and integrates cleanly
    into CI workflows—making it a reliable option for benchmarking Go services.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要精确度时，我们会选择Vegeta。它保持精确的请求速率并捕获详细的延迟分布，这有助于跟踪系统在负载下的行为变化。它轻量级，易于自动化，并且可以干净地集成到CI工作流程中——使其成为基准测试Go服务的可靠选择。
- en: 'Install:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Which endpoint(s) we are going to test:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试哪个端点：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <details class="example"><summary>Potential output</summary>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>潜在输出</summary>
- en: '[PRE5]</details>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]</details>'
- en: 'View percentiles:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看百分位数：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Generate chart:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生成图表：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <details class="info"><summary>Testing Multiple Endpoints with Vegeta</summary>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="info"><summary>使用Vegeta测试多个端点</summary>
- en: Depending on your goals, there are two recommended approaches for testing both
    `/fast` and `/slow` endpoints in a single run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的目标，有两种推荐的测试方法，可以在单次运行中测试 `/fast` 和 `/slow` 端点。
- en: '**Option 1: Round-Robin Between Endpoints**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项1：端点间的轮询**'
- en: 'Create a `targets.txt` with both endpoints:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含两个端点的 `targets.txt` 文件：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the test:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Requests are randomly distributed between the two endpoints.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求在两个端点之间随机分布。
- en: Useful for observing aggregate behavior of mixed traffic.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于观察混合流量的总体行为。
- en: Easy to set up and analyze combined performance.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于设置和分析组合性能。
- en: '**Option 2: Weighted Mix Using Multiple Vegeta Runs**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项2：使用多个Vegeta运行进行加权混合**'
- en: 'To simulate different traffic proportions (e.g., 80% fast, 20% slow):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟不同的流量比例（例如，80%快速，20%慢速）：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then merge the results and generate a report:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将结果合并并生成报告：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Gives you precise control over traffic distribution.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对流量分布的精确控制。
- en: Better for simulating realistic traffic mixes.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更适合模拟真实的流量混合。
- en: Enables per-endpoint benchmarking when analyzed separately.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当单独分析时，允许每个端点的基准测试。
- en: Both methods are valid—choose based on whether you need simplicity or control.</details>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是有效的——根据您是否需要简单性或控制来选择。</details>
- en: wrk
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wrk
- en: '[wrk](https://github.com/wg/wrk) is a high-performance HTTP benchmarking tool
    written in C. It''s designed for raw speed and concurrency, making it ideal for
    stress testing your server’s throughput and connection handling capacity.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[wrk](https://github.com/wg/wrk) 是一个用C编写的性能高效的HTTP基准测试工具。它旨在提供原始速度和并发性，使其非常适合压力测试服务器的吞吐量和连接处理能力。'
- en: We use `wrk` when we want to push the system to its upper limits. It excels
    at flooding endpoints with high request volumes using multiple threads and connections.
    While it doesn’t offer detailed percentiles like `vegeta`, it's perfect for quick
    saturation tests and measuring how much traffic your Go server can handle before
    it starts dropping requests or stalling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将系统推到其极限时，我们会使用 `wrk`。它擅长使用多个线程和连接向端点发送高请求量。虽然它不像 `vegeta` 那样提供详细的百分位数，但它非常适合快速饱和测试和测量Go服务器在开始丢弃请求或停滞之前可以处理多少流量。
- en: 'Install:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <details class="example"><summary>Potential output</summary>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>潜在输出</summary>
- en: '[PRE14]</details>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]</details>'
- en: k6
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: k6
- en: '[k6](https://k6.io) is a modern load testing tool built around scripting realistic
    client behavior in JavaScript. It’s designed for simulating time-based load profiles—ramp-up,
    steady-state, ramp-down—and supports custom flows, pacing, and threshold-based
    validation.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[k6](https://k6.io) 是一个围绕在JavaScript中编写现实客户行为的现代负载测试工具。它旨在模拟基于时间的负载配置文件——上升、稳态、下降——并支持自定义流程、节奏和基于阈值的验证。'
- en: We use `k6` when raw throughput isn’t enough and we need to simulate how real
    users interact with the system. It handles chained requests, models session-like
    flows, and supports stage-based testing out of the box. With rich metrics and
    seamless CI/CD integration, `k6` helps surface regressions before they reach production.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始吞吐量不足且需要模拟真实用户与系统交互时，我们使用 `k6`。它处理链式请求，模拟会话式流程，并支持开箱即用的基于阶段的测试。凭借丰富的指标和无缝的
    CI/CD 集成，`k6` 有助于在生产之前揭示回归。
- en: 'Install:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <details class="example"><summary>Potential output</summary>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>潜在输出</summary>
- en: '[PRE18]</details>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]</details>'
- en: Profiling Networked Go Applications with `pprof`
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `pprof` 分析网络化 Go 应用程序
- en: 'Profiling Go applications that heavily utilize networking is crucial to identifying
    and resolving bottlenecks that impact performance under high-traffic scenarios.
    Go''s built-in `net/http/pprof` package provides insights specifically beneficial
    for network-heavy operations. Set up continuous profiling by enabling an HTTP
    endpoint:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 分析大量使用网络的 Go 应用程序至关重要，这有助于识别和解决在高流量场景下影响性能的瓶颈。Go 内置的 `net/http/pprof` 包提供了针对网络密集型操作特别有益的见解。通过启用
    HTTP 端点设置持续分析：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s possible to inspect the application in real time, even under heavy load.
    To capture a CPU profile:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在实时状态下检查应用程序，即使在重负载下也是如此。要捕获 CPU 配置文件：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This grabs a 30-second snapshot of CPU usage. With the `pprof` HTTP server exposed,
    all runtime data—CPU, memory, goroutines, contention, flamegraphs—is available
    without pausing or restarting the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这会捕获 CPU 使用情况的 30 秒快照。通过暴露 `pprof` HTTP 服务器，所有运行时数据——CPU、内存、goroutines、竞争、火焰图——都可在不暂停或重新启动应用程序的情况下获得。
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: the actual `cpu.prof` path will be something like `$HOME/pprof/pprof.net-app.samples.cpu.004.pb.gz`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的 `cpu.prof` 路径可能类似于 `$HOME/pprof/pprof.net-app.samples.cpu.004.pb.gz`
- en: CPU Profiling
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU 分析
- en: Profiling a system at rest rarely tells the full story. Real bottlenecks show
    up under pressure—when requests stack up, threads compete, and memory churn increases.
    CPU profiling during load reveals where execution time concentrates, often exposing
    slow serialization, inefficient handler logic, or contention between goroutines.
    These are the paths that quietly limit throughput and inflate latency when traffic
    scales.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态系统中进行性能分析很少能讲出全部故事。真正的瓶颈在压力下出现——当请求堆积，线程竞争，内存碎片增加时。在负载期间进行 CPU 分析揭示了执行时间集中的地方，通常暴露出缓慢的序列化、低效的处理逻辑或
    goroutines 之间的竞争。这些路径在流量扩展时默默地限制了吞吐量并增加了延迟。
- en: What to Look For
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要查找的内容
- en: 'Network Serialization Hotspots: Frequent use of `json.Marshal` or similar serialization
    methods during network response generation.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络序列化热点：在网络响应生成期间频繁使用 `json.Marshal` 或类似的序列化方法。
- en: 'Syscall Overhead: Extensive syscall usage (e.g., `syscall.Read`) suggesting
    inefficient socket handling or excessive blocking I/O.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用开销：广泛的系统调用使用（例如，`syscall.Read`）表明不高效的套接字处理或过度的阻塞 I/O。
- en: 'GC Activity: High frequency of `runtime.gc` indicating inefficient memory management
    impacting response latency.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC 活动：`runtime.gc` 高频率表明不高效的内存管理影响了响应延迟。
- en: '**Why This Matters:** Identifying and optimizing CPU-intensive operations in
    networking contexts reduces latency, boosts throughput, and improves reliability
    during traffic spikes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要：**在联网环境中识别和优化 CPU 密集型操作可以减少延迟，提高吞吐量，并在流量高峰期间提高可靠性。'
- en: Flamegraphs
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 火焰图
- en: Flamegraphs provide a visual summary of where CPU time is spent by aggregating
    and collapsing stack traces into a single view. They make it easy to identify
    performance hotspots without digging through raw profiling data. In server applications,
    this often highlights issues in request handling, serialization, or blocking I/O.
    Under load, flamegraphs are especially useful for catching subtle inefficiencies
    that scale into major performance problems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图通过聚合和折叠堆栈跟踪到一个单一视图中，提供了 CPU 时间花费的视觉摘要。它们使得在不深入原始性能分析数据的情况下轻松识别性能热点。在服务器应用程序中，这通常突出了请求处理、序列化或阻塞
    I/O 中的问题。在负载下，火焰图特别有用于捕捉到微小的低效性，这些低效性在扩展到主要性能问题时变得明显。
- en: What to Look For
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要查找的内容
- en: Functions related to network I/O or data transfer that appear as wide blocks
    in a flamegraph often point to excessive time spent on serialization, buffering,
    or socket operations.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在火焰图中表现为宽块的与网络 I/O 或数据传输相关的函数通常指向在序列化、缓冲或套接字操作上花费过多时间。
- en: Deep Call Chains Deep stacks could reveal inefficient middleware or unnecessary
    layers in network request handling.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层调用链 深层堆栈可能揭示不高效的中间件或网络请求处理中不必要的层。
- en: Unexpected Paths Look for unexpected serialization, reflection, or routing inefficiencies.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外路径 寻找意外的序列化、反射或路由效率低下。
- en: '**Why This Matters:** Flamegraphs simplify diagnosing complex inefficiencies
    visually, leading to quicker optimization and reduced downtime.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要**：火焰图简化了复杂效率问题的视觉诊断，从而加快了优化并减少了停机时间。'
- en: Managing Garbage Collection (GC) Pressure
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理垃圾收集（GC）压力
- en: Memory profiling helps identify where your application is wasting heap space,
    especially in network-heavy code paths. Common issues include repeated allocation
    of response buffers, temporary objects, or excessive use of slices and maps. These
    patterns often go unnoticed until they trigger GC pressure or latency under load.
    Profiling with `pprof` follows the same basic steps as CPU profiling, making it
    easy to integrate into your existing workflow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析有助于确定您的应用程序在哪里浪费堆空间，尤其是在网络密集型代码路径中。常见问题包括重复分配响应缓冲区、临时对象或过度使用切片和映射。这些模式通常直到触发
    GC 压力或负载下的延迟才会被发现。使用 `pprof` 进行分析遵循与 CPU 分析相同的基本步骤，使其易于集成到现有的工作流程中。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, again, you can view results interactively.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次，您可以交互式地查看结果。
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: the actual `mem.prof` path will be something like `$HOME/pprof/pprof.net-app.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz`
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的 `mem.prof` 路径可能类似于 `$HOME/pprof/pprof.net-app.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz`
- en: What to Look For
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需要关注的内容
- en: 'Frequent Temporary Buffers: High frequency of allocations in network buffers,
    such as repeatedly creating byte slices for each request.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁的临时缓冲区：网络缓冲区中分配的高频率，例如为每个请求重复创建字节切片。
- en: 'Persistent Network Objects: Accumulation of long-lived network connections
    or sessions.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久网络对象：长期存在的网络连接或会话的积累。
- en: 'Excessive Serialization Overhead: High object creation rate due to repeated
    encoding/decoding of network payloads.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度的序列化开销：由于重复编码/解码网络有效负载而导致的高对象创建率。
- en: 'Example: Optimizing buffer reuse using `sync.Pool` greatly reduces GC pressure
    during high-volume network operations.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：通过使用 `sync.Pool` 优化缓冲区重用，在大量网络操作期间大大减少了 GC 压力。
- en: '**Why This Matters:** Reducing memory churn from network activities improves
    response times and minimizes latency spikes caused by GC.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要**：减少网络活动引起的内存 churn 可以提高响应时间并最小化由 GC 引起的延迟峰值。'
- en: Identifying CPU Bottlenecks
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别 CPU 瓶颈
- en: Networked applications often hit CPU limits first when pushed under sustained
    load. Profiling helps surface where time is actually being spent and what’s getting
    in the way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序在持续负载下通常首先遇到 CPU 限制。分析有助于揭示实际花费时间和阻碍的因素。
- en: What to Look For
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需要关注的内容
- en: 'Latency Rising While Throughput Stalls: A sign the CPU is saturated, often
    from request processing or serialization overhead.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当吞吐量停滞时延迟上升：这是 CPU 过载的迹象，通常来自请求处理或序列化开销。
- en: 'Scheduler Overhead (runtime.schedule, mcall): Too many goroutines can overwhelm
    the scheduler, especially when each connection gets its own handler.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度开销（runtime.schedule, mcall）：过多的 goroutines 可能会压倒调度器，尤其是在每个连接都有自己的处理器时。
- en: 'Lock Contention: Repeated locking on shared network state or blocking channel
    operations slows down throughput and limits parallelism.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁竞争：在共享网络状态或阻塞通道操作上重复加锁会降低吞吐量并限制并行性。
- en: For example, if profiling shows excessive time spent in TLS handshake routines,
    the fix might involve moving handshakes off the hot path or reducing handshake
    frequency with connection reuse.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果分析显示在 TLS 握手例程中花费了过多时间，修复可能涉及将握手从热点路径移除或通过连接重用减少握手频率。
- en: '**Why it matters:** CPU bottlenecks cap your ability to scale. Fixing them
    is often the difference between a system that handles 5K clients and one that
    handles 50K.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要**：CPU 瓶颈限制了您的扩展能力。修复它们通常是处理 5K 客户端和 50K 客户端之间的区别。'
- en: Practicle example of Profiling Networked Go Applications with `pprof`
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `pprof` 分析网络 Go 应用程序的实用示例
- en: To illustrate these concepts practically, our demo application integrates profiling
    and benchmarking tools and provides comprehensive profiling and load testing scenarios.
    The demo covers identifying performance bottlenecks, analyzing flame graphs, and
    benchmarking under various simulated network conditions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际说明这些概念，我们的演示应用程序集成了性能分析和基准测试工具，并提供了全面的性能分析和负载测试场景。演示涵盖了识别性能瓶颈、分析火焰图以及在各种模拟网络条件下的基准测试。
- en: Due to its significant size, [Practicle example of Profiling Networked Go Applications
    with `prof`](../gc-endpoint-profiling/) is a separate article.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其显著的大小，[使用`prof`对网络Go应用程序进行性能分析的实用示例](../gc-endpoint-profiling/)是一篇单独的文章。
- en: Benchmarking as a Feedback Loop
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为反馈循环的基准测试
- en: A single load test run means little in isolation. But if you treat benchmarking
    as part of your development cycle—before and after changes—you start building
    a performance narrative. You can see exactly how a change impacted throughput
    or whether it traded latency for memory overhead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单独进行一次负载测试运行意义不大。但如果你将基准测试视为开发周期的一部分——在更改前后——你开始构建性能叙事。你可以确切地看到更改是如何影响吞吐量，或者它是如何以内存开销为代价换取延迟的。
- en: The Go standard library gives you `testing.B` for microbenchmarks. Combine profiling
    with robust integration testing as part of your CI/CD pipeline using tools like
    `Vegeta` and `k6`. This practice ensures early detection of regressions, continuous
    validation of performance enhancements, and reliable application performance maintenance
    under realistic production conditions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了`testing.B`用于微基准测试。结合使用`Vegeta`和`k6`等工具，将性能分析与稳健的集成测试作为CI/CD管道的一部分，这确保了早期检测回归、持续验证性能改进，并在实际生产条件下可靠地维护应用程序性能。
