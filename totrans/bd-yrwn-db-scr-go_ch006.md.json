["```go\n[](#cb1-1)// insert a new key or update an existing key\n[](#cb1-2)func (tree *BTree) Insert(key []byte, val []byte)\n[](#cb1-3)// delete a key and returns whether the key was there\n[](#cb1-4)func (tree *BTree) Delete(key []byte) bool\n```", "```go\n[](#cb2-1)func (tree *BTree) Insert(key []byte, val []byte) {\n[](#cb2-2)    if tree.root == 0 {\n[](#cb2-3)        // create the first node\n[](#cb2-4)        root := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb2-5)        root.setHeader(BNODE_LEAF, 2)\n[](#cb2-6)        // a dummy key, this makes the tree cover the whole key space.\n[](#cb2-7)        // thus a lookup can always find a containing node.\n[](#cb2-8)        nodeAppendKV(root, 0, 0, nil, nil)\n[](#cb2-9)        nodeAppendKV(root, 1, 0, key, val)\n[](#cb2-10)        tree.root = tree.new(root)\n[](#cb2-11)        return\n[](#cb2-12)    }\n[](#cb2-13)\n[](#cb2-14)    node := treeInsert(tree, tree.get(tree.root), key, val)\n[](#cb2-15)    nsplit, split := nodeSplit3(node)\n[](#cb2-16)    tree.del(tree.root)\n[](#cb2-17)    if nsplit > 1 {\n[](#cb2-18)        // the root was split, add a new level.\n[](#cb2-19)        root := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb2-20)        root.setHeader(BNODE_NODE, nsplit)\n[](#cb2-21)        for i, knode := range split[:nsplit] {\n[](#cb2-22)            ptr, key := tree.new(knode), knode.getKey(0)\n[](#cb2-23)            nodeAppendKV(root, uint16(i), ptr, key, nil)\n[](#cb2-24)        }\n[](#cb2-25)        tree.root = tree.new(root)\n[](#cb2-26)    } else {\n[](#cb2-27)        tree.root = tree.new(split[0])\n[](#cb2-28)    }\n[](#cb2-29)}\n```", "```go\n[](#cb3-1)// remove a key from a leaf node\n[](#cb3-2)func leafDelete(new BNode, old BNode, idx uint16)\n[](#cb3-3)// merge 2 nodes into 1\n[](#cb3-4)func nodeMerge(new BNode, left BNode, right BNode)\n[](#cb3-5)// replace 2 adjacent links with 1\n[](#cb3-6)func nodeReplace2Kid(\n[](#cb3-7)    new BNode, old BNode, idx uint16, ptr uint64, key []byte,\n[](#cb3-8))\n```", "```go\n[](#cb4-1)// should the updated kid be merged with a sibling?\n[](#cb4-2)func shouldMerge(\n[](#cb4-3)    tree *BTree, node BNode,\n[](#cb4-4)    idx uint16, updated BNode,\n[](#cb4-5)) (int, BNode) {\n[](#cb4-6)    if updated.nbytes() > BTREE_PAGE_SIZE/4 {\n[](#cb4-7)        return 0, BNode{}\n[](#cb4-8)    }\n[](#cb4-9)\n[](#cb4-10)    if idx > 0 {\n[](#cb4-11)        sibling := BNode(tree.get(node.getPtr(idx - 1)))\n[](#cb4-12)        merged := sibling.nbytes() + updated.nbytes() - HEADER\n[](#cb4-13)        if merged <= BTREE_PAGE_SIZE {\n[](#cb4-14)            return -1, sibling // left\n[](#cb4-15)        }\n[](#cb4-16)    }\n[](#cb4-17)    if idx+1 < node.nkeys() {\n[](#cb4-18)        sibling := BNode(tree.get(node.getPtr(idx + 1)))\n[](#cb4-19)        merged := sibling.nbytes() + updated.nbytes() - HEADER\n[](#cb4-20)        if merged <= BTREE_PAGE_SIZE {\n[](#cb4-21)            return +1, sibling // right\n[](#cb4-22)        }\n[](#cb4-23)    }\n[](#cb4-24)    return 0, BNode{}\n[](#cb4-25)}\n```", "```go\n[](#cb5-1)// delete a key from the tree\n[](#cb5-2)func treeDelete(tree *BTree, node BNode, key []byte) BNode\n[](#cb5-3)\n[](#cb5-4)// delete a key from an internal node; part of the treeDelete()\n[](#cb5-5)func nodeDelete(tree *BTree, node BNode, idx uint16, key []byte) BNode {\n[](#cb5-6)    // recurse into the kid\n[](#cb5-7)    kptr := node.getPtr(idx)\n[](#cb5-8)    updated := treeDelete(tree, tree.get(kptr), key)\n[](#cb5-9)    if len(updated) == 0 {\n[](#cb5-10)        return BNode{} // not found\n[](#cb5-11)    }\n[](#cb5-12)    tree.del(kptr)\n[](#cb5-13)\n[](#cb5-14)    new := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb5-15)    // check for merging\n[](#cb5-16)    mergeDir, sibling := shouldMerge(tree, node, idx, updated)\n[](#cb5-17)    switch {\n[](#cb5-18)    case mergeDir < 0: // left\n[](#cb5-19)        merged := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb5-20)        nodeMerge(merged, sibling, updated)\n[](#cb5-21)        tree.del(node.getPtr(idx - 1))\n[](#cb5-22)        nodeReplace2Kid(new, node, idx-1, tree.new(merged), merged.getKey(0))\n[](#cb5-23)    case mergeDir > 0: // right\n[](#cb5-24)        merged := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb5-25)        nodeMerge(merged, updated, sibling)\n[](#cb5-26)        tree.del(node.getPtr(idx + 1))\n[](#cb5-27)        nodeReplace2Kid(new, node, idx, tree.new(merged), merged.getKey(0))\n[](#cb5-28)    case mergeDir == 0 && updated.nkeys() == 0:\n[](#cb5-29)        assert(node.nkeys() == 1 && idx == 0) // 1 empty child but no sibling\n[](#cb5-30)        new.setHeader(BNODE_NODE, 0)          // the parent becomes empty too\n[](#cb5-31)    case mergeDir == 0 && updated.nkeys() > 0: // no merge\n[](#cb5-32)        nodeReplaceKidN(tree, new, node, idx, updated)\n[](#cb5-33)    }\n[](#cb5-34)    return new\n[](#cb5-35)}\n```", "```go\n[](#cb6-1)type C struct {\n[](#cb6-2)    tree  BTree\n[](#cb6-3)    ref   map[string]string // the reference data\n[](#cb6-4)    pages map[uint64]BNode  // in-memory pages\n[](#cb6-5)}\n[](#cb6-6)\n[](#cb6-7)func newC() *C {\n[](#cb6-8)    pages := map[uint64]BNode{}\n[](#cb6-9)    return &C{\n[](#cb6-10)        tree: BTree{\n[](#cb6-11)            get: func(ptr uint64) []byte {\n[](#cb6-12)                node, ok := pages[ptr]\n[](#cb6-13)                assert(ok)\n[](#cb6-14)                return node\n[](#cb6-15)            },\n[](#cb6-16)            new: func(node []byte) uint64 {\n[](#cb6-17)                assert(BNode(node).nbytes() <= BTREE_PAGE_SIZE)\n[](#cb6-18)                ptr := uint64(uintptr(unsafe.Pointer(&node[0])))\n[](#cb6-19)                assert(pages[ptr] == nil)\n[](#cb6-20)                pages[ptr] = node\n[](#cb6-21)                return ptr\n[](#cb6-22)            },\n[](#cb6-23)            del: func(ptr uint64) {\n[](#cb6-24)                assert(pages[ptr] != nil)\n[](#cb6-25)                delete(pages, ptr)\n[](#cb6-26)            },\n[](#cb6-27)        },\n[](#cb6-28)        ref:   map[string]string{},\n[](#cb6-29)        pages: pages,\n[](#cb6-30)    }\n[](#cb6-31)}\n```", "```go\n[](#cb7-1)func (c *C) add(key string, val string) {\n[](#cb7-2)    c.tree.Insert([]byte(key), []byte(val))\n[](#cb7-3)    c.ref[key] = val // reference data\n[](#cb7-4)}\n```"]