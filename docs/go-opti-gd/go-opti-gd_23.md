# Go 中的实用网络模式[]

> 原文：[`goperf.dev/02-networking/`](https://goperf.dev/02-networking/)

一份 13 部分指南，介绍如何在 Go 中构建可扩展、高效和弹性的网络应用程序——基于实际基准测试、底层优化和实用设计模式。

* * *

## 基准测试优先

+   网络 Go 应用的基准测试和负载测试

    在优化任何内容之前建立性能基线。学习如何使用 `vegeta`、`wrk` 和 `k6` 等工具模拟真实流量。涵盖吞吐量、延迟百分位数、连接并发性和负载下的分析。为诊断瓶颈和衡量系列中每个优化的影响奠定基础。

* * *

## 基础和核心概念

+   Go 如何处理网络：并发、goroutines 和 net 包

    从底层了解 Go 的网络方法。涵盖 goroutines、`net`包和运行时调度器的交互，包括阻塞 I/O 行为、连接处理以及底层的 `epoll` 或 `kqueue` 等轮询器的使用。

+   高效使用 `net/http`, `net.Conn` 和 UDP

    比较 `net/http` 与原始 `net.Conn` 的惯用和高级用法。深入了解连接池、自定义拨号器、流重用和缓冲区调整。演示如何避免常见的陷阱，如泄漏连接、阻塞处理程序或过度分配缓冲区。

* * *

## 扩展和性能工程

+   在 Go 中管理 10K++并发连接

    处理大量并发需要有意向的架构。探索如何使用 Go 的 goroutines、适当的资源限制、套接字调整和运行时配置高效地服务 10,000+并发套接字。重点关注连接生命周期、扩展陷阱和实际调整。

+   GOMAXPROCS, epoll/kqueue 和调度器级别调整

    深入了解低级性能旋钮，如 `GOMAXPROCS`、`GODEBUG`、线程绑定以及 Go 的调度器如何与 epoll/kqueue 交互。了解何时增加并行性有帮助——何时没有。包括用于 CPU 亲和力和基准测试这些更改影响的工具。

* * *

## 诊断和弹性

+   使用负载卸载和背压构建弹性连接处理

    学习如何防止过载导致系统崩溃。涵盖断路器、被动与主动负载卸载、使用通道缓冲和超时的时间背压策略，以及在压力下优雅地拒绝或降级请求。

+   长时间连接中的内存管理和泄漏预防

    长期连接，如 WebSockets 或 TCP 流，可能会缓慢泄漏内存或积累 goroutines。本文展示了如何识别常见的泄漏、强制执行读写截止日期、管理背压，并使用内存配置文件追踪堆增长。

* * *

## 传输层优化

+   在 Go 中比较 TCP、HTTP/2 和 gRPC 性能

    在 Go 中基准测试和分析不同的传输协议：原始 TCP 带有自定义帧，通过`net/http`的 HTTP/2，以及 gRPC。评估真实场景（如内部 API、消息系统和微服务）中的延迟、吞吐量、连接重用和 CPU/内存成本。

+   Go 中的 QUIC：使用 quic-go 构建低延迟服务

    探索 QUIC 作为实时和以移动优先系统的下一代传输。介绍`quic-go`库，演示安全多路复用流的设置，并与 HTTP/2 和 TCP 比较性能。还涵盖连接迁移和 0-RTT 以实现快速启动。

* * *

## 低级和高级调整

+   低级网络优化：重要的套接字选项

    探索高级套接字级别调整选项，如禁用 Nagle 算法（`TCP_NODELAY`）、调整`SO_REUSEPORT`、`SO_RCVBUF`/`SO_SNDBUF`、TCP 保活和连接队列（`SOMAXCONN`）。解释 Go 如何通过`syscall`暴露这些选项，以及如何安全地包装它们。包括针对延迟敏感系统和高吞吐量服务的真实世界示例。

+   在 Go 服务中调整 DNS 性能

    DNS 查找通常被忽视，作为延迟的罪魁祸首。学习 Go 如何执行名称解析（cgo 与 Go 解析器），何时缓存结果，以及如何使用自定义拨号器或预解析的 IP 来避免不可靠的网络路径。包括针对真实世界 DNS 缓慢的指标和调试技巧。

+   优化 TLS 以提高速度：握手、重用和加密选择

    TLS 增加了安全性，但它也可能增加开销。调整您的 Go 服务以实现快速安全的 TLS：启用会话恢复、选择快速加密套件、明智地使用 ALPN 协商，并最小化证书验证成本。包括使用`tls.Config`最佳实践的示例。

+   连接生命周期可观察性：从拨号到关闭

    跟踪连接的完整生命周期，并在每个阶段（DNS、拨号、握手、协商、读写和断开连接）保持可见性。学习如何记录连接跨度、追踪挂起、将错误与性能指标关联起来，并将自定义可观察性构建到网络流中。
