- en: Go 中的高效缓冲
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/01-common-patterns/buffered-io/](https://goperf.dev/01-common-patterns/buffered-io/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 缓冲是系统编程中的核心性能技术。在 Go 中，它与处理 I/O（文件访问、网络通信和流处理）特别相关。没有缓冲，许多操作会引发过多的系统调用或同步开销。适当的缓冲可以减少此类交互的频率，提高吞吐量，并平滑延迟峰值。
  prefs: []
  type: TYPE_NORMAL
- en: 为什么缓冲很重要[¶](#why-buffering-matters "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 每次你从文件或套接字读取或写入时，都有很大可能触发系统调用——而这并不便宜。系统调用将控制从用户空间移动到内核空间，这意味着跨越一个带有开销的边界：进入内核模式、可能的上下文切换、与
    I/O 缓冲区交互，有时在后台排队操作。偶尔这样做是可以的。每秒做几千次？那就成问题了。缓冲通过将小读取或写入批处理到更大的块中，减少了你跨越该边界的频率，并使每个系统调用得到更好的利用。
  prefs: []
  type: TYPE_NORMAL
- en: 例如，在不使用缓冲的情况下循环写入文件，如下所示：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: f, _ := os.Create("output.txt")
  prefs: []
  type: TYPE_NORMAL
- en: for i := 0; i < 10000; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: f.Write([]byte("line\n"))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这很容易导致 **10,000 次单独的系统调用**，每个调用都有自己的开销，并拖慢性能。除此之外，大量的小写入操作往往会碎片化磁盘操作，这给 I/O
    子系统带来额外的压力，并浪费 CPU 周期来处理本可以作为一个高效批次的操作。
  prefs: []
  type: TYPE_NORMAL
- en: 使用缓冲[¶](#with-buffering "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: f, _ := os.Create("output.txt")
  prefs: []
  type: TYPE_NORMAL
- en: buf := bufio.NewWriter(f)
  prefs: []
  type: TYPE_NORMAL
- en: for i := 0; i < 10000; i++ {
  prefs: []
  type: TYPE_NORMAL
- en: buf.WriteString("line\n")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: buf.Flush() // ensure all buffered data is written
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这个版本显著减少了系统调用的次数。`bufio.Writer` 在内部内存缓冲区（通常是 4KB 或更多）中累积写入操作。只有当缓冲区满或显式刷新时，才会触发系统调用。因此，你可以实现更快的
    I/O、降低 CPU 使用率，并提高性能。
  prefs: []
  type: TYPE_NORMAL
- en: 注意
  prefs: []
  type: TYPE_NORMAL
- en: '`bufio.Writer` 在关闭时不会自动刷新。如果你忘记调用 `Flush()`，缓冲区中剩余的任何未写入数据都将丢失。在关闭或从函数返回之前，始终调用
    `Flush()`，特别是如果总写入大小小于缓冲区容量时。'
  prefs: []
  type: TYPE_NORMAL
- en: 控制缓冲区容量[¶](#controlling-buffer-capacity "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 默认情况下，`bufio.NewWriter()` 分配一个 4096 字节（4 KB）的缓冲区。这个大小与文件系统的常见块大小以及大多数操作系统（如
    Linux、BSD 和 macOS）的标准内存页面大小相匹配。以 4 KB 为增量进行读写可以最小化页面错误，与内核预读策略相匹配，并有效地映射到底层的磁盘
    I/O 操作。
  prefs: []
  type: TYPE_NORMAL
- en: 虽然 4 KB 是一个实用的通用默认值，但它可能不是所有工作负载的最佳选择。对于高吞吐量场景——例如流式传输大文件或生成大量日志——更大的缓冲区可以帮助进一步减少系统调用频率：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: f, _ := os.Create("output.txt")
  prefs: []
  type: TYPE_NORMAL
- en: buf := bufio.NewWriterSize(f, 16*1024) // 16 KB buffer
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 相反，如果延迟比吞吐量更重要（例如，交互式系统或命令行工具），则较小的缓冲区可能更合适，因为它更频繁地刷新数据。
  prefs: []
  type: TYPE_NORMAL
- en: 当读取数据时，类似的逻辑也适用：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: reader := bufio.NewReaderSize(f, 32*1024) // 32 KB buffer for input
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 缓冲区大小不是猜测的事情——它是需要测量的。理想的大小取决于太多的变量，无法硬编码：你是在写入SSD还是旋转磁盘，你的文件系统如何缓冲写入，有多少CPU缓存可用，以及系统上还有哪些资源在竞争。分析和基准测试是唯一可靠的调整方法。在一个设置上效果很好的方法可能在另一个设置上不是最优的——甚至可能是有害的。
  prefs: []
  type: TYPE_NORMAL
- en: '[基准测试影响](#benchmarking-impact "永久链接")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 在负载下，缓冲的读写操作始终显示出显著的性能提升。衡量系统调用、内存分配和CPU使用的基准测试通常显示，缓冲I/O操作比非缓冲操作更快、更高效。例如，将一百万行写入磁盘可能比直接调用`os.File.Write()`快一个数量级。你的I/O操作越有结构和突发性，缓冲带来的好处就越大。
  prefs: []
  type: TYPE_NORMAL
- en: <details class="example"><summary>显示基准测试文件</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: package perf
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"bufio"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"io"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"os"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"strconv"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"sync"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"testing"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: type Data struct {
  prefs: []
  type: TYPE_NORMAL
- en: Value []byte
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: var dataPool = sync.Pool{
  prefs: []
  type: TYPE_NORMAL
- en: 'New: func() any {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return &Data{Value: make([]byte, 0, 32)}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: const N = 10000
  prefs: []
  type: TYPE_NORMAL
- en: func writeNotBuffered(w io.Writer, count int) {
  prefs: []
  type: TYPE_NORMAL
- en: for i := 0; i < count; i++ {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d := dataPool.Get().(*Data)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.Value = strconv.AppendInt(d.Value[:0], int64(i), 10)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: w.Write(d.Value)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: w.Write([]byte(":val\n"))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dataPool.Put(d)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func writeBuffered(w io.Writer, count int) {
  prefs: []
  type: TYPE_NORMAL
- en: buf := bufio.NewWriterSize(w, 16*1024)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for i := 0; i < count; i++ {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d := dataPool.Get().(*Data)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: d.Value = strconv.AppendInt(d.Value[:0], int64(i), 10)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: buf.Write(d.Value)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: buf.Write([]byte(":val\n"))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dataPool.Put(d)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: buf.Flush()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func BenchmarkWriteNotBuffered(b *testing.B) {
  prefs: []
  type: TYPE_NORMAL
- en: for b.Loop() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f, _ := os.CreateTemp("", "nobuf")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: writeNotBuffered(f, N)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: f.Close()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: os.Remove(f.Name())
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func BenchmarkWriteBuffered(b *testing.B) {
  prefs: []
  type: TYPE_NORMAL
- en: for b.Loop() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f, _ := os.CreateTemp("", "buf")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: writeBuffered(f, N)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: f.Close()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: os.Remove(f.Name())
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 结果：
  prefs: []
  type: TYPE_NORMAL
- en: '| 基准测试 | 迭代次数 | 每次操作时间 (ns) | 每次操作字节数 | 每次操作分配数 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| BenchmarkWriteNotBuffered-14 | 49 | 23,672,792 | 53,773 | 10,007 |'
  prefs: []
  type: TYPE_TB
- en: '| BenchmarkWriteBuffered-14 | 3241 | 379,703 | 70,127 | 10,008 |'
  prefs: []
  type: TYPE_TB
- en: '[何时进行缓冲](#when-to-buffer "永久链接")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 在以下情况下使用缓冲：
  prefs: []
  type: TYPE_NORMAL
- en: 执行频繁的小型I/O操作。缓冲区将小的写入或读取分组到更大的批次中，从而减少了每个单独操作的开销。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 降低系统调用开销至关重要。系统调用越少，上下文切换成本越低，性能也越好，尤其是在I/O密集型应用中。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 高吞吐量比最小延迟更重要。缓冲I/O可以增加每秒处理的总数据量，即使它引入了轻微的交付延迟。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 在以下情况下避免缓冲：
  prefs: []
  type: TYPE_NORMAL
- en: 立即的数据可用性和低延迟至关重要。缓冲区通过设计引入延迟，这在实时或交互式系统中可能是不可以接受的。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 过度缓冲可能会导致内存使用不受控制。如果没有限制或适当的刷新，缓冲区可能会变得很大，从而对系统内存造成压力。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
