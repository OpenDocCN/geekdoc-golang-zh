- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-10-13 06:44:53'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-10-13 06:44:53
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Check if a given tree is a Binary Search Tree in Go (Golang)
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查给定的树是否为二叉搜索树（BST）在Go (Golang)中
- en: 来源：[https://golangbyexample.com/tree-is-bst-golang/](https://golangbyexample.com/tree-is-bst-golang/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://golangbyexample.com/tree-is-bst-golang/](https://golangbyexample.com/tree-is-bst-golang/)
- en: Table of Contents
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: '**   [Overview](#Overview "Overview")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**   [概述](#Overview "Overview")'
- en: '[Program](#Program "Program")*  *## **Overview**'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[程序](#Program "Program")*  *## **概述**'
- en: We can use the below strategy to know if a given tree is a BST.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下策略来判断给定的树是否为BST。
- en: For a given current node, if the left and right subtree are BST
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的当前节点，如果左子树和右子树都是BST
- en: The maximum value in the left subtree is less than the current node value
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左子树中的最大值小于当前节点值。
- en: The minimum value in the right subtree is greater than the current node value
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右子树中的最小值大于当前节点值。
- en: Here is the program for the same.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的程序。
- en: '**Program**'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**程序**'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Output**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Note:** Check out our Golang Advanced Tutorial. The tutorials in this series
    are elaborative and we have tried to cover all concepts with examples. This tutorial
    is for those who are looking to gain expertise and a solid understanding of golang
    – [Golang Advance Tutorial](https://golangbyexample.com/golang-comprehensive-tutorial/)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 请查看我们的Golang高级教程。本系列教程内容详尽，我们尽力覆盖所有概念并提供示例。本教程适合那些希望深入了解Golang并获得专业知识的人——
    [Golang高级教程](https://golangbyexample.com/golang-comprehensive-tutorial/)'
- en: Also if you are interested in understanding how all design patterns can be implemented
    in Golang. If yes, then this post is for you –[All Design Patterns Golang](https://golangbyexample.com/all-design-patterns-golang/)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解如何在Golang中实现所有设计模式。如果是，那么这篇文章适合你—— [所有设计模式Golang](https://golangbyexample.com/all-design-patterns-golang/)
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
