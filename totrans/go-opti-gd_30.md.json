["```go\n`export  GODEBUG=netdns=go` \n```", "```go\n`export  GODEBUG=netdns=cgo` \n```", "```go\n`$  ldd  ./app-cgo   linux-vdso.so.1  (0x0000fa34ddbad000)   libc.so.6  =>  /lib/aarch64-linux-gnu/libc.so.6  (0x0000fa34dd9b0000)   /lib/ld-linux-aarch64.so.1  (0x0000fa34ddb70000)` \n```", "```go\n`$  ldd  ./app-pure   not  a  dynamic  executable` \n```", "```go\n`import  (   \"github.com/patrickmn/go-cache\"   \"net\"   \"time\" )  var  dnsCache  =  cache.New(5*time.Minute,  10*time.Minute)  func  LookupWithCache(host  string)  ([]net.IP,  error)  {   if  cachedIPs,  found  :=  dnsCache.Get(host);  found  {   return  cachedIPs.([]net.IP),  nil   }    ips,  err  :=  net.LookupIP(host)   if  err  !=  nil  {   return  nil,  err   }   dnsCache.Set(host,  ips,  cache.DefaultExpiration)   return  ips,  nil }` \n```", "```go\n`var  serviceAddr  string  func  init()  {   ips,  err  :=  net.LookupIP(\"api.example.com\")   if  err  !=  nil  ||  len(ips)  ==  0  {   panic(\"Unable to resolve api.example.com\")   }   serviceAddr  =  ips[0].String()  // in real code, consider picking an IP randomly, prefer IPv4 if needed, or iterate over ips with checks as appropriate }` \n```", "```go\n`import  (   \"net\"   \"context\"   \"time\" )  var  dialer  =  &net.Dialer{   Timeout:  5  *  time.Second,   KeepAlive:  30  *  time.Second,   Resolver:  &net.Resolver{   PreferGo:  true,   Dial:  func(ctx  context.Context,  network,  address  string)  (net.Conn,  error)  {   return  net.Dial(network,  \"8.8.8.8:53\")   },   }, }  func  ConnectWithCustomDialer(ctx  context.Context,  address  string)  (net.Conn,  error)  {   return  dialer.DialContext(ctx,  \"tcp\",  address) }` \n```", "```go\n`start  :=  time.Now() ips,  err  :=  net.LookupIP(\"example.com\") duration  :=  time.Since(start)  recordDNSLookupDuration(\"example.com\",  duration)` \n```", "```go\n`export  GODEBUG=netdns=2` \n```"]