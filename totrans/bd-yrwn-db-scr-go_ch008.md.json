["```go\n head\n   ↓\n[ next | space... ] (unused object 1)\n   ↓\n[ next | space... ] (unused object 2)\n   ↓\n  ...\n```", "```go\n[](#cb2-1)// node format:\n[](#cb2-2)// | next | pointers | unused |\n[](#cb2-3)// |  8B  |   n*8B   |   ...  |\n[](#cb2-4)type LNode []byte\n[](#cb2-5)\n[](#cb2-6)const FREE_LIST_HEADER = 8\n[](#cb2-7)const FREE_LIST_CAP = (BTREE_PAGE_SIZE - FREE_LIST_HEADER) / 8\n[](#cb2-8)\n[](#cb2-9)// getters & setters\n[](#cb2-10)func (node LNode) getNext() uint64\n[](#cb2-11)func (node LNode) setNext(next uint64)\n[](#cb2-12)func (node LNode) getPtr(idx int) uint64\n[](#cb2-13)func (node LNode) setPtr(idx int, ptr uint64)\n```", "```go\n first_item\n                         ↓\nhead_page -> [ next |    xxxxx ]\n                ↓\n             [ next | xxxxxxxx ]\n                ↓\ntail_page -> [ NULL | xxxx     ]\n                         ↑\n                     last_item\n```", "```go\n[](#cb4-1)type KV struct {\n[](#cb4-2)    Path   string\n[](#cb4-3)    // internals\n[](#cb4-4)    fd   int\n[](#cb4-5)    tree BTree\n[](#cb4-6)    free FreeList // added\n[](#cb4-7)    // ...\n[](#cb4-8)}\n```", "```go\n[](#cb5-1)type FreeList struct {\n[](#cb5-2)    // callbacks for managing on-disk pages\n[](#cb5-3)    get func(uint64) []byte // read a page\n[](#cb5-4)    new func([]byte) uint64 // append a new page\n[](#cb5-5)    set func(uint64) []byte // update an existing page\n[](#cb5-6)    // persisted data in the meta page\n[](#cb5-7)    headPage uint64 // pointer to the list head node\n[](#cb5-8)    headSeq  uint64 // monotonic sequence number to index into the list head\n[](#cb5-9)    tailPage uint64\n[](#cb5-10)    tailSeq  uint64\n[](#cb5-11)    // in-memory states\n[](#cb5-12)    maxSeq uint64 // saved `tailSeq` to prevent consuming newly added items\n[](#cb5-13)}\n[](#cb5-14)\n[](#cb5-15)// get 1 item from the list head. return 0 on failure.\n[](#cb5-16)func (fl *FreeList) PopHead() uint64\n[](#cb5-17)// add 1 item to the tail\n[](#cb5-18)func (fl *FreeList) PushTail(ptr uint64)\n```", "```go\n[](#cb6-1)func (db *KV) Open() error {\n[](#cb6-2)    // ...\n[](#cb6-3)    // B+tree callbacks\n[](#cb6-4)    db.tree.get = db.pageRead      // read a page\n[](#cb6-5)    db.tree.new = db.pageAlloc     // (new) reuse from the free list or append\n[](#cb6-6)    db.tree.del = db.free.PushTail // (new) freed pages go to the free list\n[](#cb6-7)    // free list callbacks\n[](#cb6-8)    db.free.get = db.pageRead      // read a page\n[](#cb6-9)    db.free.new = db.pageAppend    // append a page\n[](#cb6-10)    db.free.set = db.pageWrite     // (new) in-place updates\n[](#cb6-11)    // ...\n[](#cb6-12)}\n```", "```go\n[](#cb7-1)type FreeList struct {\n[](#cb7-2)    // ...\n[](#cb7-3)    // persisted data in the meta page\n[](#cb7-4)    headPage uint64 // pointer to the list head node\n[](#cb7-5)    headSeq  uint64 // monotonic sequence number to index into the list head\n[](#cb7-6)    tailPage uint64\n[](#cb7-7)    tailSeq  uint64\n[](#cb7-8)    // in-memory states\n[](#cb7-9)    maxSeq uint64 // saved `tailSeq` to prevent consuming newly added items\n[](#cb7-10)}\n```", "```go\n[](#cb8-1)func seq2idx(seq uint64) int {\n[](#cb8-2)    return int(seq % FREE_LIST_CAP)\n[](#cb8-3)}\n```", "```go\n[](#cb9-1)// make the newly added items available for consumption\n[](#cb9-2)func (fl *FreeList) SetMaxSeq() {\n[](#cb9-3)    fl.maxSeq = fl.tailSeq\n[](#cb9-4)}\n```", "```go\n[](#cb10-1)// remove 1 item from the head node, and remove the head node if empty.\n[](#cb10-2)func flPop(fl *FreeList) (ptr uint64, head uint64) {\n[](#cb10-3)    if fl.headSeq == fl.maxSeq {\n[](#cb10-4)        return 0, 0 // cannot advance\n[](#cb10-5)    }\n[](#cb10-6)    node := LNode(fl.get(fl.headPage))\n[](#cb10-7)    ptr = node.getPtr(seq2idx(fl.headSeq)) // item\n[](#cb10-8)    fl.headSeq++\n[](#cb10-9)    // move to the next one if the head node is empty\n[](#cb10-10)    if seq2idx(fl.headSeq) == 0 {\n[](#cb10-11)        head, fl.headPage = fl.headPage, node.getNext()\n[](#cb10-12)        assert(fl.headPage != 0)\n[](#cb10-13)    }\n[](#cb10-14)    return\n[](#cb10-15)}\n```", "```go\n[](#cb11-1)// get 1 item from the list head. return 0 on failure.\n[](#cb11-2)func (fl *FreeList) PopHead() uint64 {\n[](#cb11-3)    ptr, head := flPop(fl)\n[](#cb11-4)    if head != 0 { // the empty head node is recycled\n[](#cb11-5)        fl.PushTail(head)\n[](#cb11-6)    }\n[](#cb11-7)    return ptr\n[](#cb11-8)}\n```", "```go\n[](#cb12-1)func (fl *FreeList) PushTail(ptr uint64) {\n[](#cb12-2)    // add it to the tail node\n[](#cb12-3)    LNode(fl.set(fl.tailPage)).setPtr(seq2idx(fl.tailSeq), ptr)\n[](#cb12-4)    fl.tailSeq++\n[](#cb12-5)    // add a new tail node if it's full (the list is never empty)\n[](#cb12-6)    if seq2idx(fl.tailSeq) == 0 {\n[](#cb12-7)        // try to reuse from the list head\n[](#cb12-8)        next, head := flPop(fl) // may remove the head node\n[](#cb12-9)        if next == 0 {\n[](#cb12-10)            // or allocate a new node by appending\n[](#cb12-11)            next = fl.new(make([]byte, BTREE_PAGE_SIZE))\n[](#cb12-12)        }\n[](#cb12-13)        // link to the new tail node\n[](#cb12-14)        LNode(fl.set(fl.tailPage)).setNext(next)\n[](#cb12-15)        fl.tailPage = next\n[](#cb12-16)        // also add the head node if it's removed\n[](#cb12-17)        if head != 0 {\n[](#cb12-18)            LNode(fl.set(fl.tailPage)).setPtr(0, head)\n[](#cb12-19)            fl.tailSeq++\n[](#cb12-20)        }\n[](#cb12-21)    }\n[](#cb12-22)}\n```", "```go\n[](#cb13-1)type KV struct {\n[](#cb13-2)    // ...\n[](#cb13-3)    page struct {\n[](#cb13-4)        flushed uint64            // database size in number of pages\n[](#cb13-5)        nappend uint64            // number of pages to be appended\n[](#cb13-6)        updates map[uint64][]byte // pending updates, including appended pages\n[](#cb13-7)    }\n[](#cb13-8)}\n```", "```go\n[](#cb14-1)// `BTree.new`, allocate a new page.\n[](#cb14-2)func (db *KV) pageAlloc(node []byte) uint64 {\n[](#cb14-3)    if ptr := db.free.PopHead(); ptr != 0 { // try the free list\n[](#cb14-4)        db.page.updates[ptr] = node\n[](#cb14-5)        return ptr\n[](#cb14-6)    }\n[](#cb14-7)    return db.pageAppend(node) // append\n[](#cb14-8)}\n```", "```go\n[](#cb15-1)// `FreeList.set`, update an existing page.\n[](#cb15-2)func (db *KV) pageWrite(ptr uint64) []byte {\n[](#cb15-3)    if node, ok := db.page.updates[ptr]; ok {\n[](#cb15-4)        return node // pending update\n[](#cb15-5)    }\n[](#cb15-6)    node := make([]byte, BTREE_PAGE_SIZE)\n[](#cb15-7)    copy(node, db.pageReadFile(ptr)) // initialized from the file\n[](#cb15-8)    db.page.updates[ptr] = node\n[](#cb15-9)    return node\n[](#cb15-10)}\n```", "```go\n[](#cb16-1)// `BTree.get`, read a page.\n[](#cb16-2)func (db *KV) pageRead(ptr uint64) []byte {\n[](#cb16-3)    if node, ok := db.page.updates[ptr]; ok {\n[](#cb16-4)        return node // pending update\n[](#cb16-5)    }\n[](#cb16-6)    return db.pageReadFile(ptr)\n[](#cb16-7)}\n[](#cb16-8)func (db *KV) pageReadFile(ptr uint64) []byte {\n[](#cb16-9)    // same as `KV.pageRead` in the last chapter ...\n[](#cb16-10)}\n```", "```go\n| sig | root_ptr | page_used | head_page | head_seq | tail_page | tail_seq |\n| 16B |    8B    |     8B    |     8B    |    8B    |     8B    |    8B    |\n```", "```go\n[](#cb18-1)func readRoot(db *KV, fileSize int64) error {\n[](#cb18-2)    if fileSize == 0 { // empty file\n[](#cb18-3)        // reserve 2 pages: the meta page and a free list node\n[](#cb18-4)        db.page.flushed = 2\n[](#cb18-5)        // add an initial node to the free list so it's never empty\n[](#cb18-6)        db.free.headPage = 1 // the 2nd page\n[](#cb18-7)        db.free.tailPage = 1\n[](#cb18-8)        return nil // the meta page will be written in the 1st update\n[](#cb18-9)    }\n[](#cb18-10)    // ...\n[](#cb18-11)}\n```", "```go\n[](#cb19-1)func updateFile(db *KV) error {\n[](#cb19-2)    // ...\n[](#cb19-3)    // prepare the free list for the next update\n[](#cb19-4)    db.free.SetMaxSeq()\n[](#cb19-5)    return nil\n[](#cb19-6)}\n```"]