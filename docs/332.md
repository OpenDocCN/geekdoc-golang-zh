# 协议缓冲区和开始:入门

> 原文:[https://golangbyexample.com/protocol-buffers-go/](https://golangbyexample.com/protocol-buffers-go/)

在本教程中，我们将了解如何在 GO 语言的上下文中使用协议缓冲区。

**什么是协议缓冲区**

协议缓冲区是以结构化格式存储数据的数据格式。协议缓冲格式的数据可以用多种语言序列化和反序列化。

听起来很困惑。你可以把它想象成 JSON、XML，但是它有很多优点。还困惑吗？那么不要担心，随着教程的进行，我们会理解为什么甚至需要一种新的数据格式。

让我们先看一个最简单的协议缓冲文件的例子。

**person.proto**

```go
syntax = "proto3";

message Person {
    string name = 1;
}
```

关于上述文件需要注意的几点。

*   这个文件只是我们的协议缓冲区结构的蓝图。还没有相关的数据。这与 JSON/XML 不同，后者的文件也代表实际数据。
*   在上面的文件中有一个**人**消息，带有一个字段**名称**，类型为**字符串。“proto 3”**表示写入的消息与协议缓冲区版本三不兼容。
*   从上面的例子中，您可以从 JSON 中注意到一个区别，即它有类型信息。这种类型的信息在自动生成不同语言的代码时会很有用。让我们看一个在 Golang 自动生成的例子

**GO 码自动生成:**

*   我们可以使用上面的 person.proto 文件生成相应的 Golang 代码。但是要做到这一点，我们需要做一些安装:

**安装:**

*   首先安装协议缓冲区的 C++实现。每个平台都有自己的安装方式。参见此链接–[https://github . com/protocol buffers/proto buf/blob/master/src/readme . MD](https://github.com/protocolbuffers/protobuf/blob/master/src/README.md)
*   安装高朗
*   安装 protocol-gen-go–**go get-u**[github.com/golang/protobuf/protoc-gen-go](http://github.com/golang/protobuf/protoc-gen-go)T4。此包将用于自动生成 Go 代码

安装完成后，将光盘刻录到包含 **person.proto** 文件的目录中。运行以下命令:

```go
protoc -I ./ --go_out=./ ./person.proto
```

它将在同一个目录中生成一个名为 **person.pb.go** 的数据访问 go 文件。

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: person.proto

package person

import (
    fmt "fmt"
    proto "github.com/golang/protobuf/proto"
    math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Person struct {
    Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
    XXX_NoUnkeyedLiteral struct{} `json:"-"`
    XXX_unrecognized     []byte   `json:"-"`
    XXX_sizecache        int32    `json:"-"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}
func (*Person) Descriptor() ([]byte, []int) {
    return fileDescriptor_4c9e10cf24b1156d, []int{0}
}

func (m *Person) XXX_Unmarshal(b []byte) error {
    return xxx_messageInfo_Person.Unmarshal(m, b)
}
func (m *Person) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    return xxx_messageInfo_Person.Marshal(b, m, deterministic)
}
func (m *Person) XXX_Merge(src proto.Message) {
    xxx_messageInfo_Person.Merge(m, src)
}
func (m *Person) XXX_Size() int {
    return xxx_messageInfo_Person.Size(m)
}
func (m *Person) XXX_DiscardUnknown() {
    xxx_messageInfo_Person.DiscardUnknown(m)
}

var xxx_messageInfo_Person proto.InternalMessageInfo

func (m *Person) GetName() string {
    if m != nil {
        return m.Name
    }
    return ""
}

func init() {
    proto.RegisterType((*Person)(nil), "Person")
}

func init() { proto.RegisterFile("person.proto", fileDescriptor_4c9e10cf24b1156d) }

var fileDescriptor_4c9e10cf24b1156d = []byte{
    // 67 bytes of a gzipped FileDescriptorProto
    0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x29, 0x48, 0x2d, 0x2a,
    0xce, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x57, 0x92, 0xe1, 0x62, 0x0b, 0x00, 0xf3, 0x85,
    0x84, 0xb8, 0x58, 0xf2, 0x12, 0x73, 0x53, 0x25, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0xc0, 0xec,
    0x24, 0x36, 0xb0, 0x22, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4, 0xaf, 0x53, 0x72, 0x34,
    0x00, 0x00, 0x00,
}
```

现在最大的问题是这个 person.pb.go 文件是什么，是 protoc 用 person.proto 自动生成的。首先要注意的几点

*   **人**结构如下。查看 person.proto 文件的类型信息如何知道**名称**是什么类型的字段是字符串

```go
type Person struct {
    Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
    XXX_NoUnkeyedLiteral struct{} `json:"-"`
    XXX_unrecognized     []byte   `json:"-"`
    XXX_sizecache        int32    `json:"-"`
}
```

*   **Person** struct 还实现了几个方法，使 if 成为接口类型**原型消息。**

因此，基本上，这个自动生成的文件为 Person 结构生成数据访问器，并且它提供了允许将 Person 结构类型封送处理到实际字节或从实际字节解封的方法。现在让我们编写一个 main.go 程序来实际创建 **Person** 结构的具体对象。在这里，我们将看到协议缓冲区提供的一些优势。下面的程序还显示了人员结构到文件的读写。

**main.go**

```go
package main

import (
    "fmt"
    "io/ioutil"
    "log"
    proto "github.com/golang/protobuf/proto"
)

func main() {
    person := &Person{Name: "XXX"}
    fmt.Printf("Person's name is %s\n", person.GetName())

    //Now lets write this person object to file
    out, err := proto.Marshal(person)
    if err != nil {
        log.Fatalf("Serialization error: %s", err.Error())
    }
    if err := ioutil.WriteFile("person.bin", out, 0644); err != nil {
        log.Fatalf("Write File Error: %s ", err.Error())
    }
    fmt.Println("Write Success")

    //Read from file
    in, err := ioutil.ReadFile("person.bin")
    if err != nil {
        log.Fatalf("Read File Error: %s ", err.Error())
    }
    person2 := &Person{}
    err2 := proto.Unmarshal(in, person2)
    if err2 != nil {
        log.Fatalf("DeSerialization error: %s", err.Error())
    }

    fmt.Println("Read Success")
    fmt.Printf("Person2's name is %s\n", person2.GetName())
}
```

要运行此文件，首先使用“开始获取[github.com/golang/protobuf/prot](http://github.com/golang/protobuf/prot)o”安装 protobuf/proto，然后使用命令“开始运行*”运行此文件。go" **输出:**

```go
Person's name is XXX
Write Success
Read Success
Person2's name is XXX
```

请注意，在上述程序中，我们

*   我们把一个具体的“人”结构写到一个文件“T2”中。是二进制文件，不可读。
*   我们也从文件中读到。它能够成功读取并打印“**人员 2 的姓名为 XXX”**

**“person . bin”文件**的惊人之处在于，如果您创建一个具有相同数据的 JSON 文件，而该文件的大小超过 15 字节，则该文件只有 5 字节。此外，与 JSON 文件的封送和解封相比，从字节到具体对象的封送和解封也非常快，反之亦然。
现在我们已经提供了理论。让我们再写一遍使用协议缓冲区的优点

1.  比相应的 JSON 和 XML 更清晰、更不模糊，因为它们还存储了类型信息。
2.  存储的数据相对较小，几乎小 2- 3 倍。
3.  快多了。例如，使用协议缓冲区，序列化和反序列化更快
4.  自动代码生成–您编写一个协议缓冲文件，并自动生成相应的 GO 文件
5.  GRPC 使用了一个协议缓冲区，这是 REST 协议的下一代替代方案——注意这里的空间，我们很快会添加一篇关于它的文章。

**结论:**除了我们在文章中讨论的内容，协议缓冲区还有很多可以提供的。这提供了什么是协议缓冲区以及它们与 JSON/XML 格式相比有什么优势的快速概述。