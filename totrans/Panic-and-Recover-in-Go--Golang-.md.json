["```\nfunc panic(v interface{})\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n\ta := []string{\"a\", \"b\"}\n\tprint(a, 2)\n}\n\nfunc print(a []string, index int) {\n\tfmt.Println(a[index])\n}\n```", "```\npanic: runtime error: index out of range [2] with length 2\n\ngoroutine 1 [running]:\nmain.checkAndPrint(...)\n        main.go:12\nmain.main()\n        /main.go:8 +0x1b\nexit status 2\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n\ta := []string{\"a\", \"b\"}\n\tcheckAndPrint(a, 2)\n}\n\nfunc checkAndPrint(a []string, index int) {\n\tif index > (len(a) - 1) {\n\t\tpanic(\"Out of bound access for slice\")\n\t}\n\tfmt.Println(a[index])\n}\n```", "```\npanic: Out of bound access for slice\n\ngoroutine 1 [running]:\nmain.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2)\n      main.go:13 +0xe2\nmain.main()\n        main.go:8 +0x7d\nexit status 2\n```", "```\npackage main\nimport \"fmt\"\nfunc main() {\n    defer fmt.Println(\"Defer in main\")\n    panic(\"Panic with Defer\")\n    fmt.Println(\"After painc in f2\")\n}\n```", "```\nDefer in main\npanic: Panic Create\n\ngoroutine 1 [running]:\nmain.main()\n        /Users/slohia/go/src/github.com/golang-examples/articles/tutorial/panicRecover/deferWithPanic/main.go:7 +0x95\nexit status 2\n```", "```\nDefer in main\n```", "```\npackage main\nimport \"fmt\"\nfunc main() {\n    f1()\n}\nfunc f1() {\n    defer fmt.Println(\"Defer in f1\")\n    f2()\n    fmt.Println(\"After painc in f1\")\n}\nfunc f2() {\n    defer fmt.Println(\"Defer in f2\")\n    panic(\"Panic Demo\")\n    fmt.Println(\"After painc in f2\")\n}\n```", "```\nDefer in f2\nDefer in f1\npanic: Panic Demo\n\ngoroutine 1 [running]:\nmain.f2()\n        main.go:17 +0x95\nmain.f1()\n        main.go:11 +0x96\nmain.main()\n        main.go:6 +0x20\nexit status 2\n```", "```\npanic(\"Panic Demo\")\n```", "```\nDefer in f2\n```", "```\nfmt.Println(\"After painc in f2\")\n```", "```\nDefer in f1\n```", "```\nfunc recover() interface{}\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n\ta := []string{\"a\", \"b\"}\n\tcheckAndPrint(a, 2)\n\tfmt.Println(\"Exiting normally\")\n}\n\nfunc checkAndPrint(a []string, index int) {\n\tdefer handleOutOfBounds()\n\tif index > (len(a) - 1) {\n\t\tpanic(\"Out of bound access for slice\")\n\t}\n\tfmt.Println(a[index])\n}\n\nfunc handleOutOfBounds() {\n\tif r := recover(); r != nil {\n\t\tfmt.Println(\"Recovering from panic:\", r)\n\t}\n}\n```", "```\nRecovering from panic: Out of bound access for slice\nExiting normally\n```", "```\nif r := recover(); r != nil {\n    fmt.Println(\"Recovering from panic:\", r)\n}\n```", "```\nRecovering from panic: Out of bound access for slice\n```", "```\nExiting normally\n```", "```\nif r := recover(); r != nil \n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    a := []string{\"a\", \"b\"}\n    checkAndPrintWithRecover(a, 2)\n    fmt.Println(\"Exiting normally\")\n}\nfunc checkAndPrintWithRecover(a []string, index int) {\n    defer handleOutOfBounds()\n    checkAndPrint(a, 2)\n}\nfunc checkAndPrint(a []string, index int) {\n    if index > (len(a) - 1) {\n        panic(\"Out of bound access for slice\")\n    }\n    fmt.Println(a[index])\n}\nfunc handleOutOfBounds() {\n    if r := recover(); r != nil {\n        fmt.Println(\"Recovering from panic:\", r)\n    }\n}\n```", "```\nRecovering from panic: Out of bound access for slice\nExiting normally\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n\ta := []string{\"a\", \"b\"}\n\tcheckAndPrint(a, 2)\n\tfmt.Println(\"Exiting normally\")\n}\n\nfunc checkAndPrint(a []string, index int) {\n\thandleOutOfBounds()\n\tif index > (len(a) - 1) {\n\t\tpanic(\"Out of bound access for slice\")\n\t}\n\tfmt.Println(a[index])\n}\n\nfunc handleOutOfBounds() {\n\tif r := recover(); r != nil {\n\t\tfmt.Println(\"Recovering from panic:\", r)\n\t}\n}\n```", "```\npanic: Out of bound access for slice\n\ngoroutine 1 [running]:\nmain.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2)\n        /Users/slohia/go/src/github.com/golang-examples/articles/tutorial/panicRecover/recoverNegativeExample/main.go:15 +0xea\nmain.main()\n        /Users/slohia/go/src/github.com/golang-examples/articles/tutorial/panicRecover/recoverNegativeExample/main.go:8 +0x81\nexit status 2\n```", "```\npackage main\nimport \"fmt\"\nfunc main() {\n    a := []string{\"a\", \"b\"}\n    checkAndPrintWithRecover(a, 2)\n    time.Sleep(time.Second)\n    fmt.Println(\"Exiting normally\")\n}\nfunc checkAndPrintWithRecover(a []string, index int) {\n    defer handleOutOfBounds()\n    go checkAndPrint(a, 2)\n}\nfunc checkAndPrint(a []string, index int) {\n    if index > (len(a) - 1) {\n        panic(\"Out of bound access for slice\")\n    }\n    fmt.Println(a[index])\n}\nfunc handleOutOfBounds() {\n    if r := recover(); r != nil {\n        fmt.Println(\"Recovering from panic:\", r)\n    }\n}\n```", "```\nExiting normally\npanic: Out of bound access for slice\n\ngoroutine 18 [running]:\nmain.checkAndPrint(0xc0000a6020, 0x2, 0x2, 0x2)\n        /Users/slohia/go/src/github.com/golang-examples/articles/tutorial/panicRecover/goroutine/main.go:19 +0xe2\ncreated by main.checkAndPrintWithRecover\n        /Users/slohia/go/src/github.com/golang-examples/articles/tutorial/panicRecover/goroutine/main.go:14 +0x82\nexit status 2\n```", "```\npackage main\nimport (\n    \"fmt\"\n    \"runtime/debug\"\n)\nfunc main() {\n    a := []string{\"a\", \"b\"}\n    checkAndPrint(a, 2)\n    fmt.Println(\"Exiting normally\")\n}\nfunc checkAndPrint(a []string, index int) {\n    defer handleOutOfBounds()\n    if index > (len(a) - 1) {\n        panic(\"Out of bound access for slice\")\n    }\n    fmt.Println(a[index])\n}\nfunc handleOutOfBounds() {\n    if r := recover(); r != nil {\n        fmt.Println(\"Recovering from panic:\", r)\n        fmt.Println(\"Stack Trace:\")\n        debug.PrintStack()\n    }\n}\n```", "```\nRecovering from panic: Out of bound access for slice\nStack Trace:\ngoroutine 1 [running]:\nruntime/debug.Stack(0xd, 0x0, 0x0)\n        stack.go:24 +0x9d\nruntime/debug.PrintStack()\n        stack.go:16 +0x22\nmain.handleOutOfBounds()\n        main.go:27 +0x10f\npanic(0x10ab8c0, 0x10e8f60)\n        /Users/slohia/Documents/goversion/go1.14.1/src/runtime/panic.go:967 +0x166\nmain.checkAndPrint(0xc000104f58, 0x2, 0x2, 0x2)\n        main.go:18 +0x111\nmain.main()\n        main.go:11 +0x81\nExiting normally\n```", "```\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    a := []int{5, 6}\n    val, err := checkAndGet(a, 2)\n    fmt.Printf(\"Val: %d\\n\", val)\n    fmt.Println(\"Error: \", err)\n}\nfunc checkAndGet(a []int, index int) (int, error) {\n    defer handleOutOfBounds()\n    if index > (len(a) - 1) {\n        panic(\"Out of bound access for slice\")\n    }\n    return a[index], nil\n}\nfunc handleOutOfBounds() {\n    if r := recover(); r != nil {\n        fmt.Println(\"Recovering from panic:\", r)\n    }\n}\n```", "```\nRecovering from panic: Out of bound access for slice\nVal: 0\nError: \n```", "```\nRecovering from panic: Out of bound access for slice\n```", "```\nval, err := checkAndGet(a, 2)\n```", "```\n fmt.Printf(\"Val: %d\\n\", val)\n```", "```\nVal: 0\n```", "```\nfmt.Println(\"Error: \", err)\n```", "```\nError: \n```", "```\npackage main\nimport (\n    \"fmt\"\n)\nfunc main() {\n    a := []int{5, 6}\n    val, err := checkAndGet(a, 2)\n    fmt.Printf(\"Val: %d\\n\", val)\n    fmt.Println(\"Error: \", err)\n}\nfunc checkAndGet(a []int, index int) (value int, err error) {\n    value = 10\n    defer handleOutOfBounds()\n    if index > (len(a) - 1) {\n        panic(\"Out of bound access for slice\")\n    }\n    value = a[index]\n    return value, nil\n}\nfunc handleOutOfBounds() {\n    if r := recover(); r != nil {\n        fmt.Println(\"Recovering from panic:\", r)\n    }\n}\n```", "```\nRecovering from panic: Out of bound access for slice\nVal: 10\nError: \n```", "```\nfunc checkAndGet(a []int, index int) (value int, err error)\n```", "```\nvalue = 10\n```", "```\nRecovering from panic: Out of bound access for slice\nVal: 10\nError: \n```"]