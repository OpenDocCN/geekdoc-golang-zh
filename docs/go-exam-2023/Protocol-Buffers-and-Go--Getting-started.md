<!--yml

分类：未分类

日期：2024-10-13 06:01:02

-->

# 协议缓冲与 Go：入门指南

> 来源：[`golangbyexample.com/protocol-buffers-go/`](https://golangbyexample.com/protocol-buffers-go/)

在本教程中，我们将看到协议缓冲如何在 GO 语言中使用。

**什么是协议缓冲**

协议缓冲是一种以结构化格式存储数据的数据格式。协议缓冲格式中的数据可以被多种语言序列化和反序列化。

听起来很混乱。你可以把它理解为 JSON、XML，但它提供了许多优势。仍然感到困惑吗？那么不用担心，随着教程的进行，我们将理解为什么甚至需要一个新的数据格式。

让我们先看看最简单的协议缓冲文件的例子。

**person.proto**

```go
syntax = "proto3";

message Person {
    string name = 1;
}
```

关于上述文件，有几点需要注意。

+   这个文件只是我们协议缓冲结构的蓝图。尚未关联任何数据。这与 JSON/XML 不同，后者的文件也表示实际数据。

+   在上述文件中，有一个 **person** 消息，其字段 **name** 的类型为 **string。 “proto3”** 意味着该消息与协议缓冲版本三不兼容。

+   从上面的例子可以注意到一个不同之处，即它具有类型信息。这种类型的信息在不同语言的代码自动生成中将非常有用。让我们看看在 Golang 中的自动生成示例。

**GO 代码的自动生成：**

+   我们可以使用上述 `person.proto` 文件生成相应的 Golang 代码。但为此我们需要进行一些安装：

**安装：**

+   首先安装协议缓冲的 C++ 实现。每个平台的安装方式各不相同。请参见此链接 – [`github.com/protocolbuffers/protobuf/blob/master/src/README.md`](https://github.com/protocolbuffers/protobuf/blob/master/src/README.md)

+   安装 Golang

+   安装 protoc-gen-go – **go get -u** [github.com/golang/protobuf/protoc-gen-go](http://github.com/golang/protobuf/protoc-gen-go)**。** 这个包将用于 Go 代码的自动生成。

安装完成后，进入包含 **person.proto** 文件的目录。运行此命令：

```go
protoc -I ./ --go_out=./ ./person.proto
```

它将在同一目录下生成名为 **person.pb.go** 的数据访问 Go 文件。

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: person.proto

package person

import (
    fmt "fmt"
    proto "github.com/golang/protobuf/proto"
    math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Person struct {
    Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
    XXX_NoUnkeyedLiteral struct{} `json:"-"`
    XXX_unrecognized     []byte   `json:"-"`
    XXX_sizecache        int32    `json:"-"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}
func (*Person) Descriptor() ([]byte, []int) {
    return fileDescriptor_4c9e10cf24b1156d, []int{0}
}

func (m *Person) XXX_Unmarshal(b []byte) error {
    return xxx_messageInfo_Person.Unmarshal(m, b)
}
func (m *Person) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    return xxx_messageInfo_Person.Marshal(b, m, deterministic)
}
func (m *Person) XXX_Merge(src proto.Message) {
    xxx_messageInfo_Person.Merge(m, src)
}
func (m *Person) XXX_Size() int {
    return xxx_messageInfo_Person.Size(m)
}
func (m *Person) XXX_DiscardUnknown() {
    xxx_messageInfo_Person.DiscardUnknown(m)
}

var xxx_messageInfo_Person proto.InternalMessageInfo

func (m *Person) GetName() string {
    if m != nil {
        return m.Name
    }
    return ""
}

func init() {
    proto.RegisterType((*Person)(nil), "Person")
}

func init() { proto.RegisterFile("person.proto", fileDescriptor_4c9e10cf24b1156d) }

var fileDescriptor_4c9e10cf24b1156d = []byte{
    // 67 bytes of a gzipped FileDescriptorProto
    0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x29, 0x48, 0x2d, 0x2a,
    0xce, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x57, 0x92, 0xe1, 0x62, 0x0b, 0x00, 0xf3, 0x85,
    0x84, 0xb8, 0x58, 0xf2, 0x12, 0x73, 0x53, 0x25, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0xc0, 0xec,
    0x24, 0x36, 0xb0, 0x22, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4, 0xaf, 0x53, 0x72, 0x34,
    0x00, 0x00, 0x00,
}
```

现在最大的问题是，什么是通过 protoc 使用 `person.proto` 自动生成的 `person.pb.go` 文件。首先要注意几点。

+   **Person** 结构体如下。请注意 `person.proto` 文件中的类型信息如何用于了解 **Name** 字段是字符串。

```go
type Person struct {
    Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
    XXX_NoUnkeyedLiteral struct{} `json:"-"`
    XXX_unrecognized     []byte   `json:"-"`
    XXX_sizecache        int32    `json:"-"`
}
```

+   **Person** 结构体还实现了一些方法，使其成为接口类型 **proto.Message。**

基本上，这个自动生成的文件为 Person 结构体生成数据访问器，并提供允许将 Person 结构体类型与实际字节之间进行序列化/反序列化的方法。现在让我们编写一个 main.go 程序，实际创建**Person**结构体的具体对象。在这里，我们将看到协议缓冲区所提供的几个优势。以下程序还展示了 Person 结构体的读写操作。

**main.go**

```go
package main

import (
    "fmt"
    "io/ioutil"
    "log"
    proto "github.com/golang/protobuf/proto"
)

func main() {
    person := &Person{Name: "XXX"}
    fmt.Printf("Person's name is %s\n", person.GetName())

    //Now lets write this person object to file
    out, err := proto.Marshal(person)
    if err != nil {
        log.Fatalf("Serialization error: %s", err.Error())
    }
    if err := ioutil.WriteFile("person.bin", out, 0644); err != nil {
        log.Fatalf("Write File Error: %s ", err.Error())
    }
    fmt.Println("Write Success")

    //Read from file
    in, err := ioutil.ReadFile("person.bin")
    if err != nil {
        log.Fatalf("Read File Error: %s ", err.Error())
    }
    person2 := &Person{}
    err2 := proto.Unmarshal(in, person2)
    if err2 != nil {
        log.Fatalf("DeSerialization error: %s", err.Error())
    }

    fmt.Println("Read Success")
    fmt.Printf("Person2's name is %s\n", person2.GetName())
}
```

要运行此文件，首先使用“go get [github.com/golang/protobuf/prot](http://github.com/golang/protobuf/prot)o”安装 protobuf/proto，然后使用命令“go run *.go”运行此文件。**输出：**

```go
Person's name is XXX
Write Success
Read Success
Person2's name is XXX
```

请注意，在上述程序中我们

+   我们将一个具体的**person**结构体写入文件**“person.bin”。**这是一个二进制文件，不可读。

+   我们也从文件中读取。能够成功读取并打印“**Person2 的名字是 XXX**”。

**“person.bin”文件**的惊人之处在于其仅有 5 个字节，而如果创建一个相同数据的 JSON 文件，其大小将超过 15 个字节。此外，从字节到具体对象及其反向操作的序列化和反序列化速度也非常快，相比之下，JSON 文件的序列化和反序列化速度较慢。

现在我们提供了理论。让我们再一次列出使用协议缓冲区的优势。

1.  相比于相应的 JSON 和 XML，更加清晰且不含歧义，因为它们还存储了类型信息。

1.  存储的数据相对较小，约小 2-3 倍。

1.  它快得多。例如，使用协议缓冲区的序列化和反序列化速度更快。

1.  自动代码生成——你编写一个协议缓冲文件，系统会自动生成相应的 GO 文件。

1.  协议缓冲区用于 GRPC，后者是 REST 协议的下一代替代品——请关注此处，我们将很快添加相关文章。

**结论：** 协议缓冲区提供的内容远不止我们在文章中讨论的。这为协议缓冲区是什么及其与 JSON/XML 格式相比的优势提供了快速概述。

+   [buffer](https://golangbyexample.com/tag/buffer/) *   [go](https://golangbyexample.com/tag/go/) *   [grpc](https://golangbyexample.com/tag/grpc/) *   [protocol](https://golangbyexample.com/tag/protocol/) *   [protocolbuffer](https://golangbyexample.com/tag/protocolbuffer/)
