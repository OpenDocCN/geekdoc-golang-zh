["```go\n[](#cb1-1)type KVTX struct {\n[](#cb1-2)    // a read-only snapshot\n[](#cb1-3)    snapshot BTree\n[](#cb1-4)    // captured KV updates:\n[](#cb1-5)    // values are prefixed by a 1-byte flag to indicate deleted keys.\n[](#cb1-6)    pending BTree\n[](#cb1-7)    // ...\n[](#cb1-8)}\n```", "```go\n[](#cb2-1)// begin a transaction\n[](#cb2-2)func (kv *KV) Begin(tx *KVTX) {\n[](#cb2-3)    // read-only snapshot, just the tree root and the page read callback\n[](#cb2-4)    tx.snapshot.root = kv.tree.root\n[](#cb2-5)    tx.snapshot.get = ... // read from mmap'ed pages ...\n[](#cb2-6)    // in-memory tree to capture updates\n[](#cb2-7)    pages := [][]byte(nil)\n[](#cb2-8)    tx.pending.get = func(ptr uint64) []byte { return pages[ptr-1] }\n[](#cb2-9)    tx.pending.new = func(node []byte) uint64 {\n[](#cb2-10)        pages = append(pages, node)\n[](#cb2-11)        return uint64(len(pages))\n[](#cb2-12)    }\n[](#cb2-13)    tx.pending.del = func(uint64) {}\n[](#cb2-14)}\n```", "```go\n[](#cb3-1)    FLAG_DELETED = byte(1)\n[](#cb3-2)    FLAG_UPDATED = byte(2)\n```", "```go\n[](#cb4-1)// point query. combines captured updates with the snapshot\n[](#cb4-2)func (tx *KVTX) Get(key []byte) ([]byte, bool) {\n[](#cb4-3)    val, ok := tx.pending.Get(key)\n[](#cb4-4)    switch {\n[](#cb4-5)    case ok && val[0] == FLAG_UPDATED: // updated in this TX\n[](#cb4-6)        return val[1:], true\n[](#cb4-7)    case ok && val[0] == FLAG_DELETED: // deleted in this TX\n[](#cb4-8)        return nil, false\n[](#cb4-9)    case !ok: // read from the snapshot\n[](#cb4-10)        return tx.snapshot.Get(key)\n[](#cb4-11)    default:\n[](#cb4-12)        panic(\"unreachable\")\n[](#cb4-13)    }\n[](#cb4-14)}\n```", "```go\n[](#cb5-1)// an iterator that combines pending updates and the snapshot\n[](#cb5-2)type CombinedIter struct {\n[](#cb5-3)    top *BIter // KVTX.pending\n[](#cb5-4)    bot *BIter // KVTX.snapshot\n[](#cb5-5)    // ...\n[](#cb5-6)}\n```", "```go\n[](#cb6-1)type KVTX struct {\n[](#cb6-2)    // a read-only snapshot\n[](#cb6-3)    snapshot BTree\n[](#cb6-4)    version  uint64 // based on KV.version\n[](#cb6-5)    // ...\n[](#cb6-6)}\n[](#cb6-7)type KV struct {\n[](#cb6-8)    // ...\n[](#cb6-9)    version uint64    // monotonic version number; persisted in the meta page\n[](#cb6-10)    ongoing []uint64  // version numbers of concurrent TXs\n[](#cb6-11)}\n```", "```go\n[](#cb7-1)// | next | pointer + version | unused |\n[](#cb7-2)// |  8B  |     n*(8B+8B)     |   ...  |\n[](#cb7-3)type FreeList struct {\n[](#cb7-4)    // ...\n[](#cb7-5)    maxSeq uint64 // saved `tailSeq` to prevent consuming newly added items\n[](#cb7-6)    maxVer uint64 // the oldest reader version\n[](#cb7-7)    curVer uint64 // version number when committing\n[](#cb7-8)}\n```", "```go\n[](#cb8-1)// start <= key <= stop\n[](#cb8-2)type KeyRange struct {\n[](#cb8-3)    start []byte\n[](#cb8-4)    stop  []byte\n[](#cb8-5)}\n[](#cb8-6)type KVTX struct {\n[](#cb8-7)    // ...\n[](#cb8-8)    reads []KeyRange\n[](#cb8-9)}\n[](#cb8-10)func (tx *KVTX) Get(key []byte) ([]byte, bool) {\n[](#cb8-11)    tx.reads = append(tx.reads, KeyRange{key, key}) // dependency\n[](#cb8-12)    // ...\n[](#cb8-13)}\n```", "```go\n[](#cb9-1)type KV struct {\n[](#cb9-2)    // ...\n[](#cb9-3)    history []CommittedTX // chanages keys; for detecting conflicts\n[](#cb9-4)}\n[](#cb9-5)type CommittedTX struct {\n[](#cb9-6)    version uint64\n[](#cb9-7)    writes  []KeyRange // sorted\n[](#cb9-8)}\n[](#cb9-9)func (kv *KV) Commit(tx *KVTX) error {\n[](#cb9-10)    // ...\n[](#cb9-11)    if len(writes) > 0 {\n[](#cb9-12)        kv.history = append(kv.history, CommittedTX{kv.version, writes})\n[](#cb9-13)    }\n[](#cb9-14)    return nil\n[](#cb9-15)}\n```", "```go\n[](#cb10-1)func detectConflicts(kv *KV, tx *KVTX) bool {\n[](#cb10-2)    for i := len(kv.history) - 1; i >= 0; i-- {\n[](#cb10-3)        if !versionBefore(tx.version, kv.history[i].version) {\n[](#cb10-4)            break // sorted\n[](#cb10-5)        }\n[](#cb10-6)        if rangesOverlap(tx.reads, kv.history[i].writes) {\n[](#cb10-7)            return true\n[](#cb10-8)        }\n[](#cb10-9)    }\n[](#cb10-10)    return false\n[](#cb10-11)}\n```", "```go\n[](#cb11-1)type KV struct {\n[](#cb11-2)    // ...\n[](#cb11-3)    mutex   sync.Mutex    // serialize TX methods\n[](#cb11-4)}\n[](#cb11-5)func (kv *KV) Begin(tx *KVTX) {\n[](#cb11-6)    kv.mutex.Lock()\n[](#cb11-7)    defer kv.mutex.Unlock()\n[](#cb11-8)    // ...\n[](#cb11-9)}\n[](#cb11-10)func (kv *KV) Commit(tx *KVTX)  // same\n[](#cb11-11)func (kv *KV) Abort(tx *KVTX)   // same\n```", "```go\n[](#cb12-1)func (kv *KV) Begin(tx *KVTX) {\n[](#cb12-2)    kv.mutex.Lock()\n[](#cb12-3)    defer kv.mutex.Unlock()\n[](#cb12-4)    // read-only snapshot, just the tree root and the page read callback\n[](#cb12-5)    tx.snapshot.root = kv.tree.root\n[](#cb12-6)    chunks := kv.mmap.chunks // copied to avoid updates from writers\n[](#cb12-7)    tx.snapshot.get = func(ptr uint64) []byte { return mmapRead(ptr, chunks) }\n[](#cb12-8)    // ...\n[](#cb12-9)}\n```"]