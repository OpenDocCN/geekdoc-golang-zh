["```\npackage main\n\nimport \"fmt\"\n\ntype maxheap struct {\n    heapArray []int\n    size      int\n    maxsize   int\n}\n\nfunc newMaxHeap(maxsize int) *maxheap {\n    maxheap := &maxheap{\n        heapArray: []int{},\n        size:      0,\n        maxsize:   maxsize,\n    }\n    return maxheap\n}\n\nfunc (m *maxheap) leaf(index int) bool {\n    if index >= (m.size/2) && index <= m.size {\n        return true\n    }\n    return false\n}\n\nfunc (m *maxheap) parent(index int) int {\n    return (index - 1) / 2\n}\n\nfunc (m *maxheap) leftchild(index int) int {\n    return 2*index + 1\n}\n\nfunc (m *maxheap) rightchild(index int) int {\n    return 2*index + 2\n}\n\nfunc (m *maxheap) insert(item int) error {\n    if m.size >= m.maxsize {\n        return fmt.Errorf(\"Heap is full\")\n    }\n    m.heapArray = append(m.heapArray, item)\n    m.size++\n    m.upHeapify(m.size - 1)\n    return nil\n}\n\nfunc (m *maxheap) swap(first, second int) {\n    temp := m.heapArray[first]\n    m.heapArray[first] = m.heapArray[second]\n    m.heapArray[second] = temp\n}\n\nfunc (m *maxheap) upHeapify(index int) {\n    for m.heapArray[index] > m.heapArray[m.parent(index)] {\n        m.swap(index, m.parent(index))\n        index = m.parent(index)\n    }\n}\n\nfunc (m *maxheap) downHeapify(current int) {\n    if m.leaf(current) {\n        return\n    }\n    largest := current\n    leftChildIndex := m.leftchild(current)\n    rightRightIndex := m.rightchild(current)\n    //If current is smallest then return\n    if leftChildIndex < m.size && m.heapArray[leftChildIndex] > m.heapArray[largest] {\n        largest = leftChildIndex\n    }\n    if rightRightIndex < m.size && m.heapArray[rightRightIndex] > m.heapArray[largest] {\n        largest = rightRightIndex\n    }\n    if largest != current {\n        m.swap(current, largest)\n        m.downHeapify(largest)\n    }\n    return\n}\n\nfunc (m *maxheap) buildMaxHeap() {\n    for index := ((m.size / 2) - 1); index >= 0; index-- {\n        m.downHeapify(index)\n    }\n}\n\nfunc (m *maxheap) remove() int {\n    top := m.heapArray[0]\n    m.heapArray[0] = m.heapArray[m.size-1]\n    m.heapArray = m.heapArray[:(m.size)-1]\n    m.size--\n    m.downHeapify(0)\n    return top\n}\n\nfunc main() {\n    inputArray := []int{6, 5, 3, 7, 2, 8}\n    maxHeap := newMaxHeap(len(inputArray))\n    for i := 0; i < len(inputArray); i++ {\n        maxHeap.insert(inputArray[i])\n    }\n    maxHeap.buildMaxHeap()\n    fmt.Println(\"The Max Heap is \")\n    for i := 0; i < len(inputArray); i++ {\n        fmt.Println(maxHeap.remove())\n    }\n}\n```", "```\n8\n7\n6\n5\n3\n2\n```"]