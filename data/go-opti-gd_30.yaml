- en: Tuning DNS Performance in Go Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 Go 服务中的 DNS 性能
- en: 原文：[https://goperf.dev/02-networking/dns_performance/](https://goperf.dev/02-networking/dns_performance/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[原文链接](https://goperf.dev/02-networking/dns_performance/)'
- en: DNS resolution tends to fly under the radar, but it can still slow down Go applications.
    Even brief delays in lookups can stack up in distributed or microservice architectures
    where components frequently communicate. Understanding how Go resolves DNS under
    the hood — and how to adjust it — can make your service more responsive and reliable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 解析通常不会引起注意，但它仍然可能会减慢 Go 应用程序的速度。即使在查找过程中出现短暂的延迟，在组件频繁通信的分布式或微服务架构中，这些延迟也会累积。了解
    Go 在底层如何解析 DNS 以及如何调整它，可以使您的服务更加响应迅速和可靠。
- en: 'How DNS Resolution Works in Go: cgo vs. Native Resolver'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中 DNS 解析的工作原理：cgo 与原生解析器
- en: 'Go supports two different ways of handling DNS queries: the built-in **pure-Go**
    resolver and the **cgo-based** resolver.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持两种处理 DNS 查询的不同方式：内置的 **纯 Go** 解析器和基于 **cgo** 的解析器。
- en: The `pure-Go` resolver is fully self-contained and avoids using any external
    DNS libraries. It reads its configuration from `/etc/resolv.conf` (on Unix-like
    systems) and talks directly to the configured nameservers. This makes it simple
    and generally performant, though it sometimes struggles to handle more exotic
    or highly customized DNS environments.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`纯 Go` 解析器完全自包含，避免使用任何外部 DNS 库。它从 `/etc/resolv.conf`（在类 Unix 系统上）读取其配置，并直接与配置的名称服务器通信。这使得它简单且通常性能良好，尽管它有时难以处理更复杂或高度定制的
    DNS 环境。'
- en: In contrast, the **cgo-based** resolver delegates DNS resolution to the operating
    system’s own resolver (through the C standard library, `libc`). This gives better
    compatibility with complicated or custom DNS environments—like those involving
    LDAP or multicast DNS—but it also comes with a tradeoff. The cgo resolver adds
    overhead due to calls into external C libraries, and it can sometimes lead to
    issues around thread safety or unpredictable latency spikes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于 **cgo** 的解析器将 DNS 解析委托给操作系统的自身解析器（通过 C 标准库 `libc`）。这提供了与复杂或定制 DNS 环境更好的兼容性——例如涉及
    LDAP 或组播 DNS 的环境——但它也带来了一定的权衡。cgo 解析器由于调用外部 C 库而增加了开销，有时还可能导致线程安全或不可预测的延迟峰值。
- en: 'It''s possible to explicitly configure Go to prefer the **pure-Go** resolver
    using an environment variable:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过环境变量显式配置 Go 以优先使用 **纯 Go** 解析器：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, force the use of cgo resolver:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，强制使用 cgo 解析器：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Runtime Dependencies
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时依赖
- en: Enabling cgo changes how the Go binary interacts with the operating system.
    With cgo turned on, the binary no longer stands alone — it links dynamically to
    `libc` and the system loader, which `ldd` reveals in its output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 cgo 改变了 Go 二进制文件与操作系统的交互方式。启用 cgo 后，二进制文件不再独立存在——它动态链接到 `libc` 和系统加载器，这在
    `ldd` 的输出中可以揭示。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A cgo-enabled binary relies on the system’s C runtime (`libc.so.6`) and the
    dynamic loader (`ld-linux`). Without these shared libraries available on the host,
    the binary won’t start — which makes it unsuitable for stripped-down environments
    like scratch containers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 cgo 的二进制文件依赖于系统的 C 运行时（`libc.so.6`）和动态加载器（`ld-linux`）。如果没有在宿主机上提供这些共享库，二进制文件将无法启动——这使得它不适用于像
    scratch 容器这样的简化环境。
- en: 'By contrast, a pure-Go binary is completely self-contained and statically linked.
    If you run `ldd` on it, you’ll simply see:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，纯 Go 二进制文件完全自包含并静态链接。如果您在它上面运行 `ldd`，您将只看到：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This shows that all the code the binary needs is already baked in, with no dependency
    on shared libraries at runtime. Because of this, pure-Go builds are a good fit
    for minimal containers or bare environments without a C runtime, offering better
    portability and fewer operational surprises. The downside is that these binaries
    can’t take advantage of system-level resolver features that require cgo and the
    host’s `libc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明二进制文件所需的全部代码已经内置，无需在运行时依赖共享库。正因为如此，纯 Go 构建非常适合最小化容器或没有 C 运行时的裸环境，提供了更好的可移植性和更少的操作意外。然而，这些二进制文件无法利用需要
    cgo 和宿主机的 `libc` 的系统级解析器功能。
- en: 'DNS Caching: Why and When'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS 缓存：为什么和何时使用
- en: Caching DNS results prevents the application from sending the same queries over
    and over, which can eliminate a noticeable amount of latency. Each lookup incurs
    at least one network round-trip, and when this happens at scale, the cumulative
    cost can become a serious drag on service performance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存DNS结果可以防止应用程序反复发送相同的查询，这可以消除可感知的延迟。每次查找至少涉及一次网络往返，当在规模上发生时，累积的成本可能会成为服务性能的严重拖累。
- en: Many operating systems and hosting environments already include some form of
    DNS caching. On Windows, the `DNS Client` service keeps a local cache; on macOS,
    `mDNSResponder` handles this; and on most Linux systems, `systemd-resolved` or
    `nscd` often provides a caching layer. In cloud environments, DNS queries are
    often routed through a nearby caching resolver inside the same data center. These
    mechanisms do help reduce latency, but they operate transparently to the application
    and offer little visibility or control over TTLs and policies. On Linux, if `systemd-resolved`
    isn’t enabled, no caching happens at all unless you configure it explicitly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作系统和托管环境已经包含某种形式的DNS缓存。在Windows上，`DNS客户端`服务保留本地缓存；在macOS上，`mDNSResponder`处理这个问题；在大多数Linux系统上，`systemd-resolved`或`nscd`通常提供缓存层。在云环境中，DNS查询通常通过同一数据中心附近的一个缓存解析器路由。这些机制确实有助于减少延迟，但它们对应用程序是透明的，并且对TTLs和策略的可见性和控制很少。在Linux上，如果`systemd-resolved`未启用，除非你明确配置，否则根本不会发生任何缓存。
- en: Since Go itself doesn’t include any DNS caching, you have to implement it yourself
    if you want fine-grained, application-level control. One option is to run your
    own caching DNS server nearby; another is to embed a lightweight cache directly
    in your code, using a third-party library.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go本身不包含任何DNS缓存，如果你想实现细粒度、应用级别的控制，你必须自己实现。一个选项是运行你自己的缓存DNS服务器；另一个选项是将轻量级缓存直接嵌入到你的代码中，使用第三方库。
- en: 'Example using [go-cache](https://github.com/patrickmn/go-cache) for a simple
    DNS cache:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[go-cache](https://github.com/patrickmn/go-cache)的简单DNS缓存示例：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Overdoing DNS caching has its downsides — it can leave you serving stale records
    and make your service fragile if upstream addresses change. It’s worth tuning
    your cache expiration times so they reflect how often the domains you rely on
    actually change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 过度使用DNS缓存有其缺点——它可能会导致你服务过时的记录，如果上游地址更改，还会使你的服务变得脆弱。调整你的缓存过期时间，使其反映你依赖的域名实际更改的频率是值得的。
- en: Using Custom Dialers and Pre-resolved IPs
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义拨号器和预解析IP地址
- en: In latency-sensitive services, it often makes sense to resolve DNS up front
    or use a custom dialer to control resolution explicitly. Every call to `net.Dial`
    or `net.DialContext` with a hostname triggers a lookup, which can involve syscalls,
    context switches, and sometimes even a network round-trip if the cache is cold.
    At high throughput, this overhead adds up.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在对延迟敏感的服务中，提前解析DNS或使用自定义拨号器显式控制解析通常是有意义的。每次调用`net.Dial`或`net.DialContext`与主机名都会触发一个查找，这可能涉及系统调用、上下文切换，有时甚至如果缓存是冷的，还会涉及网络往返。在高吞吐量下，这种开销会累积。
- en: To eliminate this overhead, you can resolve hostnames during startup and save
    the resulting IPs. This approach is particularly effective when dealing with a
    fixed set of endpoints that rarely change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这种开销，你可以在启动时解析主机名并保存结果IP地址。这种方法在处理一组固定且很少更改的端点时特别有效。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One drawback is that it fixes the IP for the lifetime of the process, so if
    the endpoint changes its address, connections may start failing. To handle this
    gracefully, you can run a background goroutine that refreshes the resolved IP
    at regular intervals.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺点是它会固定进程生命周期的IP地址，所以如果端点更改了地址，连接可能会开始失败。为了优雅地处理这个问题，你可以运行一个后台goroutine，定期刷新解析的IP地址。
- en: 'Custom dialers take it one step further: they allow you to control how DNS
    resolution and socket establishment occur on a per-connection basis. This will
    enable you to force connections through a specific resolver, hardwire pre-resolved
    IP addresses, or even bypass DNS completely by dialing IP addresses directly.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义拨号器更进一步：它们允许你控制基于每个连接的DNS解析和套接字建立方式。这将使你能够强制通过特定的解析器建立连接，硬编码预解析的IP地址，或者甚至通过直接拨打电话地址来完全绕过DNS。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Custom dialers can also bypass unreliable system resolvers or direct DNS queries
    through a dedicated, faster nameserver. They give you precise control over how
    resolution happens, but that control comes with added complexity — you’ll need
    to handle fallback and refresh logic yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义拨号器也可以绕过不可靠的系统解析器或通过专用、更快的域名服务器直接进行DNS查询。它们让你能够精确控制解析过程，但这种控制也带来了额外的复杂性——你需要自己处理回退和刷新逻辑。
- en: Metrics and Debugging Real-world DNS Slowdowns
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际DNS缓慢的指标和调试技巧
- en: 'Identifying and troubleshooting DNS-induced latency requires insightful metrics
    and targeted debugging techniques. Measuring DNS is not just about seeing how
    fast it is — it helps answer deeper questions: are lookups hitting OS or provider
    caches? is the network path to the DNS server flaky? are specific nameservers
    slower than others? are IPv6 and IPv4 behaving differently? Without visibility,
    DNS issues can silently degrade performance and reliability.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 识别和排除由DNS引起的延迟需要深入的指标和有针对性的调试技术。测量DNS不仅仅是看它有多快——它有助于回答更深层次的问题：查找是否击中了操作系统或提供商的缓存？通往DNS服务器的网络路径是否不可靠？是否有特定的域名服务器比其他服务器慢？IPv6和IPv4的行为是否不同？没有可见性，DNS问题可能会无声地降低性能和可靠性。
- en: Metrics
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指标
- en: Make sure to track DNS resolution times in your service metrics so you can see
    how much time lookups actually add to each request. The simplest way is to wrap
    your DNS calls with a timer that starts just before the lookup and records the
    duration after it completes. Over time, these measurements help you identify trends,
    spot intermittent slowness, and correlate DNS delays with other parts of your
    system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确保跟踪你的服务指标中的DNS解析时间，这样你就可以看到查找实际上为每个请求增加了多少时间。最简单的方法是在查找之前和完成后记录持续时间的计时器包装你的DNS调用。随着时间的推移，这些测量有助于你识别趋势，发现间歇性缓慢，并将DNS延迟与系统其他部分相关联。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looking at high-percentile latencies — like the 95th or 99th — can reveal sporadic
    slowdowns or flaky DNS behavior that averages might hide.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看高百分位延迟——如第95或第99百分位——可以揭示平均可能隐藏的间歇性缓慢或不可靠的DNS行为。
- en: Debugging Tips
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试技巧
- en: 'When facing unexplained latency spikes, leverage Go’s built-in debug mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 面对无法解释的延迟峰值时，利用Go的内置调试模式：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Enabling this produces detailed DNS query logs that show exactly how each request
    is handled from start to finish. You can see when a server responds slowly, when
    lookups fail and trigger retries, or when the runtime unexpectedly falls back
    to the cgo resolver. Such detailed insight makes it much easier to pinpoint elusive
    DNS problems that standard metrics often miss.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能将生成详细的DNS查询日志，显示每个请求从开始到结束的精确处理方式。你可以看到服务器响应缓慢的时间，查找失败并触发重试的时间，或者运行时意外回退到cgo解析器的时间。这种详细的洞察使得定位标准指标经常错过的难以捉摸的DNS问题变得更加容易。
- en: Advanced DNS Performance Tips
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级DNS性能技巧
- en: Running a local DNS caching resolver, such as `dnsmasq` or `Unbound`, close
    to your service can eliminate the extra latency of external lookups. If security
    and privacy are concerns, enabling DNS-over-HTTPS (DoH) or DNS-over-TLS (DoT)
    is also an option, though it comes with some additional latency due to encryption.
    Finally, reviewing and tuning your `/etc/resolv.conf` — adjusting retry counts
    and timeout settings — helps ensure the resolver behaves predictably under load
    or failure conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的服务附近运行本地DNS缓存解析器，如`dnsmasq`或`Unbound`，可以消除外部查找的额外延迟。如果安全和隐私是担忧，启用DNS-over-HTTPS
    (DoH)或DNS-over-TLS (DoT)也是一个选项，尽管它由于加密而带来了一些额外的延迟。最后，审查和调整你的`/etc/resolv.conf`——调整重试次数和超时设置——有助于确保解析器在负载或故障条件下表现出可预测的行为。
