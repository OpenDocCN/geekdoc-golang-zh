- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类。
- en: 'date: 2024-10-13 06:22:01'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-10-13 06:22:01。
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Interface in Go (Golang)
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 中的接口（Golang）。
- en: 来源：[https://golangbyexample.com/interface-in-golang/](https://golangbyexample.com/interface-in-golang/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://golangbyexample.com/interface-in-golang/](https://golangbyexample.com/interface-in-golang/)。
- en: This is the  chapter 21 of the golang comprehensive tutorial series. Refer to
    this link for other chapters of the series – [Golang Comprehensive Tutorial Series](https://golangbyexample.com/golang-comprehensive-tutorial/)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Go 语言综合教程系列的第 21 章。请参考此链接获取系列的其他章节 – [Golang 综合教程系列](https://golangbyexample.com/golang-comprehensive-tutorial/)。
- en: '**Next Tutorial** – [Iota](https://golangbyexample.com/iota-in-golang)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一个教程** – [Iota](https://golangbyexample.com/iota-in-golang)。'
- en: '**Previous Tutorial** – [Method](https://golangbyexample.com/method-in-golang/)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**上一个教程** – [方法](https://golangbyexample.com/method-in-golang/)。'
- en: Now let’s check out the current tutorial. Below is the table of contents for
    current tutorial.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当前的教程。下面是当前教程的目录。
- en: Table of Contents
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目录。
- en: '**   [Overview](#Overview "Overview")'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**[概述](#Overview "概述")**。'
- en: '[Implementing an Interface](#Implementing_an_Interface "Implementing an Interface")'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现接口](#Implementing_an_Interface "实现接口")。'
- en: '[Interface are implemented implicitly](#Interface_are_implemented_implicitly
    "Interface are implemented implicitly")'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接口是隐式实现的](#Interface_are_implemented_implicitly "接口是隐式实现的")。'
- en: '[Interface types as argument to a function](#Interface_types_as_argument_to_a_function
    "Interface types as argument to a function")'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接口类型作为函数参数](#Interface_types_as_argument_to_a_function "接口类型作为函数参数")。'
- en: '[Why Interface](#Why_Interface "Why Interface")'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么使用接口](#Why_Interface "为什么使用接口")。'
- en: '[Pointer Receiver  while implementing an interface](#Pointer_Receiver_while_implementing_an_interface
    "Pointer Receiver  while implementing an interface")'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指针接收者在实现接口时](#Pointer_Receiver_while_implementing_an_interface "指针接收者在实现接口时")。'
- en: '[Non-struct Custom Type Implementing an interface](#Non-struct_Custom_Type_Implementing_an_interface
    "Non-struct Custom Type Implementing an interface")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[非结构体自定义类型实现接口](#Non-struct_Custom_Type_Implementing_an_interface "非结构体自定义类型实现接口")。'
- en: '[Type Implementing multiple interfaces](#Type_Implementing_multiple_interfaces
    "Type Implementing multiple interfaces")'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型实现多个接口](#Type_Implementing_multiple_interfaces "类型实现多个接口")。'
- en: '[Zero Value of Interface](#Zero_Value_of_Interface "Zero Value of Interface")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接口的零值](#Zero_Value_of_Interface "接口的零值")。'
- en: '[Inner Working of Interface](#Inner_Working_of_Interface "Inner Working of
    Interface")'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接口的内部工作原理](#Inner_Working_of_Interface "接口的内部工作原理")。'
- en: '[Embedding Interfaces](#Embedding_Interfaces "Embedding Interfaces")'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[嵌入接口](#Embedding_Interfaces "嵌入接口")。'
- en: '[Embedding interface in other interface](#Embedding_interface_in_other_interface
    "Embedding interface in other interface")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在其他接口中嵌入接口](#Embedding_interface_in_other_interface "在其他接口中嵌入接口")。'
- en: '[Embedding interface in a struct](#Embedding_interface_in_a_struct "Embedding
    interface in a struct")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在结构体中嵌入接口](#Embedding_interface_in_a_struct "在结构体中嵌入接口")。'
- en: '[Access Underlying Variable of Interface](#Access_Underlying_Variable_of_Interface
    "Access Underlying Variable of Interface")'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[访问接口的底层变量](#Access_Underlying_Variable_of_Interface "访问接口的底层变量")。'
- en: '[Type Assertion](#Type_Assertion "Type Assertion")'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型断言](#Type_Assertion "类型断言")。'
- en: '[Type Switch](#Type_Switch "Type Switch")'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型切换](#Type_Switch "类型切换")。'
- en: '[Empty interface](#Empty_interface "Empty interface")'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[空接口](#Empty_interface "空接口")。'
- en: '[Conclusion](#Conclusion "Conclusion")*  *# **Overview**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#Conclusion "结论")*  *# **概述**'
- en: Interface is a type in Go which is a collection of method signatures. These
    collections of method signatures are meant to represent certain behaviour. The
    interface declares only the method set and any type which implements all methods
    of the interface is of that interface type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是 Go 中的一种类型，它是方法签名的集合。这些方法签名的集合旨在表示某种行为。接口只声明方法集，任何实现了接口所有方法的类型都是该接口类型。
- en: Interface lets you use duck typing in golang. Now, what is duck typing?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接口让你在 Golang 中使用鸭子类型。现在，什么是鸭子类型？
- en: Duck typing is a way in computer programming which lets you do duck test where
    we do not check type instead we check the only presence of some attributes or
    methods. So what really matters is whether an object has certain attributes and
    methods and not its type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型是一种计算机编程方式，让你进行鸭子测试，我们不检查类型，而是只检查某些属性或方法的存在。因此，真正重要的是对象是否具有某些属性和方法，而不是它的类型。
- en: Duck typing comes from the below phrase
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型源于以下短语。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Coming back to interface again. So what is interface?  As mentioned before also
    it is a collection of method signatures. It defines the exact set of methods that
    a type might have. Below is the signature of an interface, it has only method
    signatures
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到接口。那么，什么是接口？正如之前提到的，它是方法签名的集合。它定义了一个类型可能拥有的确切方法集。下面是一个接口的签名，它仅包含方法签名。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s understand the concept with the help of an example. Things will be more
    clear then. Let’s define an interface named **animal.** The **animal** interface
    has two methods **breathe** and **walk**. It defines only the method signatures
    and nothing else.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念。这样会更加清晰。我们定义一个名为**动物**的接口。**动物**接口有两个方法**呼吸**和**行走**。它仅定义方法签名，而没有其他内容。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A method signature would include
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名包括
- en: Name of the method
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的名称
- en: Number of arguments and type of each argument
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的数量和每个参数的类型
- en: Number of return values and type of each return value
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的数量和每个返回值的类型
- en: With the above declaration, we created a new interface type i.e **animal.**
    It is ok to define a variable of **animal** type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述声明，我们创建了一个新的接口类型，即**动物**。定义一个**动物**类型的变量是可以的。
- en: Let’s create a variable of **animal** interface type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个**动物**接口类型的变量。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Output**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen in the above program it is ok to create a variable of interface type.
    It prints nil as the default zero value of an interface is nil.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如上程序所示，创建一个接口类型的变量是可以的。它打印nil，因为接口的默认零值是nil。
- en: '**Implementing an Interface**'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**实现接口**'
- en: Any type which implements the breathe and walk method then it is said to implement
    the **animal** interface. So if we define a **lion** struct and implements the
    breathe and walk method then it will implement the animal interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了呼吸和行走方法的类型都被称为实现了**动物**接口。所以如果我们定义一个**狮子**结构体并实现呼吸和行走方法，那么它就会实现动物接口。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Output**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We declare a variable of animal interface type
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个动物接口类型的变量。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we assign an instance of lion struct to it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将一个狮子结构体的实例赋值给它。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Assigning an instance of **lion** struct to a variable of **animal** interface
    type works because **lion** struct implements both **breathe** and **walk** method
    of the animal. The type is not checked during this assignment, instead, it is
    enough to check that the type assigned does implement **breathe** and **walk**
    method.  The concept is similar to duck typing,  a **lion** can **breathe** and
    **walk** like an **animal** and hence it is an **animal**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将**狮子**结构体的一个实例分配给**动物**接口类型的变量是可行的，因为**狮子**结构体实现了**呼吸**和**行走**这两个方法。在这个赋值过程中并不会检查类型，而只需检查被分配的类型是否实现了**呼吸**和**行走**这两个方法。这个概念类似于鸭子类型，**狮子**能够像**动物**一样**呼吸**和**行走**，因此它就是一种**动物**。
- en: If you notice that there is no explicit declaration that the lion type implements
    the animal interface. This brings a very important property related to interface
    – ‘Interface are implemented implicitly
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，并没有明确声明狮子类型实现了动物接口。这带来了与接口相关的一个非常重要的属性——“接口是隐式实现的”。
- en: '**Interface are implemented implicitly**'
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**接口是隐式实现的**'
- en: There is no explicit declaration that a type implements an interface. In fact,
    in Go there doesn’t exist any **“implements”** keyword similar to Java.  A type
    implements an interface if it implements all the methods of the interface.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有明确声明一个类型实现了一个接口。实际上，在Go中并不存在类似于Java的**“implements”**关键字。如果一个类型实现了接口的所有方法，它就实现了该接口。
- en: As seen above, It is correct to define a variable of an interface type and we
    can assign any concrete type value to this variable if the concrete type implements
    all the methods of the interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所见，定义一个接口类型的变量是正确的，并且如果具体类型实现了接口的所有方法，我们可以将任何具体类型的值分配给这个变量。
- en: There is no explicit declaration that says that **lion** struct implements the
    **animal** interface. During compilation, go notices that **lion** struct implements
    all methods of **animal** interface hence it is allowed. Any other type which
    implements all methods of the **animal** interface becomes of that interface type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有明确声明**狮子**结构体实现了**动物**接口。在编译期间，Go会注意到**狮子**结构体实现了**动物**接口的所有方法，因此这是允许的。任何实现了**动物**接口所有方法的其他类型都成为该接口类型。
- en: Let’s see a more complex example of another type implementing the animal interface.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个类型实现动物接口的更复杂的例子。
- en: If we define a **dog** struct and it implements the **breathe** and **walk**
    method then it will also be an animal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个**狗**结构并且它实现了**呼吸**和**行走**方法，那么它也将是动物。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Output**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both **lion** and **dog** implement the breathe and walk method hence they are
    of animal type and can correctly be assigned to a variable of interface type.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**狮子**和**狗**都实现了呼吸和行走方法，因此它们属于动物类型，并且可以正确地分配给接口类型的变量。'
- en: The **animal** interface variable a was assigned a **lion** instance first and
    then the same variable was assigned a **dog** instance. So the type which interface
    variable refers to is dynamic.  It dynamically holds a reference to the underlying
    type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接口变量a最初被分配为**狮子**实例，然后同一变量被分配为**狗**实例。因此，接口变量所引用的类型是动态的。它动态地持有对底层类型的引用。
- en: 'Two important points to note:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的两个重要点：
- en: The interface static check is done during compile time – means that if a type
    doesn’t implement all the methods of an interface, then assigning the type instance
    to a variable of that interface type will raise an error during compile time.
    Eg. on deleting the walk method defined on lion struct, below error will be raised
    during the assignment
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口静态检查是在编译时进行的——这意味着如果一个类型没有实现接口的所有方法，则将该类型实例分配给该接口类型的变量将在编译时引发错误。例如，在删除定义在狮子结构上的行走方法时，下面的错误将在赋值过程中被引发。
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The correct method based on the type of instance is called at run time – means
    that the method of either lion or dog is called depending upon whether interface
    variable refers to an instance of lion or dog. If it refers to an instance of
    lion, then lion’s method is called and if it refers to an instance of dog, then
    dog’s method is called. That is also proven from the output. This is a way to
    achieve runtime polymorphism in Go.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据实例的类型，在运行时调用正确的方法——这意味着根据接口变量引用的是狮子实例还是狗实例来调用相应的方法。如果它引用的是狮子实例，则调用狮子的方法；如果它引用的是狗实例，则调用狗的方法。这也从输出中得到了验证。这是在Go中实现运行时多态性的一种方式。
- en: It is also to be noted that the methods defined by the type,  should match the
    entire signature of methods in the interface ie., it should match
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意，类型定义的方法应与接口中方法的整个签名匹配，即应匹配。
- en: Name of the method
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的名称
- en: Number of arguments and type of each argument
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的数量和每个参数的类型
- en: Number of return values and type of each return value
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的数量和每个返回值的类型。
- en: Imagine that **animal** interface has another method **speed** which returns
    the int value of speed of the animal
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，**动物**接口还有另一个方法**速度**，返回动物速度的int值。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the **lion** struct has **speed** method as below which does not return the
    int value, then the **lion** struct will not implement **animal** interface
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**狮子**结构具有如下的**速度**方法，但不返回int值，则**狮子**结构将不实现**动物**接口。
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Below compilation error will be raised on assigning the lion instance to a variable
    of type animal
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将狮子实例分配给动物类型的变量时将引发下面的编译错误。
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So in essence, method signatures are important while implementing an interface
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从本质上讲，方法签名在实现接口时是重要的。
- en: '**Interface types as argument to a function**'
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**作为函数参数的接口类型**'
- en: A function can accept an argument of an interface type. Any type which implements
    that interface can be passed as that argument to that function. For example, in
    the below code, we have **callBreathe** and **callWalk** function which accept
    an argument of **animal** interface type. Both **lion** and **dog** instance can
    be passed to this function. We create an instance of both lion and dog type and
    pass it to the function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受接口类型的参数。任何实现该接口的类型都可以作为该参数传递给该函数。例如，在下面的代码中，我们有**callBreathe**和**callWalk**函数，它们接受**动物**接口类型的参数。**狮子**和**狗**实例都可以传递给这个函数。我们创建狮子和狗类型的实例，并将其传递给函数。
- en: It works similarly to the assignment we discussed above. During compilation
    no type is checked while calling the function,  instead, it is enough to check
    that the type passed to the function does implement **breathe** and **walk** method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式类似于我们上面讨论的赋值。在编译过程中，调用函数时不会检查类型，而是只需检查传递给函数的类型是否实现了**呼吸**和**行走**方法。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Output**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above code, we have **callBreathe** and **callWalk** function which accept
    an argument of **animal** interface type. Both **lion** and **dog** instance can
    be passed to this function. We create an instance of both **lion** and **dog**
    type and pass it to the function. During compilation no type is checked while
    calling the function, instead, it is enough to check that the type passed to the
    function does implement **breathe** and **walk** method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有**callBreathe**和**callWalk**函数，它们接受一个**animal**接口类型的参数。**lion**和**dog**实例都可以传递给这个函数。我们创建了**lion**和**dog**类型的实例并将其传递给函数。在编译期间，调用函数时不检查类型，而只需检查传递给函数的类型是否实现了**breathe**和**walk**方法。
- en: '**Why Interface**'
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**为什么使用接口**'
- en: Below are some benefits of using interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用接口的一些好处。
- en: Helps write more modular and decoupled code between different parts of codebase
    – It can help reduce dependency between different parts of codebase and provide
    loose coupling.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于在代码库的不同部分之间编写更模块化和解耦的代码——它可以帮助减少代码库不同部分之间的依赖，并提供松耦合。
- en: For eg imagine an application interacting with a database layer. If the application
    interacts with the database using the interface, then it never gets to know about
    what kind of database is being used in the background. You can change the type
    of database in the background, let’s say from arango db to mongo db without any
    change in the application layer as it interacts with the database layer via an
    interface which both arango db and mongo db implement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 比如想象一个与数据库层交互的应用程序。如果该应用程序通过接口与数据库交互，那么它永远不会知道后台使用的是哪种数据库。你可以在后台更改数据库的类型，比如从arango
    db更改为mongo db，而应用层无需任何更改，因为它通过实现该接口的arango db和mongo db与数据库层交互。
- en: Interface can be used to achieve run time polymorphism in golang. RunTime Polymorphism
    means that a call is resolved at runtime. Let’s understand how interface can be
    used to achieve runtime polymorphism with an example
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以用于实现golang中的运行时多态性。运行时多态性意味着调用在运行时被解析。让我们通过一个示例了解如何使用接口实现运行时多态性。
- en: Different countries have different ways of calculating the tax. This can be
    represented by means of an interface.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不同国家有不同的税收计算方式。这可以通过接口来表示。
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now different countries can have their own struct and can implement the **calculateTax()**
    method. The same **calculateTax** method is used in different contexts to calculate
    tax. When the compiler sees this call it delays which exact method to be called
    at run time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不同国家可以有自己的结构体并实现**calculateTax()**方法。同样的**calculateTax**方法在不同上下文中用于计算税。编译器在看到这个调用时，会延迟确定在运行时调用哪个确切的方法。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Output:**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now below is the line where run time polymorphism happens.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下面是运行时多态性发生的地方。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The correct **calculateTax()** method is called based upon weather the instance
    is of type **singaporeTax** struct tax or **indianTax** struct
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的**calculateTax()**方法根据实例是否为**singaporeTax**结构体税或**indianTax**结构体税被调用。
- en: '**Pointer Receiver  while implementing an interface**'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**使用指针接收器实现接口**'
- en: Amethod of a type can either have a pointer receiver or a value receiver. In
    the above examples, we only worked with the value receiver. It is to be noted
    that the pointer receiver can also be used to implement an interface. But there
    is a caveat here
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的方法可以具有指针接收器或值接收器。在上述示例中，我们只使用了值接收器。需要注意的是，指针接收器也可以用来实现接口。但这里有一个警告。
- en: If a type implements all methods of an interface using value receiver, then
    both variable of that type as well pointer to the variable of that type can be
    used while assigning to that interface or while passing to a function which accepts
    an argument as that interface.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型使用值接收器实现接口的所有方法，那么在将该类型的变量或该类型变量的指针赋值给接口或传递给接受该接口参数的函数时，两者都可以使用。
- en: If a type implements all methods of an interface using pointer receiver, then
    the only pointer to the variable of that type can be used while assigning to that
    interface or while passing to a function that accepts an argument as that interface.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型使用指针接收器实现接口的所有方法，那么在将该类型的变量赋值给接口或传递给接受该接口参数的函数时，只有该变量的指针可以使用。
- en: Example to demonstrate the first point above
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例以演示上述第一点
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Output**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The **lion** structs implements the **animal** interface using value receiver.
    Hence it works for both variable of type **lion** as well as pointer to variable
    of type **lion**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**狮子**结构体通过值接收器实现了**动物**接口。因此，它适用于**狮子**类型的变量和指向**狮子**类型变量的指针。'
- en: This works
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作。
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: as well as this
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有这一点。
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example to demonstrate the second point above. The **lion** structs implements
    the **animal** interface using pointer receiver. Hence it  works for only for
    pointer to variable of type **lion**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例以演示上述第二点。**狮子**结构体通过指针接收器实现了**动物**接口。因此，它仅适用于指向**狮子**类型变量的指针。
- en: So this works
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这可以工作。
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: but this raises compilation error
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会引发编译错误。
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See full working code
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查看完整的工作代码。
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Uncomment the line
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释该行。
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: and it will raise compilation error
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会引发编译错误。
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Non-struct Custom Type Implementing an interface**'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**非结构自定义类型实现接口**'
- en: So far we have only seen examples of struct type implementing an interface. 
    It is also perfectly ok for any non-struct custom type to implement an interface.
    Let’s see an example
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了结构类型实现接口的例子。任何非结构自定义类型实现接口也是完全可以的。让我们看一个例子。
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Output**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The above program illustrates the concept that any custom type can also implement
    an interface. The **cat** is of string type and it implements the **breathe**
    and **walk** method hence it is correct to assign an instance of **cat** type
    to a variable of **animal** type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序说明了任何自定义类型也可以实现接口的概念。**猫**是字符串类型，它实现了**呼吸**和**行走**方法，因此将**猫**类型的实例赋值给**动物**类型的变量是正确的。
- en: '**Type Implementing multiple interfaces**'
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**类型实现多个接口**'
- en: A type implements an interface if it defines all methods of an interface. If
    that defines all methods of another interface then it implements that interface.
    In essence, a type can implement multiple interfaces.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型定义了接口的所有方法，则该类型实现了该接口。如果它定义了另一个接口的所有方法，那么它也实现了那个接口。从本质上讲，一个类型可以实现多个接口。
- en: In below program, we have a mammal interface that has a feed method. The lion
    struct defines this method too hence it implements the mammal interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的程序中，我们有一个哺乳动物接口，具有一个进食方法。狮子结构体也定义了这个方法，因此它实现了哺乳动物接口。
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Output**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Zero Value of Interface**'
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**接口的零值**'
- en: Default or zero value of an interface is nil. Below program demonstrates that
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的默认或零值是nil。下面的程序演示了这一点。
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Output**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Inner Working of Interface**'
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**接口的内部工作原理**'
- en: Like any other variable, an interface variable is represented by a type and
    value. Interface value, in turn under the hood, consists of two tuple
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他变量一样，接口变量由类型和值表示。接口值在底层由两个元组组成。
- en: Underlying Type
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层类型
- en: Underlying Value
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层值
- en: See below diagram which illustrates what we mentioned above
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下面的图示，说明了我们上面提到的内容。
- en: '![](img/e09464771d53171817cfeecf9da6a93e.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e09464771d53171817cfeecf9da6a93e.png)'
- en: For eg in case of lion struct implementing the animal interface would be like
    below
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，狮子结构体实现动物接口如下。
- en: '![](img/c9cc4eb8c2e7148fd7877e127d773ca6.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9cc4eb8c2e7148fd7877e127d773ca6.png)'
- en: Golang provides format identifiers to print the underlying type and underlying
    value represented by the interface value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Golang提供了格式标识符，以打印由接口值表示的底层类型和底层值。
- en: '%T can be used to print the concrete type of the interface value'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%T可以用来打印接口值的具体类型。'
- en: '%v can be used to print the concrete value of the interface value.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%v可以用来打印接口值的具体值。'
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Output**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: An interface can be embedded in other interface as well as it can be embedded
    in a struct. Let’s look at each one by one
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以嵌入其他接口，也可以嵌入结构体。让我们逐一看看。
- en: '**Embedding Interfaces**'
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**嵌入接口**'
- en: An interface can be embedded in other interface as well as it can be embedded
    in a struct. Let’s look at each one by one
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以嵌入其他接口，也可以嵌入结构体。让我们逐一看看。
- en: '**Embedding interface in other interface**'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在其他接口中嵌入接口**'
- en: An interface can embed any number of interfaces in it as well as it can be embedded
    in any interface. All the methods of the embedded interface become part of the
    embedding interface. It is a way of creating a new interface by merging some small
    interfaces. Let’s understand it with an example
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口可以嵌入任意数量的接口，也可以嵌入任何接口。嵌入接口的所有方法都成为嵌入接口的一部分。这是通过合并一些小接口来创建新接口的一种方式。让我们通过一个例子来理解。
- en: Assume we have an interface **animal** as below
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个接口**动物**如下。
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s say there is another interface named **human** which embeds the **animal**
    interface
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设还有一个名为 **human** 的接口，它嵌入了 **animal** 接口。
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So if any type needs to implement the **human** interface, then it has to define
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果任何类型需要实现 **human** 接口，则必须定义
- en: '**breathe()** and **walk()** method of animal interfaces animal is  embedded
    in human'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**breathe()** 和 **walk()** 方法的动物接口嵌入在 **human** 中'
- en: '**speak()** method of human interface'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**speak()** 方法的人类接口'
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Output**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As an other example, the ReaderWriter interface of the **io** package of golang
    ([https://golang.org/pkg/io/#ReadWriter](https://golang.org/pkg/io/#ReadWriter))
    embeds two other interfaces
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，golang 的 **io** 包的 ReaderWriter 接口 ([https://golang.org/pkg/io/#ReadWriter](https://golang.org/pkg/io/#ReadWriter))
    嵌入了两个其他接口。
- en: The reader interface  – [https://golang.org/pkg/io/#Reader](https://golang.org/pkg/io/#Reader)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reader 接口 – [https://golang.org/pkg/io/#Reader](https://golang.org/pkg/io/#Reader)
- en: The writer interface   – [https://golang.org/pkg/io/#Writer](https://golang.org/pkg/io/#Writer)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: writer 接口 – [https://golang.org/pkg/io/#Writer](https://golang.org/pkg/io/#Writer)
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Embedding interface in a struct**'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在结构中嵌入接口**'
- en: Aninterface can be embedded in a struct as well.  All the methods of the embedded
    interface can be called via that struct. How these methods will be called will
    depend upon whether the embedded interface is a named field or an unnamed/anonymous
    field.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以嵌入到结构中。所有嵌入接口的方法都可以通过该结构调用。这些方法的调用方式取决于嵌入接口是命名字段还是未命名/匿名字段。
- en: If the embedded interface is a named field, then interface methods has to be
    called via the named interface name
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果嵌入接口是命名字段，则接口方法必须通过命名接口名称调用
- en: If the embedded interface is unnamed/anonymous field then interface methods
    can be referred directly or via the interface name
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果嵌入接口是未命名/匿名字段，则可以直接或通过接口名称引用接口方法
- en: Let’s see a program illustrating above points
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个程序，说明上述要点
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Output**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We declared two struct **pet1** and **pet2**.  **pet1** struct has named **animal**
    interface in it
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个结构 **pet1** 和 **pet2**。 **pet1** 结构中有命名的 **animal** 接口
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**pet2** has unnamed/anonymous **animal** interface embedded'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**pet2** 嵌入了未命名/匿名 **animal** 接口'
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For an instance of **pet1** struct we call the **breathe()** and **walk()**
    method like this
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **pet1** 结构的实例，我们可以这样调用 **breathe()** 和 **walk()** 方法。
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Directly calling these methods with raise compilation error
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用这些方法将引发编译错误
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For an instance of **pet2** struct we can call the **breathe()** and **walk()**
    method like directly
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **pet2** 结构的实例，我们可以直接调用 **breathe()** 和 **walk()** 方法
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can directly access the methods of embedded interface if the embedded interface
    is anonymous or unnamed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果嵌入接口是匿名或未命名的，我们可以直接访问嵌入接口的方法。
- en: Below is also valid and another way fo called methods of unnamed/anonymous embedded
    interface
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面也是有效的，另一种调用未命名/匿名嵌入接口方法的方式
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Also note that while creating the instance of either the **pet1** or **pet2**
    struct, the embedded interface i.e **animal** is initialised with a type implementing 
    it i.e **dog** .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，在创建 **pet1** 或 **pet2** 结构的实例时，嵌入的接口 **animal** 是用实现该接口的类型 **dog** 初始化的。
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we don’t initialise the embedded interface **animal**, then it will be intialised
    with the zero value of the interface which is nil. Calling **breathe()** and **walk()**
    method  on such an instance of **pet1** or **pet2** struct will create a panic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不初始化嵌入接口 **animal**，则它将被初始化为接口的零值，即 nil。在这样的 **pet1** 或 **pet2** 结构的实例上调用
    **breathe()** 和 **walk()** 方法将导致恐慌。
- en: '**Access Underlying Variable of Interface**'
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**访问接口的底层变量**'
- en: The underlying variable can be accessed in two ways
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过两种方式访问底层变量
- en: Type Assertion
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言
- en: Type Switch
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型切换
- en: '**Type Assertion**'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**类型断言**'
- en: Type assertion provides a way to access the underlying variable inside the interface
    value of the interface by asserting the correct type of underlying value. Below
    is the syntax for that where **i** is an interface.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言提供了一种通过断言底层值的正确类型来访问接口值内部的底层变量的方法。下面是其语法，其中 **i** 是一个接口。
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The above statement is asserting that the type of underlying value in the interface
    is of type {type}. If this is true then the underlying value is assigned to **val.**
    If not then the above statement panics.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明断言接口中的底层值的类型为 {type}。如果这个断言成立，则将底层值分配给 **val**。如果不成立，则上述声明将导致恐慌。
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Output**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is how we assert the variable **a** of type **animal** to have underlying
    type as **lion**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何断言变量 **a** 的类型 **animal** 为底层类型 **lion**。
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Below line will create a panic as underlying type is **lion** and not **dog**.
    Uncomment the line to check it out
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行将引发程序崩溃，因为底层类型是**狮子**而不是**狗**。取消注释该行以查看效果。
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Type assertion provides another way to get the underlying value and which also
    prevents a panic. The syntax for that is
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言提供了获取底层值的另一种方法，同时也能防止程序崩溃。其语法为：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this case type assertion returns two values, the first value is the same
    as discussed above, the other value is boolean indicating whether the type assertion
    was correct or not. This value is
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类型断言返回两个值，第一个值与上面讨论的相同，另一个值是布尔值，指示类型断言是否正确。这个值是：
- en: true if the type assertion is correct meaning the type asserted is same as the
    underlying type
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型断言正确，则返回true，意味着断言的类型与底层类型相同。
- en: false if the type assertion fails.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型断言失败，则返回false。
- en: So the second is a good way of doing type assertion since it prevents a panic.
    Let’s see an example
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以第二种方法是一种良好的类型断言方式，因为它可以防止程序崩溃。让我们来看一个例子。
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Output:**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let’s move on to type switch now.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论类型开关。
- en: '**Type Switch**'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**类型开关**'
- en: Type switch enables us to do above type assertion in series. See below code
    example for the same
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类型开关使我们能够连续进行上述类型断言。请参见下面的代码示例。
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Output:**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the code above, using the type switch we determine the type of value contained
    in interface variable x is **lion** or **dog** or some other type. It is also
    ok to add more different types in case statement
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，使用类型开关我们可以确定接口变量x中包含的值的类型是**狮子**、**狗**或其他某种类型。也可以在case语句中添加更多不同的类型。
- en: '**Empty interface**'
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**空接口**'
- en: An empty interface has no methods , hence by default all concrete types implement
    the empty interface. If you write a function that accepts an empty interface then
    you can pass any type to that function. See working code below
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 空接口没有方法，因此默认情况下，所有具体类型都实现空接口。如果你编写一个接受空接口的函数，那么你可以将任何类型传递给该函数。请参见下面的工作代码。
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Output**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Conclusion**'
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This is all about interface in go. Hope you have liked this article. Please
    share feedback/improvemets/mistakes in comments.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Go语言中的接口。希望你喜欢这篇文章。请在评论中分享反馈/改进建议/错误。
- en: '**Next Tutorial** – [Iota](https://golangbyexample.com/iota-in-golang)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一教程** – [Iota](https://golangbyexample.com/iota-in-golang)'
- en: '**Previous Tutorial** – [Method](https://golangbyexample.com/method-in-golang/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**上一教程** – [方法](https://golangbyexample.com/method-in-golang/)'
- en: '[go](https://golangbyexample.com/tag/go/)*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[go](https://golangbyexample.com/tag/go/)*'
