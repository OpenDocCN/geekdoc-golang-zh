- en: Immutable Data Sharing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变数据共享
- en: 原文：[https://goperf.dev/01-common-patterns/immutable-data/](https://goperf.dev/01-common-patterns/immutable-data/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/immutable-data/](https://goperf.dev/01-common-patterns/immutable-data/)
- en: 'One common source of slowdown in high-performance Go programs is the way shared
    data is accessed under concurrency. The usual tools—mutexes and channels—work
    well, but they’re not free. Mutexes can become choke points if many goroutines
    try to grab the same lock. Channels, while elegant for coordination, can introduce
    blocking and make control flow harder to reason about. Both require careful use:
    it’s easy to introduce subtle bugs or unexpected performance issues if synchronization
    isn’t tight.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能Go程序中常见的性能瓶颈之一是并发下共享数据的访问方式。常用的工具——互斥锁和通道——效果很好，但它们不是免费的。如果许多goroutine尝试获取相同的锁，互斥锁可能会成为瓶颈。通道虽然优雅，但可能会引入阻塞，使控制流更难推理。两者都需要谨慎使用：如果同步不紧密，很容易引入微妙的错误或意外的性能问题。
- en: A powerful alternative is immutable data sharing. Instead of protecting data
    with locks, you design your system so that shared data is never mutated after
    it's created. This minimizes contention and simplifies reasoning about your program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的替代方案是不可变数据共享。不是用锁保护数据，而是设计你的系统，使得创建后的共享数据永远不会被修改。这最小化了竞争并简化了程序推理。
- en: Why Immutable Data?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用不可变数据？
- en: 'Immutability brings several advantages to concurrent programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性为并发程序带来了几个优点：
- en: 'No locks needed: Multiple goroutines can safely read immutable data without
    synchronization.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要锁：多个goroutine可以安全地读取不可变数据，无需同步。
- en: 'Easier reasoning: If data can''t change, you avoid entire classes of race conditions.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易推理：如果数据不能改变，你可以避免整个类别的竞争条件。
- en: 'Copy-on-write optimizations: You can create new versions of a structure without
    altering the original, which is useful for config reloading or versioning a state.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写时复制优化：你可以创建结构体的新版本而不改变原始版本，这在配置重载或版本化状态时很有用。
- en: 'Practical Example: Shared Config'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例：共享配置
- en: Imagine you have a long-running service that periodically reloads its configuration
    from a disk or a remote source. Multiple goroutines read this configuration to
    make decisions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个长期运行的服务，它定期从磁盘或远程源重新加载其配置。多个goroutine读取此配置以做出决策。
- en: 'Here''s how immutable data helps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何不可变数据帮助的：
- en: 'Step 1: Define the Config Struct'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：定义Config结构体
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Step 2: Ensure Deep Immutability'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：确保深度不可变性
- en: 'Maps and slices in Go are reference types. Even if the Config struct isn''t
    changed, someone could accidentally mutate a shared map. To prevent this, we make
    defensive copies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的映射和切片是引用类型。即使Config结构体没有改变，也可能有人意外地修改共享的映射。为了防止这种情况，我们进行防御性复制：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, every config instance is self-contained and safe to share.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个配置实例都是自包含的，并且可以安全地共享。
- en: 'Step 3: Atomic Swapping'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：原子交换
- en: Use `atomic.Value` to store and safely update the current config.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`atomic.Value`来存储和安全地更新当前配置。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now all goroutines can safely call `GetConfig()` with no locks. When the config
    is reloaded, you just `Store` a new immutable copy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有goroutine都可以安全地调用`GetConfig()`而不需要锁。当配置重新加载时，你只需`Store`一个新的不可变副本。
- en: 'Step 4: Using It in Handlers'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：在处理程序中使用它
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Practical Example: Immutable Routing Table'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例：不可变路由表
- en: Suppose you're building a lightweight reverse proxy or API gateway and must
    route incoming requests based on path or host. The routing table is read thousands
    of times per second and updated only occasionally (e.g., from a config file or
    service discovery).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个轻量级的反向代理或API网关，必须根据路径或主机路由传入的请求。路由表每秒被读取数千次，但只偶尔更新（例如，从配置文件或服务发现）。
- en: 'Step 1: Define Route Structs'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：定义路由结构体
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Step 2: Build Immutable Version'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：构建不可变版本
- en: To ensure immutability, we deep-copy the slice of routes when constructing a
    new routing table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保不可变性，我们在构建新的路由表时深度复制路由切片。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Step 3: Store It Atomically'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：原子存储
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Step 4: Route Requests Concurrently'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：并发路由请求
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, your routing logic can scale safely under load with zero locking overhead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的路由逻辑可以在负载下安全地扩展，没有锁的开销。
- en: Scaling Immutable Routing Tables
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展不可变路由表
- en: As systems grow, routing tables can expand to hundreds or even thousands of
    entries. While immutability brings clear benefits—safe concurrent access, predictable
    behavior—it becomes costly if every update means copying the entire structure.
    At some point, rebuilding the whole table for each minor change doesn’t scale.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的增长，路由表可以扩展到数百甚至数千个条目。虽然不可变性带来了明显的优势——安全并发访问、可预测的行为——但如果每次更新都需要复制整个结构，这就会变得成本高昂。在某个点上，为每个小更改重建整个表是不具扩展性的。
- en: To keep immutability without paying for full reconstruction on every update,
    the design needs to evolve. There are several ways to do this—each preserving
    the core benefits while reducing overhead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不为每次更新支付完整重建费用的情况下保持不可变性，设计需要进化。有几种方法可以实现这一点——每种方法都保留了核心优势，同时减少了开销。
- en: 'Scenario 1: Segmented Routing'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景1：分段路由
- en: 'Imagine a multi-tenant system where each customer has their own set of routing
    rules. Instead of one giant slice of routes, you can split them into a map:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个多租户系统，其中每个客户都有自己的路由规则集。您可以将它们拆分为一个映射：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If only customer "acme" updates their rules, you clone just that slice and update
    the map. Then you atomically swap in a new version of the full map. All other
    tenants continue using their existing, untouched routing tables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有客户“acme”更新其规则，您只需克隆该部分并更新映射。然后您原子性地交换新版本的完整映射。所有其他租户继续使用他们现有的、未受影响的路由表。
- en: 'This approach reduces memory pressure and speeds up updates without losing
    immutability. It also isolates blast radius: a broken rule set in one segment
    doesn’t affect others.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以减少内存压力并加快更新速度，同时不会失去不可变性。它还可以隔离爆炸半径：一个段中损坏的规则集不会影响其他段。
- en: 'Scenario 2: Indexed Routing Table'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景2：索引路由表
- en: 'Let’s say your router matches by exact path, and lookup speed is critical.
    You can use a `map[string]RouteHandler` as an index:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的路由器通过精确路径进行匹配，并且查找速度至关重要。您可以使用`map[string]RouteHandler`作为索引：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a new path is added, clone the current map, add the new route, and publish
    the new version. Because maps are shallow, this is fast for moderate numbers of
    routes. Reads are constant time, and updates are efficient because only a small
    part of the structure changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新路径时，克隆当前映射，添加新路由，并发布新版本。由于映射是浅层的，对于中等数量的路由来说，这很快。读取是常数时间，更新效率高，因为只有结构的一小部分发生变化。
- en: 'Scenario 3: Hybrid Staging and Publishing'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景3：混合预演和发布
- en: 'Suppose you’re doing a batch update — maybe reading hundreds of routes from
    a database. Instead of rebuilding live, you keep a mutable staging area:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在进行批量更新——比如从数据库中读取数百个路由。您不必重建实时数据，而是保持一个可变的预演区域：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You load and manipulate data in staging under a mutex, then convert to an immutable
    `RoutingTable` and store it atomically. This lets you safely prepare complex changes
    without locking readers or affecting live traffic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在预演阶段，您在互斥锁下加载数据并进行操作，然后将数据转换为不可变的`RoutingTable`并原子性地存储。这允许您在无需锁定读取者或影响实时流量的情况下安全地准备复杂更改。
- en: Benchmarking Impact
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响
- en: Benchmarking immutable data sharing in real-world systems is difficult to do
    in a generic, meaningful way. Factors like structure size, read/write ratio, and
    memory layout all heavily influence results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界系统中进行不可变数据共享的基准测试很难以通用和有意义的方式进行。结构大小、读写比和内存布局等因素都会严重影响结果。
- en: Rather than presenting artificial benchmarks here, we recommend reviewing the
    results in the [Atomic Operations and Synchronization Primitives](../atomic-ops/#benchmarking-impact)
    article. Those benchmarks clearly illustrate the potential performance benefits
    of using atomic.Value over traditional synchronization primitives like sync.RWMutex,
    especially in highly concurrent read scenarios.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在这里展示人工基准，我们建议您查看[原子操作和同步原语](../atomic-ops/#benchmarking-impact)文章中的结果。这些基准明确说明了使用`atomic.Value`而不是传统的同步原语（如`sync.RWMutex`）在高度并发读取场景中可能带来的性能优势。
- en: When to Use This Pattern
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用此模式
- en: 'Immutable data sharing is ideal when:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况发生时，不可变数据共享是理想的：
- en: The data is read-heavy and write-light (e.g., configuration, feature flags,
    global mappings). This works well because the cost of creating new immutable versions
    is amortized over many reads, and avoiding locks provides a performance boost.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据读取密集，写入轻（例如，配置、功能标志、全局映射）。这效果很好，因为创建新不可变版本的成本被分摊到许多读取中，避免锁定提供了性能提升。
- en: You want to minimize locking without sacrificing safety. By sharing read-only
    data, you remove the need for mutexes or coordination, reducing the chances of
    deadlocks or race conditions.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望在保证安全的前提下最小化锁定。通过共享只读数据，你消除了对互斥锁或协调的需求，减少了死锁或竞态条件发生的可能性。
- en: You can tolerate minor delays between update and read (eventual consistency).
    Since data updates are not coordinated with readers, there might be a small delay
    before all goroutines see the new version. If exact timing isn't critical, this
    tradeoff simplifies your concurrency model.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以容忍更新和读取之间的轻微延迟（最终一致性）。由于数据更新与读取者没有协调，所有goroutines看到新版本之前可能会有短暂的延迟。如果精确时间不是关键因素，这种权衡可以简化你的并发模型。
- en: It’s less suitable when updates must be transactional across multiple pieces
    of data or happen frequently. In those cases, the cost of repeated copying or
    lack of coordination can outweigh the benefits.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新必须在多份数据之间进行事务处理或频繁发生时，这就不太合适。在这些情况下，重复复制或缺乏协调的成本可能会超过其带来的好处。
