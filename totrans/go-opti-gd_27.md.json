["```go\n`[msg1][msg2][msg3]` \n```", "```go\n`[msg1_part][msg2][msg3_part]` \n```", "```go\n`| Length (4 bytes) | Payload (Length bytes) |` \n```", "```go\n`func  writeFrame(conn  net.Conn,  payload  []byte)  error  {   frameLen  :=  uint32(len(payload))   buf  :=  make([]byte,  4+len(payload))   binary.BigEndian.PutUint32(buf[:4],  frameLen)   copy(buf[4:],  payload)   _,  err  :=  conn.Write(buf)   return  err }  func  readFrame(conn  net.Conn)  ([]byte,  error)  {   lenBuf  :=  make([]byte,  4)   if  _,  err  :=  io.ReadFull(conn,  lenBuf);  err  !=  nil  {   return  nil,  err   }   frameLen  :=  binary.BigEndian.Uint32(lenBuf)   payload  :=  make([]byte,  frameLen)   if  _,  err  :=  io.ReadFull(conn,  payload);  err  !=  nil  {   return  nil,  err   }   return  payload,  nil }` \n```", "```go\n`func  handler(w  http.ResponseWriter,  r  *http.Request)  {   payload,  err  :=  io.ReadAll(r.Body)   if  err  !=  nil  {   http.Error(w,  \"invalid request\",  http.StatusBadRequest)   return   }   defer  r.Body.Close()    // Process payload...    w.WriteHeader(http.StatusOK)   w.Write([]byte(\"processed\")) }  func  main()  {   server  :=  &http.Server{   Addr:  \":8080\",   Handler:  http.HandlerFunc(handler),   }   log.Fatal(server.ListenAndServeTLS(\"server.crt\",  \"server.key\")) }` \n```", "```go\n`syntax  =  \"proto3\";  service  EchoService  {   rpc  Echo(EchoRequest)  returns  (EchoResponse); }  message  EchoRequest  {   string  message  =  1; }  message  EchoResponse  {   string  message  =  1; }` \n```", "```go\n`type  server  struct  {   UnimplementedEchoServiceServer }  func  (s  *server)  Echo(ctx  context.Context,  req  *EchoRequest)  (*EchoResponse,  error)  {   return  &EchoResponse{Message:  req.Message},  nil }  func  main()  {   lis,  err  :=  net.Listen(\"tcp\",  \":50051\")   if  err  !=  nil  {   log.Fatalf(\"failed to listen: %v\",  err)   }   grpcServer  :=  grpc.NewServer()   RegisterEchoServiceServer(grpcServer,  &server{})   grpcServer.Serve(lis) }` \n```"]