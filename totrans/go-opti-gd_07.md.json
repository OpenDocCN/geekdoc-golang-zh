["```go\n`func  StreamData(src  io.Reader,  dst  io.Writer)  error  {   buf  :=  make([]byte,  4096)  // Reusable buffer   _,  err  :=  io.CopyBuffer(dst,  src,  buf)   return  err }` \n```", "```go\n`func  process(buffer  []byte)  []byte  {   return  buffer[128:256]  // returns a slice reference without copying }` \n```", "```go\n`import  \"golang.org/x/exp/mmap\"  func  ReadFileZeroCopy(path  string)  ([]byte,  error)  {   r,  err  :=  mmap.Open(path)   if  err  !=  nil  {   return  nil,  err   }   defer  r.Close()    data  :=  make([]byte,  r.Len())   _,  err  =  r.ReadAt(data,  0)   return  data,  err }` \n```", "```go\n`func  BenchmarkCopy(b  *testing.B)  {   data  :=  make([]byte,  64*1024)   for  b.Loop()  {   buf  :=  make([]byte,  len(data))   copy(buf,  data)   } }  func  BenchmarkSlice(b  *testing.B)  {   data  :=  make([]byte,  64*1024)   for  b.Loop()  {   _  =  data[:]   } }` \n```", "```go\n`func  BenchmarkReadWithCopy(b  *testing.B)  {   f,  err  :=  os.Open(\"testdata/largefile.bin\")   if  err  !=  nil  {   b.Fatalf(\"failed to open file: %v\",  err)   }   defer  f.Close()    buf  :=  make([]byte,  4*1024*1024)  // 4MB buffer   for  b.Loop()  {   _,  err  :=  f.ReadAt(buf,  0)   if  err  !=  nil  &&  err  !=  io.EOF  {   b.Fatal(err)   }   } }  func  BenchmarkReadWithMmap(b  *testing.B)  {   r,  err  :=  mmap.Open(\"testdata/largefile.bin\")   if  err  !=  nil  {   b.Fatalf(\"failed to mmap file: %v\",  err)   }   defer  r.Close()    buf  :=  make([]byte,  r.Len())   for  b.Loop()  {   _,  err  :=  r.ReadAt(buf,  0)   if  err  !=  nil  &&  err  !=  io.EOF  {   b.Fatal(err)   }   } }` \n```", "```go\n`go  get  golang.org/x/exp/mmap mkdir  -p  testdata dd  if=/dev/urandom  of=./testdata/largefile.bin  bs=1M  count=4` \n```", "```go\n`package  perf  import  \"testing\"   // interface-start  type  Worker  interface  {   Work() }  type  LargeJob  struct  {   payload  [4096]byte }  func  (LargeJob)  Work()  {} // interface-end  // bench-slice-start func  BenchmarkBoxedLargeSlice(b  *testing.B)  {   jobs  :=  make([]Worker,  0,  1000)   for  b.Loop()  {   jobs  =  jobs[:0]   for  j  :=  0;  j  <  1000;  j++  {   var  job  LargeJob   jobs  =  append(jobs,  job)   }   } }  func  BenchmarkPointerLargeSlice(b  *testing.B)  {   jobs  :=  make([]Worker,  0,  1000)   for  b.Loop()  {   jobs  :=  jobs[:0]   for  j  :=  0;  j  <  1000;  j++  {   job  :=  &LargeJob{}   jobs  =  append(jobs,  job)   }   } } // bench-slice-end  // bench-call-start var  sink  Worker  func  call(w  Worker)  {   sink  =  w }  func  BenchmarkCallWithValue(b  *testing.B)  {   for  b.Loop()  {   var  j  LargeJob   call(j)   } }  func  BenchmarkCallWithPointer(b  *testing.B)  {   for  b.Loop()  {   j  :=  &LargeJob{}   call(j)   } } // bench-call-end` \n```"]