- en: 连接生命周期可观察性：从拨号到关闭¶
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/02-networking/connection_observability/](https://goperf.dev/02-networking/connection_observability/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 许多可观察性系统仅公开高级HTTP指标，但更深入的洞察来自于对每个阶段——DNS解析、拨号、握手、协商、读写和拆除——的显式仪表化。观察网络连接的完整生命周期，可以提供诊断延迟问题、识别故障以及将资源使用与外部行为相关联所需的清晰度。
  prefs: []
  type: TYPE_NORMAL
- en: DNS解析[¶](#dns-resolution "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 每个出站连接都始于一个名称解析步骤，除非已知IP地址。DNS延迟和故障通常主导连接设置时间，并且可能因缓存和解析器性能而显著变化。
  prefs: []
  type: TYPE_NORMAL
- en: 捕获DNS解析持续时间、错误和结果地址，可以提供对最不可预测阶段之一的可见性。在这个阶段，以下做法是有价值的：
  prefs: []
  type: TYPE_NORMAL
- en: 测量从查询发出到收到答案的时间
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 记录解析的IP地址
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 明确区分短暂和永久性故障
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 在Go中，这可以通过包装`net.Resolver`来实现。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"context"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"log"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"net"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"time"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func resolveWithTracing(ctx context.Context, hostname string) ([]string, error)
    {
  prefs: []
  type: TYPE_NORMAL
- en: start := time.Now()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ips, err := net.DefaultResolver.LookupHost(ctx, hostname)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elapsed := time.Since(start)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Printf("dns: host=%s duration=%s ips=%v err=%v", hostname, elapsed, ips,
    err)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return ips, err
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 这种显式测量避免了依赖于操作系统解析器或库公开的模糊指标。
  prefs: []
  type: TYPE_NORMAL
- en: 拨号[¶](#dialing "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 获得地址后，下一个阶段是拨号——建立TCP（或其他传输）连接。在这里，往返延迟到目标、路由稳定性和临时端口的耗尽都可能显现。
  prefs: []
  type: TYPE_NORMAL
- en: 观察拨号阶段通常涉及拦截`net.Dialer`。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func dialWithTracing(ctx context.Context, network, addr string) (net.Conn, error)
    {
  prefs: []
  type: TYPE_NORMAL
- en: var d net.Dialer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: start := time.Now()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conn, err := d.DialContext(ctx, network, addr)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elapsed := time.Since(start)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Printf("dial: addr=%s duration=%s err=%v", addr, elapsed, err)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return conn, err
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 为什么在这里进行跟踪？拨号失败可能表明下游不可用，但也可能是由于本地的SYN洪水保护（1）或不良路由问题。没有每个拨号的时戳和错误跟踪，确定故障位置只能是猜测。
  prefs: []
  type: TYPE_NORMAL
- en: 当拨号失败时，有时并不是因为网络或服务器故障，而是因为本地机器由于资源耗尽或保护性速率限制拒绝打开更多连接。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 握手和协商[¶](#handshake-and-negotiation "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 对于安全连接，下一个阶段——加密握手——占主导地位。TLS协商可能涉及多个往返、证书验证和加密套件协商。单独测量这一阶段是必要的，因为它将纯网络延迟（拨号）与加密和政策执行成本（握手）隔离开来。
  prefs: []
  type: TYPE_NORMAL
- en: Go语言中的`crypto/tls`库允许显式地对握手进行仪表化。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"crypto/tls"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func handshakeWithTracing(conn net.Conn, config *tls.Config) (*tls.Conn, error)
    {
  prefs: []
  type: TYPE_NORMAL
- en: tlsConn := tls.Client(conn, config)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: start := time.Now()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: err := tlsConn.Handshake()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elapsed := time.Since(start)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Printf("handshake: duration=%s err=%v", elapsed, err)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return tlsConn, err
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 一个常见的误解是，缓慢的TLS握手总是反映不良的网络条件；在实践中，缓慢的证书验证或[OCSP](https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol)/[CRL](https://en.wikipedia.org/wiki/Certificate_revocation_list)检查通常是罪魁祸首。将这些阶段分开有助于确定原因。
  prefs: []
  type: TYPE_NORMAL
- en: 应用程序读取和写入[¶](#application-reads-and-writes "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 一旦连接建立并协商，应用层流量就作为读取和写入进行。在这个阶段的可观察性通常是最不精确的，但对于将客户端感知的延迟与后端处理相关联来说却是最关键的。
  prefs: []
  type: TYPE_NORMAL
- en: 直接对读取和写入进行度量可以产生细粒度的延迟和吞吐量指标。包裹连接是一种常见策略。
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: type tracedConn struct {
  prefs: []
  type: TYPE_NORMAL
- en: net.Conn
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func (c *tracedConn) Read(b []byte) (int, error) {
  prefs: []
  type: TYPE_NORMAL
- en: start := time.Now()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n, err := c.Conn.Read(b)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elapsed := time.Since(start)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Printf("read: bytes=%d duration=%s err=%v", n, elapsed, err)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return n, err
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func (c *tracedConn) Write(b []byte) (int, error) {
  prefs: []
  type: TYPE_NORMAL
- en: start := time.Now()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n, err := c.Conn.Write(b)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elapsed := time.Since(start)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Printf("write: bytes=%d duration=%s err=%v", n, elapsed, err)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return n, err
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 为什么要在这种粒度上进行测量？读取和写入可能会因为与连接建立无关的原因而阻塞——缓冲区后压力、TCP窗口耗尽或应用程序暂停。追踪这些操作可以揭示观察到的缓慢是否由于I/O竞争或上游延迟。
  prefs: []
  type: TYPE_NORMAL
- en: 警告
  prefs: []
  type: TYPE_NORMAL
- en: 这样的粒度级别可能会影响您的系统性能。有关更多详细信息，请参阅[为什么减少日志？](#why-reduce-logs)。
  prefs: []
  type: TYPE_NORMAL
- en: 拆卸[¶](#teardown "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 最后，连接关闭通常很少受到关注，但它可能会影响资源使用和连接池的行为。观察连接关闭所需的时间以及`Close()`期间是否出现任何错误也是有用的。对于TCP，关闭可能会被操作系统延迟，直到所有`FIN`/`ACK`序列完成，并且套接字可能会在`TIME_WAIT`(1)中滞留。明确记录拆卸指标有助于识别资源泄漏。
  prefs: []
  type: TYPE_NORMAL
- en: 等待足够的时间以确保连接上所有剩余的包都已过期。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: func closeWithTracing(c net.Conn) error {
  prefs: []
  type: TYPE_NORMAL
- en: start := time.Now()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: err := c.Close()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elapsed := time.Since(start)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'log.Printf("close: duration=%s err=%v", elapsed, err)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return err
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 关联跨度与错误[¶](#correlating-spans-and-errors "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 除非将各个阶段的持续时间关联到一个连贯的跟踪中，否则捕获单个阶段持续时间是不够的。使用上下文感知的跟踪库可以将阶段跨度附加到单个逻辑事务上。
  prefs: []
  type: TYPE_NORMAL
- en: 例如，使用[OpenTelemetry](https://opentelemetry.io/)：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"go.opentelemetry.io/otel/trace"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func tracePhase(ctx context.Context, tracer trace.Tracer, phase string, fn func()
    error) error {
  prefs: []
  type: TYPE_NORMAL
- en: ctx, span := tracer.Start(ctx, phase)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: defer span.End()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return fn()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 将每个阶段包裹在跨度中可以拼接时间线，并将特定错误与其起源阶段相关联。在诊断生产中断时，症状往往远在根本原因之外，这种详细程度非常重要。
  prefs: []
  type: TYPE_NORMAL
- en: 检测和解释挂起[¶](#detecting-and-explaining-hangs "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 分布式系统中的一个更隐蔽的问题是挂起的连接——没有前进但也没有立即失败。细粒度的可观察性可以区分DNS期间的挂起、无响应的手势、由于缓冲区满而阻塞的写入或延迟的FIN。例如，如果拨号阶段日志已完整但握手从未完成，则应关注证书验证、MTU黑洞或中间盒干扰。通过维护每个阶段的超时和基于历史基线的警报，这些条件可以被检测和解释，而不仅仅是简单地归类为“慢”。这不仅能说明什么失败了，还能说明为什么失败了。
  prefs: []
  type: TYPE_NORMAL
- en: 超越日志：指标和结构化事件[¶](#beyond-logs-metrics-and-structured-events "永久链接")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 很可能你需要减少日志量，同时不丢失对规模运营至关重要的关键信息。高频、详细的连接生命周期事件记录会产生I/O、CPU和存储开销。如果没有控制机制，它可能会压倒日志聚合系统，增加成本，甚至用噪声掩盖信号。因此，必须谨慎管理日志详细程度——保持足够的细节以供诊断，但避免过多的体积。
  prefs: []
  type: TYPE_NORMAL
- en: '[Zap](https://github.com/uber-go/zap)在这些示例中用于演示运行时可配置性和结构化日志记录的策略，但相同的原理适用于任何有能力的日志库。能够动态更改级别、发出结构化数据和采样事件使得实现这些策略变得更容易。'
  prefs: []
  type: TYPE_NORMAL
- en: 为什么减少日志量？[¶](#why-reduce-logs "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 在每秒数千个连接上以细粒度进行日志记录可以迅速生成数以兆字节的数据，其中大部分是重复的且价值较低。高日志吞吐量也可能与应用程序的主要执行路径产生竞争，影响延迟。此外，无限制的日志增长会给操作员带来负担，复杂化事件分类，并增加保留成本。
  prefs: []
  type: TYPE_NORMAL
- en: 控制日志量的技术[¶](#techniques-to-control-log-volume "永久链接")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**可配置的日志级别**：根据情况在运行时调整详细程度——默认情况下将生产环境保持在`INFO`或`WARN`，在调查期间切换到`DEBUG`或`TRACE`。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**采样**：在高负载下仅记录事件的一部分或每N个连接记录一次。Zap支持强制执行速率限制和随机性的采样器。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**指标优先，日志用于异常**：将阶段持续时间和计数器提升到指标（例如，Prometheus）中，并且仅在阈值或百分位数被突破时发出日志。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**聚合阶段数据**：收集每个连接的所有阶段时间和结果，然后在结束时发出一个单独的结构化日志事件，而不是将每个阶段作为单独的行进行记录。'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 通过结合这些方法，可以在可管理的开销下保留有意义的可观察性。Zap的API简单地说明了如何有效地实现这些模式——**关键要点是设计本身，而不是库的选择**，决定了可观察性的质量和成本。
  prefs: []
  type: TYPE_NORMAL
- en: 这里有一些这些技术的示例代码片段：
  prefs: []
  type: TYPE_NORMAL
- en: 可配置的日志级别[¶](#configurable-log-level "永久链接")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: atomicLevel := zap.NewAtomicLevel()
  prefs: []
  type: TYPE_NORMAL
- en: logger := zap.New(zapcore.NewCore(
  prefs: []
  type: TYPE_NORMAL
- en: zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: zapcore.AddSync(os.Stdout),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: atomicLevel,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ))
  prefs: []
  type: TYPE_NORMAL
- en: // Adjust at runtime
  prefs: []
  type: TYPE_NORMAL
- en: atomicLevel.SetLevel(zap.WarnLevel)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 采样日志[¶](#sampling-logs "永久链接")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: core := zapcore.NewSamplerWithOptions(
  prefs: []
  type: TYPE_NORMAL
- en: logger.Core(),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: time.Second,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 100, // first 100 per second
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 10,  // thereafter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: logger := zap.New(core)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 每个连接的聚合日志[¶](#aggregate-per-connection-log "永久链接")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: phases := map[string]time.Duration{
  prefs: []
  type: TYPE_NORMAL
- en: '"dns": 10 * time.Millisecond,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"dial": 40 * time.Millisecond,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"handshake": 50 * time.Millisecond,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: logger.Info("connection completed", zap.Any("phases", phases))
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 虽然日志语句和跨度提供了有价值的信息，但生产级可观察性系统从结构化指标收集和结构化日志记录中获益良多。
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus非常适合从每个阶段收集和查询时间序列指标，并将它们暴露在仪表板和警报规则中。与其将阶段持续时间嵌入到非结构化日志中，不如设计并暴露清晰命名的指标，例如`connection_dns_duration_seconds`、`connection_dial_errors_total`以及类似的计数器。这些名称是遵循Prometheus命名约定的示例，应在实现中明确定义，以确保清晰和一致性。
  prefs: []
  type: TYPE_NORMAL
- en: 对于结构化日志，如Uber的`zap`库提供快速、JSON编码的日志，可以干净地与ELK或Splunk等日志聚合系统集成。而不是使用自由形式的`Printf`，可以发出结构化的键值对：
  prefs: []
  type: TYPE_NORMAL
- en: '```go'
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"go.uber.org/zap"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: var logger, _ = zap.NewProduction()
  prefs: []
  type: TYPE_NORMAL
- en: logger.Info("dns",
  prefs: []
  type: TYPE_NORMAL
- en: zap.String("host", hostname),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: zap.Duration("duration", elapsed),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: zap.Strings("ips", ips),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: zap.Error(err),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 结构化日志减轻了下游解析器的负担，并使在服务之间关联事件更加可靠。结合这些技术——阶段级仪表、Prometheus指标和结构化日志——将模糊的故障转化为可操作的见解。在这个粒度和一致性的水平上，模糊的症状变成了精确的诊断，确保开发人员和运维人员不仅可以确定有问题，而且可以精确地确定问题所在以及原因。
  prefs: []
  type: TYPE_NORMAL
