["```go\n| type | nkeys |  pointers  |   offsets  | key-values | unused |\n|  2B  |   2B  | nkeys * 8B | nkeys * 2B |     ...    |        |\n```", "```go\n| klen | vlen | key | val |\n|  2B  |  2B  | ... | ... |\n```", "```go\n[](#cb3-1)const HEADER = 4\n[](#cb3-2)\n[](#cb3-3)const BTREE_PAGE_SIZE = 4096\n[](#cb3-4)const BTREE_MAX_KEY_SIZE = 1000\n[](#cb3-5)const BTREE_MAX_VAL_SIZE = 3000\n[](#cb3-6)\n[](#cb3-7)func init() {\n[](#cb3-8)    node1max := HEADER + 8 + 2 + 4 + BTREE_MAX_KEY_SIZE + BTREE_MAX_VAL_SIZE\n[](#cb3-9)    assert(node1max <= BTREE_PAGE_SIZE) // maximum KV\n[](#cb3-10)}\n```", "```go\n[](#cb4-1)type BNode []byte // can be dumped to the disk\n```", "```go\n[](#cb5-1)type BTree struct {\n[](#cb5-2)    // pointer (a nonzero page number)\n[](#cb5-3)    root uint64\n[](#cb5-4)    // callbacks for managing on-disk pages\n[](#cb5-5)    get func(uint64) []byte // dereference a pointer\n[](#cb5-6)    new func([]byte) uint64 // allocate a new page\n[](#cb5-7)    del func(uint64)        // deallocate a page\n[](#cb5-8)}\n```", "```go\n| type | nkeys |  pointers  |   offsets  | key-values | unused |\n|  2B  |   2B  | nkeys * 8B | nkeys * 2B |     ...    |        |\n\n| klen | vlen | key | val |\n|  2B  |  2B  | ... | ... |\n```", "```go\n[](#cb7-1)const (\n[](#cb7-2)    BNODE_NODE = 1 // internal nodes without values\n[](#cb7-3)    BNODE_LEAF = 2 // leaf nodes with values\n[](#cb7-4))\n[](#cb7-5)\n[](#cb7-6)func (node BNode) btype() uint16 {\n[](#cb7-7)    return binary.LittleEndian.Uint16(node[0:2])\n[](#cb7-8)}\n[](#cb7-9)func (node BNode) nkeys() uint16 {\n[](#cb7-10)    return binary.LittleEndian.Uint16(node[2:4])\n[](#cb7-11)}\n[](#cb7-12)func (node BNode) setHeader(btype uint16, nkeys uint16) {\n[](#cb7-13)    binary.LittleEndian.PutUint16(node[0:2], btype)\n[](#cb7-14)    binary.LittleEndian.PutUint16(node[2:4], nkeys)\n[](#cb7-15)}\n```", "```go\n[](#cb8-1)// pointers\n[](#cb8-2)func (node BNode) getPtr(idx uint16) uint64 {\n[](#cb8-3)    assert(idx < node.nkeys())\n[](#cb8-4)    pos := HEADER + 8*idx\n[](#cb8-5)    return binary.LittleEndian.Uint64(node[pos:])\n[](#cb8-6)}\n[](#cb8-7)func (node BNode) setPtr(idx uint16, val uint64)\n```", "```go\n[](#cb9-1)// offset list\n[](#cb9-2)func offsetPos(node BNode, idx uint16) uint16 {\n[](#cb9-3)    assert(1 <= idx && idx <= node.nkeys())\n[](#cb9-4)    return HEADER + 8*node.nkeys() + 2*(idx-1)\n[](#cb9-5)}\n[](#cb9-6)func (node BNode) getOffset(idx uint16) uint16 {\n[](#cb9-7)    if idx == 0 {\n[](#cb9-8)        return 0\n[](#cb9-9)    }\n[](#cb9-10)    return binary.LittleEndian.Uint16(node[offsetPos(node, idx):])\n[](#cb9-11)}\n[](#cb9-12)func (node BNode) setOffset(idx uint16, offset uint16)\n```", "```go\n[](#cb10-1)// key-values\n[](#cb10-2)func (node BNode) kvPos(idx uint16) uint16 {\n[](#cb10-3)    assert(idx <= node.nkeys())\n[](#cb10-4)    return HEADER + 8*node.nkeys() + 2*node.nkeys() + node.getOffset(idx)\n[](#cb10-5)}\n[](#cb10-6)func (node BNode) getKey(idx uint16) []byte {\n[](#cb10-7)    assert(idx < node.nkeys())\n[](#cb10-8)    pos := node.kvPos(idx)\n[](#cb10-9)    klen := binary.LittleEndian.Uint16(node[pos:])\n[](#cb10-10)    return node[pos+4:][:klen]\n[](#cb10-11)}\n[](#cb10-12)func (node BNode) getVal(idx uint16) []byte\n```", "```go\n[](#cb11-1)// node size in bytes\n[](#cb11-2)func (node BNode) nbytes() uint16 {\n[](#cb11-3)    return node.kvPos(node.nkeys())\n[](#cb11-4)}\n```", "```go\n[](#cb12-1)// returns the first kid node whose range intersects the key. (kid[i] <= key)\n[](#cb12-2)// TODO: binary search\n[](#cb12-3)func nodeLookupLE(node BNode, key []byte) uint16 {\n[](#cb12-4)    nkeys := node.nkeys()\n[](#cb12-5)    found := uint16(0)\n[](#cb12-6)    // the first key is a copy from the parent node,\n[](#cb12-7)    // thus it's always less than or equal to the key.\n[](#cb12-8)    for i := uint16(1); i < nkeys; i++ {\n[](#cb12-9)        cmp := bytes.Compare(node.getKey(i), key)\n[](#cb12-10)        if cmp <= 0 {\n[](#cb12-11)            found = i\n[](#cb12-12)        }\n[](#cb12-13)        if cmp >= 0 {\n[](#cb12-14)            break\n[](#cb12-15)        }\n[](#cb12-16)    }\n[](#cb12-17)    return found\n[](#cb12-18)}\n```", "```go\n[](#cb13-1)// add a new key to a leaf node\n[](#cb13-2)func leafInsert(\n[](#cb13-3)    new BNode, old BNode, idx uint16,\n[](#cb13-4)    key []byte, val []byte,\n[](#cb13-5)) {\n[](#cb13-6)    new.setHeader(BNODE_LEAF, old.nkeys()+1) // setup the header\n[](#cb13-7)    nodeAppendRange(new, old, 0, 0, idx)\n[](#cb13-8)    nodeAppendKV(new, idx, 0, key, val)\n[](#cb13-9)    nodeAppendRange(new, old, idx+1, idx, old.nkeys()-idx)\n[](#cb13-10)}\n```", "```go\n[](#cb14-1)// copy a KV into the position\n[](#cb14-2)func nodeAppendKV(new BNode, idx uint16, ptr uint64, key []byte, val []byte) {\n[](#cb14-3)    // ptrs\n[](#cb14-4)    new.setPtr(idx, ptr)\n[](#cb14-5)    // KVs\n[](#cb14-6)    pos := new.kvPos(idx)\n[](#cb14-7)    binary.LittleEndian.PutUint16(new[pos+0:], uint16(len(key)))\n[](#cb14-8)    binary.LittleEndian.PutUint16(new[pos+2:], uint16(len(val)))\n[](#cb14-9)    copy(new[pos+4:], key)\n[](#cb14-10)    copy(new[pos+4+uint16(len(key)):], val)\n[](#cb14-11)    // the offset of the next key\n[](#cb14-12)    new.setOffset(idx+1, new.getOffset(idx)+4+uint16((len(key)+len(val))))\n[](#cb14-13)}\n[](#cb14-14)\n[](#cb14-15)// copy multiple KVs into the position from the old node\n[](#cb14-16)func nodeAppendRange(\n[](#cb14-17)    new BNode, old BNode,\n[](#cb14-18)    dstNew uint16, srcOld uint16, n uint16,\n[](#cb14-19))\n```", "```go\n[](#cb15-1)// replace a link with one or multiple links\n[](#cb15-2)func nodeReplaceKidN(\n[](#cb15-3)    tree *BTree, new BNode, old BNode, idx uint16,\n[](#cb15-4)    kids ...BNode,\n[](#cb15-5)) {\n[](#cb15-6)    inc := uint16(len(kids))\n[](#cb15-7)    new.setHeader(BNODE_NODE, old.nkeys()+inc-1)\n[](#cb15-8)    nodeAppendRange(new, old, 0, 0, idx)\n[](#cb15-9)    for i, node := range kids {\n[](#cb15-10)        nodeAppendKV(new, idx+uint16(i), tree.new(node), node.getKey(0), nil)\n[](#cb15-11)        //                ^position      ^pointer        ^key            ^val\n[](#cb15-12)    }\n[](#cb15-13)    nodeAppendRange(new, old, idx+inc, idx+1, old.nkeys()-(idx+1))\n[](#cb15-14)}\n```", "```go\n[](#cb16-1)// split a oversized node into 2 so that the 2nd node always fits on a page\n[](#cb16-2)func nodeSplit2(left BNode, right BNode, old BNode) {\n[](#cb16-3)    // code omitted...\n[](#cb16-4)}\n[](#cb16-5)\n[](#cb16-6)// split a node if it's too big. the results are 1~3 nodes.\n[](#cb16-7)func nodeSplit3(old BNode) (uint16, [3]BNode) {\n[](#cb16-8)    if old.nbytes() <= BTREE_PAGE_SIZE {\n[](#cb16-9)        old = old[:BTREE_PAGE_SIZE]\n[](#cb16-10)        return 1, [3]BNode{old} // not split\n[](#cb16-11)    }\n[](#cb16-12)    left := BNode(make([]byte, 2*BTREE_PAGE_SIZE)) // might be split later\n[](#cb16-13)    right := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb16-14)    nodeSplit2(left, right, old)\n[](#cb16-15)    if left.nbytes() <= BTREE_PAGE_SIZE {\n[](#cb16-16)        left = left[:BTREE_PAGE_SIZE]\n[](#cb16-17)        return 2, [3]BNode{left, right} // 2 nodes\n[](#cb16-18)    }\n[](#cb16-19)    leftleft := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb16-20)    middle := BNode(make([]byte, BTREE_PAGE_SIZE))\n[](#cb16-21)    nodeSplit2(leftleft, middle, left)\n[](#cb16-22)    assert(leftleft.nbytes() <= BTREE_PAGE_SIZE)\n[](#cb16-23)    return 3, [3]BNode{leftleft, middle, right} // 3 nodes\n[](#cb16-24)}\n```", "```go\n[](#cb17-1)// insert a KV into a node, the result might be split.\n[](#cb17-2)// the caller is responsible for deallocating the input node\n[](#cb17-3)// and splitting and allocating result nodes.\n[](#cb17-4)func treeInsert(tree *BTree, node BNode, key []byte, val []byte) BNode {\n[](#cb17-5)    // the result node.\n[](#cb17-6)    // it's allowed to be bigger than 1 page and will be split if so\n[](#cb17-7)    new := BNode{data: make([]byte, 2*BTREE_PAGE_SIZE)}\n[](#cb17-8)\n[](#cb17-9)    // where to insert the key?\n[](#cb17-10)    idx := nodeLookupLE(node, key)\n[](#cb17-11)    // act depending on the node type\n[](#cb17-12)    switch node.btype() {\n[](#cb17-13)    case BNODE_LEAF:\n[](#cb17-14)        // leaf, node.getKey(idx) <= key\n[](#cb17-15)        if bytes.Equal(key, node.getKey(idx)) {\n[](#cb17-16)            // found the key, update it.\n[](#cb17-17)            leafUpdate(new, node, idx, key, val)\n[](#cb17-18)        } else {\n[](#cb17-19)            // insert it after the position.\n[](#cb17-20)            leafInsert(new, node, idx+1, key, val)\n[](#cb17-21)        }\n[](#cb17-22)    case BNODE_NODE:\n[](#cb17-23)        // internal node, insert it to a kid node.\n[](#cb17-24)        nodeInsert(tree, new, node, idx, key, val)\n[](#cb17-25)    default:\n[](#cb17-26)        panic(\"bad node!\")\n[](#cb17-27)    }\n[](#cb17-28)    return new\n[](#cb17-29)}\n```", "```go\n[](#cb18-1)// part of the treeInsert(): KV insertion to an internal node\n[](#cb18-2)func nodeInsert(\n[](#cb18-3)    tree *BTree, new BNode, node BNode, idx uint16,\n[](#cb18-4)    key []byte, val []byte,\n[](#cb18-5)) {\n[](#cb18-6)    kptr := node.getPtr(idx)\n[](#cb18-7)    // recursive insertion to the kid node\n[](#cb18-8)    knode := treeInsert(tree, tree.get(kptr), key, val)\n[](#cb18-9)    // split the result\n[](#cb18-10)    nsplit, split := nodeSplit3(knode)\n[](#cb18-11)    // deallocate the kid node\n[](#cb18-12)    tree.del(kptr)\n[](#cb18-13)    // update the kid links\n[](#cb18-14)    nodeReplaceKidN(tree, new, node, idx, split[:nsplit]...)\n[](#cb18-15)}\n```"]