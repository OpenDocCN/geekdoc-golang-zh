- en: Tuning DNS Performance in Go Services¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go服务中调整DNS性能¶
- en: 原文：[https://goperf.dev/02-networking/dns_performance/](https://goperf.dev/02-networking/dns_performance/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/02-networking/dns_performance/](https://goperf.dev/02-networking/dns_performance/)
- en: DNS resolution tends to fly under the radar, but it can still slow down Go applications.
    Even brief delays in lookups can stack up in distributed or microservice architectures
    where components frequently communicate. Understanding how Go resolves DNS under
    the hood — and how to adjust it — can make your service more responsive and reliable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: DNS解析通常不会引起注意，但它仍然可能减慢Go应用程序的速度。即使在查找中的短暂延迟，在组件频繁通信的分布式或微服务架构中也会累积。了解Go在底层如何解析DNS以及如何调整它可以使您的服务更加响应迅速和可靠。
- en: 'How DNS Resolution Works in Go: cgo vs. Native Resolver[¶](#how-dns-resolution-works-in-go-cgo-vs-native-resolver
    "Permanent link")'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go中DNS解析的工作原理：cgo与本地解析器[¶](#how-dns-resolution-works-in-go-cgo-vs-native-resolver
    "永久链接")
- en: 'Go supports two different ways of handling DNS queries: the built-in **pure-Go**
    resolver and the **cgo-based** resolver.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持两种处理DNS查询的不同方式：内置的**纯Go**解析器和基于**cgo**的解析器。
- en: The `pure-Go` resolver is fully self-contained and avoids using any external
    DNS libraries. It reads its configuration from `/etc/resolv.conf` (on Unix-like
    systems) and talks directly to the configured nameservers. This makes it simple
    and generally performant, though it sometimes struggles to handle more exotic
    or highly customized DNS environments.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`纯Go`解析器是完全自包含的，避免使用任何外部DNS库。它从`/etc/resolv.conf`（在类Unix系统中）读取其配置，并直接与配置的名称服务器通信。这使得它简单且通常性能良好，尽管它有时难以处理更奇特或高度定制的DNS环境。'
- en: In contrast, the **cgo-based** resolver delegates DNS resolution to the operating
    system’s own resolver (through the C standard library, `libc`). This gives better
    compatibility with complicated or custom DNS environments—like those involving
    LDAP or multicast DNS—but it also comes with a tradeoff. The cgo resolver adds
    overhead due to calls into external C libraries, and it can sometimes lead to
    issues around thread safety or unpredictable latency spikes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于**cgo**的解析器将DNS解析委托给操作系统的自身解析器（通过C标准库`libc`）。这提供了与复杂或自定义DNS环境的更好兼容性——例如涉及LDAP或组播DNS的环境——但它也带来了一定的权衡。cgo解析器由于调用外部C库而增加了开销，有时可能导致线程安全或不可预测的延迟峰值。
- en: 'It''s possible to explicitly configure Go to prefer the **pure-Go** resolver
    using an environment variable:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过环境变量显式配置Go以优先使用**纯Go**解析器：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, force the use of cgo resolver:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，强制使用cgo解析器：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Runtime Dependencies[¶](#runtime-dependencies "Permanent link")
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时依赖[¶](#runtime-dependencies "永久链接")
- en: Enabling cgo changes how the Go binary interacts with the operating system.
    With cgo turned on, the binary no longer stands alone — it links dynamically to
    `libc` and the system loader, which `ldd` reveals in its output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 启用cgo会改变Go二进制文件与操作系统的交互方式。当cgo开启时，二进制文件不再独立存在——它动态链接到`libc`和系统加载器，这在`ldd`的输出中可以揭示。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A cgo-enabled binary relies on the system’s C runtime (`libc.so.6`) and the
    dynamic loader (`ld-linux`). Without these shared libraries available on the host,
    the binary won’t start — which makes it unsuitable for stripped-down environments
    like scratch containers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 启用cgo的二进制文件依赖于系统的C运行时（`libc.so.6`）和动态加载器（`ld-linux`）。如果没有在宿主机上提供这些共享库，二进制文件将无法启动——这使得它不适合像scratch容器这样的简化环境。
- en: 'By contrast, a pure-Go binary is completely self-contained and statically linked.
    If you run `ldd` on it, you’ll simply see:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，纯Go二进制文件是完全自包含的，并且是静态链接的。如果您在它上面运行`ldd`，您将只看到：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This shows that all the code the binary needs is already baked in, with no dependency
    on shared libraries at runtime. Because of this, pure-Go builds are a good fit
    for minimal containers or bare environments without a C runtime, offering better
    portability and fewer operational surprises. The downside is that these binaries
    can’t take advantage of system-level resolver features that require cgo and the
    host’s `libc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明二进制文件所需的全部代码已经内置，运行时无需依赖共享库。正因为如此，纯Go构建非常适合最小化容器或没有C运行时的裸环境，提供了更好的可移植性和更少的操作意外。缺点是这些二进制文件无法利用需要cgo和宿主机的`libc`的系统级解析器功能。
- en: 'DNS Caching: Why and When[¶](#dns-caching-why-and-when "Permanent link")'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS缓存：为什么以及何时[¶](#dns-caching-why-and-when "永久链接")
- en: Caching DNS results prevents the application from sending the same queries over
    and over, which can eliminate a noticeable amount of latency. Each lookup incurs
    at least one network round-trip, and when this happens at scale, the cumulative
    cost can become a serious drag on service performance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存DNS结果可以防止应用程序反复发送相同的查询，这可以消除可感知的延迟。每次查找至少涉及一次网络往返，当在规模上发生时，累积成本可能会成为对服务性能的严重拖累。
- en: Many operating systems and hosting environments already include some form of
    DNS caching. On Windows, the `DNS Client` service keeps a local cache; on macOS,
    `mDNSResponder` handles this; and on most Linux systems, `systemd-resolved` or
    `nscd` often provides a caching layer. In cloud environments, DNS queries are
    often routed through a nearby caching resolver inside the same data center. These
    mechanisms do help reduce latency, but they operate transparently to the application
    and offer little visibility or control over TTLs and policies. On Linux, if `systemd-resolved`
    isn’t enabled, no caching happens at all unless you configure it explicitly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作系统和托管环境已经包含某种形式的DNS缓存。在Windows上，`DNS客户端`服务保留本地缓存；在macOS上，`mDNSResponder`处理这个问题；在大多数Linux系统上，`systemd-resolved`或`nscd`通常提供缓存层。在云环境中，DNS查询通常通过同一数据中心附近的一个缓存解析器路由。这些机制确实有助于减少延迟，但它们对应用程序是透明的，并且对TTLs和策略的可见性和控制很少。在Linux上，如果`systemd-resolved`未启用，除非你明确配置，否则根本不会发生缓存。
- en: Since Go itself doesn’t include any DNS caching, you have to implement it yourself
    if you want fine-grained, application-level control. One option is to run your
    own caching DNS server nearby; another is to embed a lightweight cache directly
    in your code, using a third-party library.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go本身不包含任何DNS缓存，如果你想实现细粒度、应用级别的控制，你必须自己实现。一个选项是运行你自己的缓存DNS服务器；另一个选项是在你的代码中直接嵌入轻量级缓存，使用第三方库。
- en: 'Example using [go-cache](https://github.com/patrickmn/go-cache) for a simple
    DNS cache:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[go-cache](https://github.com/patrickmn/go-cache)的简单DNS缓存示例：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Overdoing DNS caching has its downsides — it can leave you serving stale records
    and make your service fragile if upstream addresses change. It’s worth tuning
    your cache expiration times so they reflect how often the domains you rely on
    actually change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 过度DNS缓存有其缺点——它可能导致你提供过时的记录，如果上游地址更改，还会使你的服务变得脆弱。调整你的缓存过期时间，使其反映你依赖的域名实际更改的频率是值得的。
- en: Using Custom Dialers and Pre-resolved IPs[¶](#using-custom-dialers-and-pre-resolved-ips
    "Permanent link")
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义拨号器和预解析IP[¶](#using-custom-dialers-and-pre-resolved-ips "永久链接")
- en: In latency-sensitive services, it often makes sense to resolve DNS up front
    or use a custom dialer to control resolution explicitly. Every call to `net.Dial`
    or `net.DialContext` with a hostname triggers a lookup, which can involve syscalls,
    context switches, and sometimes even a network round-trip if the cache is cold.
    At high throughput, this overhead adds up.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在对延迟敏感的服务中，提前解析DNS或使用自定义拨号器来显式控制解析通常是有意义的。每次调用`net.Dial`或`net.DialContext`与主机名都会触发一个查找，这可能涉及系统调用、上下文切换，有时甚至如果缓存是冷的，还需要网络往返。在高吞吐量下，这种开销会累积。
- en: To eliminate this overhead, you can resolve hostnames during startup and save
    the resulting IPs. This approach is particularly effective when dealing with a
    fixed set of endpoints that rarely change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这种开销，你可以在启动时解析主机名并保存结果IP。这种方法在处理一组固定且很少更改的端点时特别有效。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One drawback is that it fixes the IP for the lifetime of the process, so if
    the endpoint changes its address, connections may start failing. To handle this
    gracefully, you can run a background goroutine that refreshes the resolved IP
    at regular intervals.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺点是它会固定进程生命周期的IP地址，所以如果端点更改了地址，连接可能会开始失败。为了优雅地处理这个问题，你可以运行一个后台goroutine，定期刷新解析的IP地址。
- en: 'Custom dialers take it one step further: they allow you to control how DNS
    resolution and socket establishment occur on a per-connection basis. This will
    enable you to force connections through a specific resolver, hardwire pre-resolved
    IP addresses, or even bypass DNS completely by dialing IP addresses directly.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义拨号器更进一步：它们允许你根据每个连接控制DNS解析和套接字建立的方式。这将使你能够强制连接通过特定的解析器，硬编码预解析的IP地址，或者甚至通过直接拨打电话地址来完全绕过DNS。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Custom dialers can also bypass unreliable system resolvers or direct DNS queries
    through a dedicated, faster nameserver. They give you precise control over how
    resolution happens, but that control comes with added complexity — you’ll need
    to handle fallback and refresh logic yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义拨号器也可以绕过不可靠的系统解析器或直接通过专用、更快的名称服务器进行 DNS 查询。它们让你能够精确控制解析过程，但这种控制也带来了额外的复杂性——你需要自己处理回退和刷新逻辑。
- en: Metrics and Debugging Real-world DNS Slowdowns[¶](#metrics-and-debugging-real-world-dns-slowdowns
    "Permanent link")
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标和调试现实世界 DNS 变慢问题[¶](#metrics-and-debugging-real-world-dns-slowdowns "永久链接")
- en: 'Identifying and troubleshooting DNS-induced latency requires insightful metrics
    and targeted debugging techniques. Measuring DNS is not just about seeing how
    fast it is — it helps answer deeper questions: are lookups hitting OS or provider
    caches? is the network path to the DNS server flaky? are specific nameservers
    slower than others? are IPv6 and IPv4 behaving differently? Without visibility,
    DNS issues can silently degrade performance and reliability.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 识别和调试由 DNS 引起的延迟需要深入的指标和有针对性的调试技术。测量 DNS 不仅仅是看它有多快——它有助于回答更深层次的问题：查找是否击中了操作系统或提供商的缓存？通往
    DNS 服务器的网络路径是否不可靠？是否有特定的名称服务器比其他服务器慢？IPv6 和 IPv4 是否表现不同？没有可见性，DNS 问题可能会无声地降低性能和可靠性。
- en: Metrics[¶](#metrics "Permanent link")
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指标[¶](#metrics "永久链接")
- en: Make sure to track DNS resolution times in your service metrics so you can see
    how much time lookups actually add to each request. The simplest way is to wrap
    your DNS calls with a timer that starts just before the lookup and records the
    duration after it completes. Over time, these measurements help you identify trends,
    spot intermittent slowness, and correlate DNS delays with other parts of your
    system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确保跟踪你的服务指标中的 DNS 解析时间，以便你可以看到查找实际上为每个请求增加了多少时间。最简单的方法是在查找之前和完成后记录持续时间的计时器包装你的
    DNS 调用。随着时间的推移，这些测量有助于你识别趋势，发现间歇性缓慢，并将 DNS 延迟与系统的其他部分相关联。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looking at high-percentile latencies — like the 95th or 99th — can reveal sporadic
    slowdowns or flaky DNS behavior that averages might hide.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看高百分位延迟，如第 95 或第 99 百分位，可以揭示平均数隐藏的间歇性变慢或不可靠的 DNS 行为。
- en: Debugging Tips[¶](#debugging-tips "Permanent link")
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试技巧[¶](#debugging-tips "永久链接")
- en: 'When facing unexplained latency spikes, leverage Go’s built-in debug mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 面对无法解释的延迟峰值时，利用 Go 的内置调试模式：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Enabling this produces detailed DNS query logs that show exactly how each request
    is handled from start to finish. You can see when a server responds slowly, when
    lookups fail and trigger retries, or when the runtime unexpectedly falls back
    to the cgo resolver. Such detailed insight makes it much easier to pinpoint elusive
    DNS problems that standard metrics often miss.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能会产生详细的 DNS 查询日志，显示每个请求从开始到结束的详细处理过程。你可以看到服务器响应缓慢的时间，查找失败并触发重试的时间，或者运行时意外回退到
    cgo 解析器的时间。这种详细的洞察力使得定位标准指标经常忽略的难以捉摸的 DNS 问题变得容易得多。
- en: Advanced DNS Performance Tips[¶](#advanced-dns-performance-tips "Permanent link")
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级 DNS 性能技巧[¶](#advanced-dns-performance-tips "永久链接")
- en: Running a local DNS caching resolver, such as `dnsmasq` or `Unbound`, close
    to your service can eliminate the extra latency of external lookups. If security
    and privacy are concerns, enabling DNS-over-HTTPS (DoH) or DNS-over-TLS (DoT)
    is also an option, though it comes with some additional latency due to encryption.
    Finally, reviewing and tuning your `/etc/resolv.conf` — adjusting retry counts
    and timeout settings — helps ensure the resolver behaves predictably under load
    or failure conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的服务附近运行本地 DNS 缓存解析器，例如 `dnsmasq` 或 `Unbound`，可以消除外部查找的额外延迟。如果安全和隐私是关注点，启用
    DNS-over-HTTPS (DoH) 或 DNS-over-TLS (DoT) 也是一个选项，尽管由于加密，它会有一些额外的延迟。最后，审查和调整你的
    `/etc/resolv.conf` —— 调整重试次数和超时设置 —— 有助于确保解析器在负载或故障条件下表现出可预测的行为。
