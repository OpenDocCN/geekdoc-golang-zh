- en: 'Memory Efficiency: Mastering Go’s Garbage Collector¶'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存效率：掌握Go的垃圾回收器[¶]
- en: 原文：[https://goperf.dev/01-common-patterns/gc/](https://goperf.dev/01-common-patterns/gc/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/gc/](https://goperf.dev/01-common-patterns/gc/)
- en: Memory management in Go is automated—but it’s not invisible. Every allocation
    you make contributes to GC workload. The more frequently objects are created and
    discarded, the more work the runtime has to do reclaiming memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的内存管理是自动化的——但它并非不可见。你进行的每一次分配都会对垃圾回收工作负载做出贡献。对象创建和丢弃的频率越高，运行时在回收内存时需要做的工作就越多。
- en: This becomes especially relevant in systems prioritizing low latency, predictable
    resource usage, or high throughput. Tuning your allocation patterns and leveraging
    newer features like weak references can help reduce pressure on the GC without
    adding complexity to your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这在优先考虑低延迟、可预测的资源使用或高吞吐量的系统中尤其相关。调整您的分配模式并利用像弱引用这样的新功能可以帮助减轻垃圾回收器的压力，而不会增加您的代码复杂性。
- en: How Go's Garbage Collector Works[¶](#how-gos-garbage-collector-works "Permanent
    link")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go的垃圾回收器是如何工作的[¶](#how-gos-garbage-collector-works "永久链接")
- en: Info
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Highly encourage you to read the official [A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)!
    The document provides a detailed description of multiple Go's GC internals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您阅读官方的[A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)！该文档提供了对多个Go垃圾回收器内部结构的详细描述。
- en: Go uses a **non-generational, concurrent, tri-color mark-and-sweep** garbage
    collector. Here's what that means in practice and how it's implemented.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用一个**非代际、并发、三色标记-清除**垃圾回收器。以下是它在实际中的含义以及它的实现方式。
- en: Non-generational[¶](#non-generational "Permanent link")
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非代际[¶](#non-generational "永久链接")
- en: Many modern GCs, like those in the JVM or .NET CLR, divide memory into *generations*
    (young and old) under the assumption that most objects die young. These collectors
    focus on the young generation, which leads to shorter collection cycles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代垃圾回收器，如JVM或.NET CLR中的那些，在假设大多数对象年轻死亡的情况下将内存划分为*代际*（年轻和年老）。这些收集器专注于年轻代，导致收集周期更短。
- en: Go’s GC takes a different approach. It treats all objects equally—no generational
    segmentation—not because generational GC conflicts with short pause times or concurrent
    scanning, but because it hasn’t shown clear, consistent benefits in real-world
    Go programs with the designs tried so far. This choice avoids the complexity of
    promotion logic and specialized memory regions. While it can mean scanning more
    objects overall, this cost is mitigated by concurrent execution and efficient
    write barriers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go的垃圾回收器采用不同的方法。它平等地对待所有对象——没有代际分割——这不是因为代际垃圾回收器与短暂的暂停时间或并发扫描冲突，而是因为它尚未在迄今为止尝试的Go程序设计中显示出清晰、一致的好处。这种选择避免了提升逻辑和专用内存区域的复杂性。虽然这可能意味着总体上扫描更多的对象，但这种成本通过并发执行和高效的写屏障得到了缓解。
- en: Concurrent[¶](#concurrent "Permanent link")
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发[¶](#concurrent "永久链接")
- en: 'Go’s GC runs concurrently with your application, which means it does most of
    its work without stopping the world. Concurrency is implemented using multiple
    phases that interleave with normal program execution:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go的垃圾回收器与应用程序并发运行，这意味着它的大部分工作都是在不停止世界的情况下完成的。并发是通过使用多个阶段来实现的，这些阶段与正常程序执行交织在一起：
- en: Even though Go’s garbage collector is mostly concurrent, it still requires brief
    Stop-The-World (STW) pauses at several points to maintain correctness. These pauses
    are kept extremely short—typically under 100 microseconds—even with large heaps
    and hundreds of goroutines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go的垃圾回收器主要是并发的，但它仍然需要在几个点上进行短暂的停止世界（STW）暂停以保持正确性。这些暂停被保持得非常短——通常在100微秒以下——即使是在大型堆和数百个goroutine的情况下。
- en: STW is essential for ensuring that memory structures are not mutated while the
    GC analyzes them. In most applications, these pauses are imperceptible. However,
    even sub-millisecond pauses in latency-sensitive systems can be significant—so
    understanding and monitoring STW behavior becomes important when optimizing for
    tail latencies or jitter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: STW对于确保在垃圾回收分析内存结构时内存结构不被修改是必不可少的。在大多数应用程序中，这些暂停是感觉不到的。然而，即使在延迟敏感系统中，亚毫秒级的暂停也可能很重要——因此，当优化尾部延迟或抖动时，理解和监控STW行为变得很重要。
- en: '**STW Start Phase:** The application is briefly paused to initiate GC. The
    runtime scans stacks, globals, and root objects.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STW开始阶段：** 应用程序会短暂暂停以启动垃圾回收。运行时会扫描栈、全局变量和根对象。'
- en: '**Concurrent Mark Phase:** The garbage collector traverses the heap, marking
    all reachable objects while the program continues running. This is the heaviest
    phase in terms of work but runs concurrently to avoid long stop-the-world pauses.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发标记阶段**：垃圾回收器遍历堆，在程序继续运行的同时标记所有可达对象。这是工作量最大的阶段，但它是并发运行的，以避免长时间的停止世界暂停。'
- en: '**STW Mark Termination:** Once marking is mostly complete, the GC briefly pauses
    the program to finish any remaining work and ensure the heap is in a consistent
    state before sweeping begins. This pause is typically very short—measured in microseconds.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STW 标记终止**：一旦标记基本完成，垃圾回收器会短暂暂停程序以完成任何剩余的工作，并在开始清除之前确保堆处于一致状态。这个暂停通常非常短——以微秒计。'
- en: '**Concurrent Sweep Phase:** The GC reclaims memory from unreachable (white)
    objects and returns it to the heap for reuse, all while your program continues
    running.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发清除阶段**：垃圾回收器从不可达（白色）对象中回收内存，并将其返回到堆中以供重用，同时你的程序继续运行。'
- en: Write barriers ensure correctness while the application mutates objects during
    concurrent marking. These barriers help track references created or modified mid-scan
    so the GC doesn’t miss them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 写屏障确保在应用程序在并发标记期间修改对象时的正确性。这些屏障有助于跟踪扫描过程中创建或修改的引用，以便垃圾回收器不会错过它们。
- en: Tri-color Mark and Sweep[¶](#tri-color-mark-and-sweep "Permanent link")
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三色标记和清除[¶](#tri-color-mark-and-sweep "永久链接")
- en: 'The tri-color algorithm breaks the heap into three working sets during garbage
    collection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 三色算法在垃圾回收期间将堆分成三个工作集：
- en: '**White:** Objects that haven’t been reached—if they stay white, they’ll be
    collected.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白色**：尚未到达的对象——如果它们保持白色，它们将被收集。'
- en: '**Grey:** Objects that have been discovered (i.e., marked as reachable) but
    haven’t had their references scanned yet.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灰色**：已经被发现（即，标记为可达）但尚未扫描其引用的对象。'
- en: '**Black:** Objects that are both reachable and fully scanned—they’re retained
    and don’t need further processing.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑色**：既是可达的又被完全扫描的对象——它们被保留，不需要进一步处理。'
- en: 'Garbage collection starts by marking all root objects (stack, globals, etc.)
    grey. It then walks the grey set: for each object, it scans its fields. Any referenced
    objects that are still white are added to the grey set. Once an object’s references
    are fully processed, it’s marked black.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收首先将所有根对象（栈、全局变量等）标记为灰色。然后遍历灰色集合：对于每个对象，它扫描其字段。任何仍然是白色的被引用对象都被添加到灰色集合中。一旦一个对象的引用被完全处理，它就被标记为黑色。
- en: When no grey objects remain, anything still white is unreachable and gets cleaned
    up during the sweep phase. This model ensures that no live object is accidentally
    collected—even if references change mid-scan—thanks to Go’s write barriers that
    maintain the algorithm’s core invariants.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有灰色对象剩下时，任何仍然保持白色的对象在清除阶段都会被清理。这种模型确保没有活动对象被意外收集——即使引用在扫描过程中发生变化——这要归功于 Go
    的写屏障，它维护了算法的核心不变性。
- en: 'A key optimization is **incremental marking**: Go spreads out GC work to avoid
    long pauses, supported by precise stack scanning and conservative write barriers.
    The use of concurrent sweeping further reduces latency, allowing memory to be
    reclaimed without halting execution.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的优化是**增量标记**：Go 将 GC 工作分散到避免长时间暂停，由精确的栈扫描和保守的写屏障支持。并发清除的使用进一步减少了延迟，允许在不停机的情况下回收内存。
- en: This design gives Go a GC that’s safe, fast, and friendly to server workloads
    with large heaps and many cores.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使 Go 的垃圾回收器既安全又快速，对具有大堆和多个核心的服务器工作负载非常友好。
- en: 'GC Tuning: GOGC[¶](#gc-tuning-gogc "Permanent link")'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC 调优：GOGC[¶](#gc-tuning-gogc "永久链接")
- en: Go’s garbage collector is tuned to deliver good performance without manual configuration.
    The default `GOGC` setting typically strikes the right balance between memory
    consumption and CPU effort, adapting well across a wide range of workloads. In
    most cases, manually tweaking it offers little benefit—and in many, it actually
    makes things worse by increasing either pause times or memory pressure. Unless
    you’ve profiled a specific bottleneck and understand the trade-offs, it’s usually
    best to leave `GOGC` alone.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的垃圾回收器经过调整，能够在不进行手动配置的情况下提供良好的性能。默认的 `GOGC` 设置通常在内存消耗和 CPU 努力之间取得适当的平衡，能够很好地适应广泛的工作负载。在大多数情况下，手动调整它带来的好处很少——在许多情况下，它实际上会使事情变得更糟，通过增加暂停时间或内存压力。除非你已经分析了特定的瓶颈并理解了权衡，否则通常最好让
    `GOGC` 保持原样。
- en: That said, there are specific cases where tuning `GOGC` can yield significant
    gains. For example, [Uber implemented dynamic GC tuning](https://www.uber.com/en-GB/blog/how-we-saved-70k-cores-across-30-mission-critical-services/)
    across their Go services to reduce CPU usage and saved tens of thousands of cores
    in the process. Their approach relied on profiling, metric collection, and automation
    to safely adjust GC behavior based on actual memory pressure and workload characteristics.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有一些特定的情况，调整`GOGC`可以带来显著的收益。例如，Uber在其Go服务中实施了动态GC调整[Uber实现了动态GC调整](https://www.uber.com/en-GB/blog/how-we-saved-70k-cores-across-30-mission-critical-services/)，以减少CPU使用并在这个过程中节省了数万个核心。他们的方法依赖于性能分析、指标收集和自动化，以根据实际的内存压力和工作负载特征安全地调整GC行为。
- en: Another unusual case is from Cloudflare. They [profiled a high-concurrency cryptographic
    workload](https://blog.cloudflare.com/go-dont-collect-my-garbage/) and found that
    Go’s GC became a bottleneck as goroutines increased. Their application produced
    minimal garbage, yet GC overhead grew with concurrency. By tuning GOGC to a much
    higher value—specifically 11300—they significantly reduced GC frequency and improved
    throughput, achieving over 22× performance gains compared to the single-core baseline.
    This case highlights how allowing more heap growth in CPU-bound and low-allocation
    scenarios can yield major improvements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不寻常的案例来自Cloudflare。他们[对高并发加密工作负载进行了性能分析](https://blog.cloudflare.com/go-dont-collect-my-garbage/)，发现随着goroutine的增加，Go的GC成为瓶颈。他们的应用程序产生的垃圾最少，但GC开销随着并发性增长。通过将GOGC调整到一个更高的值——具体为11300——他们显著减少了GC频率并提高了吞吐量，与单核基线相比实现了超过22倍的性能提升。这个案例突出了在CPU密集型和低分配场景中允许更多的堆增长可以带来重大改进。
- en: 'So, if you decide to tune the garbage collector, be methodical:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你决定调整垃圾回收器，请保持条理性：
- en: Always profile first. Use tools like `pprof` to confirm that GC activity is
    a bottleneck.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先进行性能分析。使用像`pprof`这样的工具来确认GC活动是否是瓶颈。
- en: Change settings incrementally. For example, increasing `GOGC` from 100 to 150
    means the GC will run less frequently, using less CPU but more memory.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步更改设置。例如，将`GOGC`从100增加到150意味着GC将运行得更少，使用更少的CPU但更多的内存。
- en: Verify impact. After tuning, validate with profiling data that the change had
    a positive effect. Without that confirmation, it's easy to make things worse.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证影响。调整后，使用性能数据验证更改是否产生了积极的效果。没有这种确认，很容易使事情变得更糟。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Memory Limiting with `GOMEMLIMIT`[¶](#memory-limiting-with-gomemlimit "Permanent
    link")
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`GOMEMLIMIT`进行内存限制[¶](#memory-limiting-with-gomemlimit "永久链接")
- en: In addition to `GOGC`, Go provides `GOMEMLIMIT`—a soft memory limit that caps
    the total heap size the runtime will try to stay under. This allows you to explicitly
    control memory growth, especially useful in environments like containers or systems
    with strict memory budgets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`GOGC`之外，Go还提供了`GOMEMLIMIT`——这是一个软内存限制，限制了运行时将尝试保持在总堆大小之下的上限。这允许你显式地控制内存增长，在容器或具有严格内存预算的系统等环境中特别有用。
- en: Why is this helpful? In containerized environments (like Kubernetes), memory
    limits are typically enforced at the OS or orchestrator level. If your application
    exceeds its memory quota, the OOM killer may abruptly terminate the container.
    Go's GC isn't aware of those limits by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处？在容器化环境中（如Kubernetes），内存限制通常在OS或编排器级别强制执行。如果你的应用程序超过了其内存配额，OOM杀手可能会突然终止容器。默认情况下，Go的GC并不了解这些限制。
- en: 'Setting a `GOMEMLIMIT` helps prevent this. For example, if your container has
    a 512MiB memory limit, you might set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`GOMEMLIMIT`有助于防止这种情况。例如，如果你的容器有512MiB的内存限制，你可能设置：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This buffer gives the Go runtime room to act before reaching the hard system-imposed
    memory cap. It allows the garbage collector to become more aggressive as total
    memory usage grows, reducing the chances of the process being killed due to an
    out-of-memory condition. It also leaves space for non-heap allocations—like goroutine
    stacks, OS threads, and other internal runtime structures—which don’t count toward
    heap size but still consume real memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缓冲区为Go运行时提供了在达到系统强加的内存上限之前行动的空间。它允许垃圾回收器随着总内存使用量的增长而变得更加激进，从而降低因内存不足而杀死进程的可能性。它还留出了非堆分配的空间——如goroutine栈、OS线程和其他内部运行时结构，这些不计算在堆大小之内，但仍然消耗实际内存。
- en: 'You can also set the limit programmatically:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过编程设置限制：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The GC will become more aggressive as heap usage nears the limit, which can
    increase CPU load. Be careful not to set the limit too low—especially if your
    application maintains a large live set of objects—or you may trigger excessive
    GC cycles.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当堆使用接近限制时，GC 将变得更加激进，这可能会增加 CPU 负载。请小心不要设置限制得太低——特别是如果你的应用程序维护了一个大的活动对象集——否则可能会触发过多的
    GC 循环。
- en: 'While `GOGC` controls how frequently the GC runs based on heap growth, `GOMEMLIMIT`
    constrains the heap size itself. The two can be combined for more precise control:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `GOGC` 根据堆增长控制 GC 运行的频率，但 `GOMEMLIMIT` 本身限制了堆的大小。这两个可以结合使用以实现更精确的控制：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells the GC to operate with the default growth ratio and to start collecting
    sooner if heap usage nears 4 GiB.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 GC 使用默认的增长比率，并在堆使用接近 4 GiB 时开始收集。
- en: GOMEMLIMIT=X and GOGC=off configuration[¶](#gomemlimitx-and-gogcoff-configuration
    "Permanent link")
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GOMEMLIMIT=X 和 GOGC=off 配置[¶](#gomemlimitx-and-gogcoff-configuration "永久链接")
- en: 'In scenarios where memory availability is fixed and predictable—such as within
    containers or VMs, you can use these two variables together:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存可用性固定且可预测的场景中——例如在容器或虚拟机内部，你可以同时使用这两个变量：
- en: '`GOMEMLIMIT=X` tells the runtime to aim for a specific memory ceiling. For
    example, `GOMEMLIMIT=2GiB` will trigger garbage collection when total memory usage
    nears 2 GiB.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOMEMLIMIT=X` 告诉运行时目标一个特定的内存上限。例如，`GOMEMLIMIT=2GiB` 当总内存使用接近 2 GiB 时将触发垃圾回收。'
- en: '`GOGC=off` disables the default GC pacing algorithm, so garbage collection
    only runs when the memory limit is hit.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOGC=off` 禁用了默认的 GC 调度算法，因此垃圾回收仅在内存限制达到时运行。'
- en: This configuration maximizes memory usage efficiency and avoids the overhead
    of frequent GC cycles. It's especially effective in high-throughput or latency-sensitive
    systems where predictable memory usage matters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置最大化内存使用效率，并避免了频繁 GC 循环的开销。它特别适用于高吞吐量或对延迟敏感的系统，在这些系统中，可预测的内存使用非常重要。
- en: '**Example:**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this setup, memory usage grows freely until the 2 GiB threshold is reached.
    At that point, Go performs a full garbage collection pass.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置下，内存使用量会自由增长，直到达到 2 GiB 的阈值。在那个点上，Go 执行完整的垃圾回收遍历。
- en: Warning
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Always benchmark with your real workload. Disabling automatic GC can backfire
    if your application produces a lot of short-lived allocations.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用你的实际工作负载进行基准测试。如果你的应用程序产生了大量的短生命周期分配，禁用自动 GC 可能会适得其反。
- en: Monitor memory pressure and GC pause times using `runtime.ReadMemStats` or `pprof`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `runtime.ReadMemStats` 或 `pprof` 监控内存压力和 GC 暂停时间。
- en: This approach works best when your memory usage patterns are well understood
    and stable.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的内存使用模式被充分理解和稳定时，这种方法效果最佳。
- en: Practical Strategies for Reducing GC Pressure[¶](#practical-strategies-for-reducing-gc-pressure
    "Permanent link")
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低 GC 压力的实用策略[¶](#practical-strategies-for-reducing-gc-pressure "永久链接")
- en: Prefer Stack Allocation[¶](#prefer-stack-allocation "Permanent link")
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先使用栈分配[¶](#prefer-stack-allocation "永久链接")
- en: 'Go allocates variables on the stack whenever possible. Avoid escaping variables
    to the heap:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在可能的情况下始终在栈上分配变量。避免将变量逃逸到堆上：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use `go build -gcflags="-m"` to view escape analysis diagnostics. See [Stack
    Allocations and Escape Analysis](../stack-alloc/) for more details.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go build -gcflags="-m"` 来查看逃逸分析诊断。有关更多详细信息，请参阅 [堆分配和逃逸分析](../stack-alloc/)。
- en: Use sync.Pool for Short-Lived Objects[¶](#use-syncpool-for-short-lived-objects
    "Permanent link")
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 为短生命周期的对象[¶](#use-syncpool-for-short-lived-objects "永久链接")
- en: '`sync.Pool` is ideal for temporary, reusable allocations that are expensive
    to GC.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Pool` 是用于临时、可重复使用的分配的理想选择，这些分配的 GC 成本很高。'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See [Object Pooling](../object-pooling/) for more details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅 [对象池](../object-pooling/)。
- en: Batch Allocations[¶](#batch-allocations "Permanent link")
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量分配[¶](#batch-allocations "永久链接")
- en: Group allocations into fewer objects to reduce GC pressure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将分配组合成更少的对象以减少 GC 压力。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See [Memory Preallocation](../mem-prealloc/) for more details.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅 [内存预分配](../mem-prealloc/)。
- en: Weak References in Go[¶](#weak-references-in-go "Permanent link")
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的弱引用[¶](#weak-references-in-go "永久链接")
- en: 'Go 1.24 added the `weak` package, providing a standardized way to create weak
    references—pointers that don’t keep their target objects alive. In garbage-collected
    systems like Go, strong references extend an object’s lifetime: as long as something
    points to it, it won’t be collected. That’s usually what you want, but in structures
    like caches, deduplication maps, or object graphs, this can lead to memory staying
    alive much longer than intended. Weak references solve that by allowing you to
    refer to an object without blocking the GC from reclaiming it when nothing else
    is using it.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.24 添加了 `weak` 包，提供了一种创建弱引用的标准方法——这些引用不会保持其目标对象存活。在像 Go 这样的垃圾收集系统中，强引用扩展了对象的生命周期：只要还有东西指向它，它就不会被收集。这通常是您想要的，但在像缓存、去重映射或对象图这样的结构中，这可能导致内存存活时间远长于预期。弱引用通过允许您在不阻止垃圾收集器回收它的情况下引用对象来解决这一问题。
- en: 'A weak reference, by contrast, tells the garbage collector: “you can collect
    this object if nothing else is strongly referencing it.” This pattern is important
    for building memory-sensitive data structures that should not interfere with garbage
    collection.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，弱引用会告诉垃圾收集器：“如果没有其他强引用，您可以收集这个对象。”这种模式对于构建不应干扰垃圾收集的内存敏感数据结构非常重要。
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, `wp` holds a weak reference to a `Data` object. After the strong
    reference (`data`) goes out of scope and the garbage collector runs, the `Data`
    may be collected—at which point `wp.Value()` will return nil. This pattern is
    especially useful in memory-sensitive contexts like caches or canonicalization
    maps, where you want to avoid artificially extending object lifetimes. Always
    check the result of `Value()` before using it, since the target may have been
    reclaimed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`wp` 持有一个对 `Data` 对象的弱引用。在强引用（`data`）超出作用域并且垃圾收集器运行后，`Data` 可能会被收集——此时
    `wp.Value()` 将返回 nil。这种模式在像缓存或规范映射这样的内存敏感环境中特别有用，在这些环境中，您希望避免人为地延长对象的生命周期。始终在使用之前检查
    `Value()` 的结果，因为目标可能已经被回收。
- en: Benchmarking Impact[¶](#benchmarking-impact "Permanent link")
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响[¶](#benchmarking-impact "永久链接")
- en: It's tempting to rely on synthetic benchmarks to evaluate the performance of
    Go's garbage collector, but generic benchmarks rarely capture the nuances of real-world
    workloads. Memory behavior is highly dependent on allocation patterns, object
    lifetimes, concurrency, and how frequently short-lived versus long-lived data
    structures are used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于合成基准测试来评估 Go 的垃圾收集器性能很诱人，但通用基准测试很少能捕捉到真实工作负载的细微差别。内存行为高度依赖于分配模式、对象生命周期、并发性以及短生命周期与长生命周期数据结构的使用频率。
- en: For example, the impact of GC in a CPU-bound microservice that maintains large
    in-memory indexes will differ dramatically from an I/O-heavy API server with minimal
    heap usage. As such, tuning decisions should always be informed by your application's
    profiling data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在维护大型内存索引的 CPU 密集型微服务中，垃圾收集的影响将显著不同于具有最小堆使用的 I/O 重的 API 服务器。因此，调优决策应始终基于您的应用程序的配置文件数据。
- en: 'We cover targeted use cases and their GC performance trade-offs in more focused
    articles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更专注的文章中涵盖了目标用例及其垃圾收集性能权衡：
- en: '[Object Pooling](../object-pooling/): Reducing allocation churn using `sync.Pool`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[对象池](../object-pooling/): 使用 `sync.Pool` 减少分配 churn'
- en: '[Stack Allocations and Escape Analysis](../stack-alloc/): Minimizing heap usage
    by keeping values on the stack'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[堆栈分配和逃逸分析](../stack-alloc/): 通过保持值在堆栈上最小化堆使用'
- en: '[Memory Preallocation](../mem-prealloc/): Avoiding unnecessary growth of slices
    and maps'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内存预分配](../mem-prealloc/): 避免切片和映射的不必要增长'
- en: When applied to the right context, these techniques can make a measurable difference,
    but they don’t lend themselves to one-size-fits-all benchmarks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于正确的上下文时，这些技术可以产生可测量的差异，但它们不适合一刀切的基准测试。
