["```go\nGOGC=100  # Default: GC runs when heap grows 100% since last collection\nGOGC=off  # Disables GC (use only in special cases like short-lived CLI tools) \n```", "```go\nGOMEMLIMIT=400MiB \n```", "```go\nimport \"runtime/debug\"\n\ndebug.SetMemoryLimit(2 << 30) // 2 GiB \n```", "```go\nGOGC=100 GOMEMLIMIT=4GiB ./your-service \n```", "```go\nGOMEMLIMIT=2GiB GOGC=off ./my-app \n```", "```go\n// BAD: returns pointer to heap-allocated struct\nfunc newUser(name string) *User {\n    return &User{Name: name}  // escapes to heap\n}\n\n// BETTER: use value types if pointer is unnecessary\nfunc printUser(u User) {\n    fmt.Println(u.Name)\n} \n```", "```go\nvar bufPool = sync.Pool{\n    New: func() any { return new(bytes.Buffer) },\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    buf := bufPool.Get().(*bytes.Buffer)\n    buf.Reset()\n    defer bufPool.Put(buf)\n\n    // Use buf...\n} \n```", "```go\n// Instead of allocating many small structs, allocate a slice of structs\nusers := make([]User, 0, 1000)  // single large allocation \n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n    \"weak\"\n)\n\ntype Data struct {\n    Value string\n}\n\nfunc main() {\n    data := &Data{Value: \"Important\"}\n    wp := weak.Make(data) // create weak pointer\n\n    fmt.Println(\"Original:\", wp.Value().Value)\n\n    data = nil // remove strong reference\n    runtime.GC()\n\n    if v := wp.Value(); v != nil {\n        fmt.Println(\"Still alive:\", v.Value)\n    } else {\n        fmt.Println(\"Data has been collected\")\n    }\n} \n```", "```go\nOriginal: Important\nData has been collected \n```"]