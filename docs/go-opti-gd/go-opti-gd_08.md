# 内存效率：掌握 Go 的垃圾回收器

> 原文：[`goperf.dev/01-common-patterns/gc/`](https://goperf.dev/01-common-patterns/gc/)

Go 中的内存管理是自动化的——但它并非不可见。你进行的每一次分配都会对 GC 的工作负载做出贡献。对象创建和丢弃的频率越高，运行时在回收内存方面需要做的工作就越多。

这在优先考虑低延迟、可预测的资源使用或高吞吐量的系统中尤为重要。调整你的分配模式并利用像弱引用这样的新功能可以帮助减轻 GC 的压力，而不会增加你代码的复杂性。

## Go 的垃圾回收器是如何工作的

信息

强烈建议你阅读官方的[A Guide to the Go Garbage Collector](https://go.dev/doc/gc-guide)！该文档提供了对多个 Go 的 GC 内部结构的详细描述。

Go 使用一个**非代、并发、三色标记-清除**垃圾收集器。以下是它在实际中的含义以及它的实现方式。

### 非代

许多现代 GC，如 JVM 或.NET CLR 中的 GC，基于大多数对象年轻时就死亡这一假设，将内存划分为*代*（年轻和年老）。这些收集器专注于年轻代，这导致了更短的收集周期。

Go 的 GC 采取了一种不同的方法。它平等地对待所有对象——没有代分割——不是因为代 GC 与短暂的暂停时间或并发扫描冲突，而是因为到目前为止的设计在现实世界的 Go 程序中并没有显示出明确、一致的好处。这种选择避免了提升逻辑和专用内存区域的复杂性。虽然这可能意味着总体上需要扫描更多的对象，但这种成本通过并发执行和高效的写屏障得到了缓解。

### 并发

Go 的 GC 与你的应用程序并发运行，这意味着它的大部分工作都不需要停止世界。并发是通过多个阶段实现的，这些阶段与正常程序执行交织在一起：

尽管 Go 的垃圾收集器主要是并发的，但它仍然需要在几个点上进行短暂的停止世界（STW）暂停，以保持正确性。这些暂停被保持得非常短——通常在 100 微秒以下——即使是在大型堆和数百个 goroutine 的情况下。

STW 对于确保在 GC 分析内存结构时内存结构不被修改是必不可少的。在大多数应用程序中，这些暂停是感觉不到的。然而，在延迟敏感系统中，即使是亚毫秒的暂停也可能很重要——因此，当优化尾部延迟或抖动时，理解和监控 STW 行为变得很重要。

+   **STW 开始阶段**：应用程序会短暂暂停以启动 GC。运行时会扫描栈、全局变量和根对象。

+   **并发标记阶段**：垃圾收集器遍历堆，在程序继续运行的同时标记所有可达对象。这是工作量最大的阶段，但它是并发运行的，以避免长时间的停止世界暂停。

+   **STW 标记终止**：一旦标记基本完成，GC 会短暂暂停程序以完成任何剩余的工作，并在开始清除之前确保堆处于一致状态。这种暂停通常非常短——以微秒计。

+   **并发清除阶段**：GC 从不可达（白色）对象中回收内存，并将其返回到堆中以供重用，同时你的程序继续运行。

写屏障确保在应用程序并发标记期间对象突变时的正确性。这些屏障有助于跟踪扫描过程中创建或修改的引用，以便垃圾回收器不会错过它们。

### 三色标记和清除

三色算法在垃圾回收期间将堆拆分为三个工作集：

+   **白色**：尚未到达的对象——如果它们保持白色，它们将被收集。

+   **灰色**：已发现的对象（即，标记为可达）但尚未扫描其引用。

+   **黑色**：既可达又完全扫描的对象——它们被保留，不需要进一步处理。

垃圾回收首先将所有根对象（栈、全局变量等）标记为灰色。然后遍历灰色集：对于每个对象，它扫描其字段。任何仍为白色的引用对象都将添加到灰色集中。一旦一个对象的引用被完全处理，它就被标记为黑色。

当没有灰色对象剩余时，任何仍为白色的对象都是不可达的，并在清除阶段被清理。这种模型确保没有活动对象被意外收集——即使引用在扫描过程中发生变化——这得益于 Go 的写屏障，它维护算法的核心不变性。

一个关键的优化是**增量标记**：Go 将 GC 工作分散以避免长时间暂停，这得益于精确的栈扫描和保守的写屏障。并发清除的使用进一步减少了延迟，允许在不停机的情况下回收内存。

这种设计使 Go 的 GC 变得安全、快速，并且对具有大堆和多个核心的服务器工作负载友好。

## GC 调优：GOGC

Go 的垃圾回收器经过调整，在不进行手动配置的情况下提供良好的性能。默认的 `GOGC` 设置通常在内存消耗和 CPU 努力之间取得平衡，适应广泛的负载。在大多数情况下，手动调整它几乎没有好处——在许多情况下，它实际上会使事情变得更糟，通过增加暂停时间或内存压力。除非你已经分析了特定的瓶颈并理解了权衡，否则通常最好让 `GOGC` 保持原样。

话虽如此，在某些特定情况下调整 `GOGC` 可以带来显著的收益。例如，[Uber 在其 Go 服务中实施了动态 GC 调整](https://www.uber.com/en-GB/blog/how-we-saved-70k-cores-across-30-mission-critical-services/) 以减少 CPU 使用，并在过程中节省了数万个核心。他们的方法依赖于分析、指标收集和自动化，以根据实际的内存压力和工作负载特征安全地调整 GC 行为。

另一个不寻常的案例来自 Cloudflare。他们 [分析了高并发加密工作负载](https://blog.cloudflare.com/go-dont-collect-my-garbage/) 并发现，随着 goroutine 的增加，Go 的 GC 变成了瓶颈。他们的应用程序产生的垃圾最少，但 GC 开销随着并发性增长。通过将 GOGC 调整到一个更高的值——具体为 11300——他们显著减少了 GC 频率并提高了吞吐量，与单核基线相比实现了超过 22 倍的性能提升。这个案例突出了在 CPU 密集型和低分配场景中允许更多堆增长如何带来重大改进。

因此，如果你决定调整垃圾收集器，请有计划地进行：

+   总是先进行性能分析。使用 `pprof` 等工具确认 GC 活动是瓶颈。

+   逐步更改设置。例如，将 `GOGC` 从 100 增加到 150 意味着 GC 将运行得更少，使用更少的 CPU 但更多的内存。

+   验证影响。调整后，使用分析数据验证更改是否产生了积极效果。没有这种确认，很容易使事情变得更糟。

```go
`GOGC=100  # Default: GC runs when heap grows 100% since last collection GOGC=off  # Disables GC (use only in special cases like short-lived CLI tools)` 
```

### 使用 `GOMEMLIMIT` 进行内存限制

除了 `GOGC` 之外，Go 还提供了 `GOMEMLIMIT`——这是一个软内存限制，它限制了运行时尝试保持在下的总堆大小。这允许你显式地控制内存增长，这在容器或具有严格内存预算的系统等环境中特别有用。

这有什么好处？在容器化环境中（如 Kubernetes），内存限制通常在操作系统或编排器级别强制执行。如果你的应用程序超过了其内存配额，OOM 杀手可能会突然终止容器。Go 的 GC 默认情况下并不了解这些限制。

设置 `GOMEMLIMIT` 有助于防止这种情况。例如，如果你的容器有 512MiB 的内存限制，你可能设置如下：

```go
`GOMEMLIMIT=400MiB` 
```

这个缓冲区为 Go 运行时提供了在达到系统强加的内存上限之前进行操作的空间。它允许垃圾收集器在总内存使用量增长时变得更加激进，从而降低因内存不足而终止进程的可能性。它还留出了空间用于非堆分配——例如 goroutine 栈、OS 线程和其他内部运行时结构，这些结构不计入堆大小，但仍然消耗实际内存。

你也可以通过编程方式设置限制：

```go
`import  "runtime/debug"  debug.SetMemoryLimit(2  <<  30)  // 2 GiB` 
```

当堆使用接近限制时，GC 将变得更加激进，这可能会增加 CPU 负载。请小心不要将限制设置得太低——特别是如果您的应用程序维护一个大型活动对象集——否则可能会触发过多的 GC 循环。

虽然 `GOGC` 根据堆增长频率控制 GC 的运行，但 `GOMEMLIMIT` 限制了堆的大小。这两个变量可以结合使用以实现更精确的控制：

```go
`GOGC=100  GOMEMLIMIT=4GiB  ./your-service` 
```

这告诉 GC 以默认的增长比率运行，并在堆使用接近 4 GiB 时开始收集。

### GOMEMLIMIT=X 和 GOGC=off 配置

在内存可用性固定且可预测的场景中——例如在容器或虚拟机中，你可以同时使用这两个变量：

+   `GOMEMLIMIT=X` 告诉运行时达到特定的内存上限。例如，`GOMEMLIMIT=2GiB` 将在总内存使用量接近 2 GiB 时触发垃圾回收。

+   `GOGC=off` 禁用了默认的 GC 调度算法，因此垃圾回收仅在达到内存限制时运行。

此配置最大化内存使用效率，并避免了频繁 GC 循环的开销。它特别适用于高吞吐量或对延迟敏感的系统，在这些系统中，可预测的内存使用很重要。

**示例：**

```go
`GOMEMLIMIT=2GiB  GOGC=off  ./my-app` 
```

在这种设置下，内存使用量自由增长，直到达到 2 GiB 的阈值。在那个时刻，Go 执行完整的垃圾回收过程。

警告

+   总是用您的实际工作负载进行基准测试。如果您的应用程序产生大量短生命周期的分配，禁用自动 GC 可能会适得其反。

+   使用 `runtime.ReadMemStats` 或 `pprof` 监控内存压力和 GC 暂停时间。

+   当您的内存使用模式被充分理解和稳定时，这种方法效果最佳。

## 降低 GC 压力的实用策略

### 优先使用栈分配

Go 在可能的情况下始终在栈上分配变量。避免将变量逃逸到堆上：

```go
`// BAD: returns pointer to heap-allocated struct func  newUser(name  string)  *User  {   return  &User{Name:  name}  // escapes to heap }  // BETTER: use value types if pointer is unnecessary func  printUser(u  User)  {   fmt.Println(u.Name) }` 
```

使用 `go build -gcflags="-m"` 查看逃逸分析诊断。有关更多详细信息，请参阅栈分配和逃逸分析。

### 用于短生命周期对象的 sync.Pool

`sync.Pool` 是用于临时、可重用且 GC 成本高昂的分配的理想选择。

```go
`var  bufPool  =  sync.Pool{   New:  func()  any  {  return  new(bytes.Buffer)  }, }  func  handler(w  http.ResponseWriter,  r  *http.Request)  {   buf  :=  bufPool.Get().(*bytes.Buffer)   buf.Reset()   defer  bufPool.Put(buf)    // Use buf... }` 
```

有关更多详细信息，请参阅对象池。

### 批量分配

将内存分配分组到更少的对象中，以降低 GC 压力。

```go
`// Instead of allocating many small structs, allocate a slice of structs users  :=  make([]User,  0,  1000)  // single large allocation` 
```

有关更多详细信息，请参阅内存预分配。

## Go 中的弱引用

Go 1.24 添加了 `weak` 包，提供了一种创建弱引用的标准方式——这些引用不会保持其目标对象存活。在像 Go 这样的垃圾回收系统中，强引用延长了对象的生命周期：只要有什么东西指向它，它就不会被回收。这通常是您想要的，但在像缓存、去重映射或对象图这样的结构中，这可能导致内存存活时间远超过预期。弱引用通过允许您在不阻止 GC 在没有其他东西使用它时回收对象的情况下引用对象来解决此问题。

与之相反，弱引用会告诉垃圾收集器：“如果没有任何其他强引用引用它，你可以收集这个对象。”这种模式对于构建不应干扰垃圾收集的内存敏感数据结构非常重要。

```go
`package  main  import  (   "fmt"   "runtime"   "weak" )  type  Data  struct  {   Value  string }  func  main()  {   data  :=  &Data{Value:  "Important"}   wp  :=  weak.Make(data)  // create weak pointer    fmt.Println("Original:",  wp.Value().Value)    data  =  nil  // remove strong reference   runtime.GC()    if  v  :=  wp.Value();  v  !=  nil  {   fmt.Println("Still alive:",  v.Value)   }  else  {   fmt.Println("Data has been collected")   } }` 
```

```go
`Original: Important Data has been collected` 
```

在这个例子中，`wp` 持有一个对 `Data` 对象的弱引用。在强引用（`data`）超出作用域并且垃圾收集器运行后，`Data` 可能被收集——此时 `wp.Value()` 将返回 nil。这种模式在内存敏感的上下文中特别有用，如缓存或规范映射，在这些上下文中，你希望避免人为地延长对象的生命周期。始终在使用之前检查 `Value()` 的结果，因为目标可能已经被回收。

## 基准测试影响

依赖于合成基准来评估 Go 的垃圾收集器性能很诱人，但通用的基准很少能捕捉到真实工作负载的细微差别。内存行为高度依赖于分配模式、对象生命周期、并发性以及短生命周期与长生命周期数据结构的使用频率。

例如，在维护大型内存索引的 CPU 密集型微服务中，GC 的影响与堆使用量极小的 I/O 重的 API 服务器相比将截然不同。因此，调优决策应始终基于你的应用程序的配置文件数据。

我们在更专注的文章中涵盖了目标用例及其 GC 性能权衡：

+   对象池：使用 `sync.Pool` 减少分配波动

+   栈分配和逃逸分析：通过在栈上保持值来最小化堆使用

+   内存预分配：避免切片和映射不必要的增长

当应用于正确的上下文时，这些技术可以产生可测量的差异，但它们不适合所有基准测试。
