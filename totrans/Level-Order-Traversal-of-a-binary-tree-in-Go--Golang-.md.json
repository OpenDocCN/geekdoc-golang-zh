["```\n[[1] [2 3] [4 5 6]]\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\nfunc levelOrder(root *TreeNode) [][]int {\n\tlevelMapNode := make(map[int][]int)\n\tvisit(root, 0, &levelMapNode)\n\n\toutput := make([][]int, 0)\n\n\ti := 0\n\tfor true {\n\t\t_, ok := levelMapNode[i]\n\n\t\tif ok {\n\t\t\toutput = append(output, levelMapNode[i])\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t\ti = i + 1\n\n\t}\n\treturn output\n\n}\n\nfunc visit(root *TreeNode, level int, levelMapNode *map[int][]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\t_, ok := (*levelMapNode)[level]\n\tif ok {\n\t\t(*levelMapNode)[level] = append((*levelMapNode)[level], root.Val)\n\t} else {\n\t\t(*levelMapNode)[level] = []int{root.Val}\n\t}\n\n\tif root.Left != nil {\n\t\tvisit(root.Left, level+1, levelMapNode)\n\t}\n\n\tif root.Right != nil {\n\t\tvisit(root.Right, level+1, levelMapNode)\n\t}\n\treturn\n}\n\nfunc main() {\n\troot := TreeNode{Val: 1}\n\troot.Left = &TreeNode{Val: 2}\n\troot.Right = &TreeNode{Val: 3}\n\troot.Right.Left = &TreeNode{Val: 4}\n\troot.Right.Right = &TreeNode{Val: 5}\n\n\toutput := levelOrder(&root)\n\tfmt.Println(output)\n\n}\n```", "```\n[[1] [2 3] [4 5 6]]\n```"]