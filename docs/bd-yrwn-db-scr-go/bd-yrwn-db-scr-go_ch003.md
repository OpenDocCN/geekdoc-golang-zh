# 02. 索引数据结构

## 2.1 查询类型

大多数 SQL 查询可以分为 3 种类型：

1.  扫描整个数据集。（不使用索引）。

1.  点查询：通过特定的键查询索引。

1.  范围查询：通过范围查询索引。（索引是排序的）。

有方法可以使扫描变得快速，例如基于列的存储。但无论速度有多快，扫描都是 *O*(*N*)；我们的重点是使用数据结构在 *O*(log *N*) 时间内提供查询。

范围查询由两个阶段组成：

1.  查找：找到起始键。

1.  迭代：在排序顺序中找到前一个/下一个键。

点查询只是不带迭代的查找；排序数据结构就是我们需要的所有。

## 2.2 哈希表

如果只考虑点查询（获取、设置、删除），哈希表是可行的，所以我们不会因为缺乏排序而烦恼。

然而，编写哈希表，即使是内存中的哈希表，仍然是一项有价值的练习。它比我们稍后要编写的 B 树容易得多，尽管仍然存在一些挑战：

+   如何扩展哈希表？当负载因子太高时，必须将键移动到更大的哈希表中。一次性移动所有内容是过于 *O*(*N*) 的。即使是像 Redis 这样的内存应用程序，也需要逐步进行重新哈希。

+   其他之前提到的事情：原地更新、空间重用等。

## 2.3 排序数组

排除哈希表，让我们从最简单的排序数据结构开始：排序数组。你可以在 *O*(log *N*) 的时间内对其进行二分搜索。对于如字符串（KV）这样的变长数据，使用指针数组（偏移量）进行二分搜索。

更新排序数组是 *O*(*N*)，无论是原地还是非原地。所以这并不实用，但它可以扩展到其他可更新的数据结构。

减少更新成本的一种方法是将数组分割成几个较小的非重叠数组——嵌套排序数组。这种扩展导致了 B+树（多级 n 叉树），同时还需要维护这些小数组（树节点）的额外挑战。

“可更新数组”的另一种形式是日志结构合并树（LSM-tree）。更新首先在较小的数组（或其他排序数据结构）中缓冲，然后当它变得太大时合并到主数组中。通过将较小的数组传播到较大的数组中，更新成本被摊销。

## 2.4 B 树

B 树是一个平衡的 n 叉树，类似于平衡的二叉树。每个节点存储可变数量的键（和分支），最多为 *n* 且 *n* > 2。

### 使用更短的树减少随机访问

磁盘每秒只能执行有限数量的 I/O 操作（IOPS），这是树查找的限制因素。树的每一层在查找时都是磁盘读取，对于相同数量的键，n 叉树比二叉树短（log[*n*]*N* 与 log[2]*N*），因此 n 叉树在每次查找中需要更少的磁盘读取。

*n* 如何选择？这里有一个权衡：

+   较大的 *n* 意味着每次查找的磁盘读取较少（更好的延迟和吞吐量）。

+   较大的 *n* 意味着更大的节点，更新速度较慢（稍后讨论）。

### 以页面为单位的 I/O

虽然你可以从文件中的任何偏移量读取任意数量的字节，但磁盘并不是这样工作的。磁盘 I/O 的基本单位不是字节，而是扇区，在旧硬盘上，扇区是 512 字节的连续块。

然而，磁盘扇区不是应用程序需要关心的，因为常规文件 I/O 并不直接与磁盘交互。操作系统在 *页面缓存* 中缓存/缓冲磁盘的读取/写入，页面缓存由称为 *页面* 的 4K 字节内存块组成。

无论如何，都有一个最小的 I/O 单元。数据库也可以定义它们自己的 I/O 单元（也称为页面），它可能比操作系统的页面大。

最小 I/O 单元意味着树节点应该以单元的倍数分配；半用单元是半浪费 I/O。反对小 *n* 的另一个原因！

### B+tree 变体

在数据库的上下文中，B-tree 指的是 B-tree 的一个变体，称为 B+tree。在 B+树中，内部节点不存储值，值只存在于叶节点中。这导致树变得更短，因为内部节点有更多的空间用于分支。

B+tree 作为一个内存中的数据结构也是有意义的，因为 RAM 和 CPU 缓存之间的最小 I/O 单元是 64 字节（缓存行）。由于 64 字节中能放入的内容不多，因此在内存中的性能提升不如在磁盘上那么大。

### 数据结构空间开销

另一个为什么二叉树不实用是因为指针的数量；每个键至少从父节点有一个进入指针，而在 B+树中，叶节点中的多个键共享一个进入指针。

叶节点中的键也可以以紧凑的格式打包或压缩，以进一步减少空间。

## 2.5 日志结构化存储

### 通过合并更新：分摊成本

日志结构化存储最常见的一个例子是日志结构合并树（LSM-tree）。它的主要思想既不是日志也不是树；而是“合并”！

让我们从两个文件开始：一个小文件用于存储最近的更新，一个大文件用于存储其余数据。更新首先写入小文件，但小文件不能无限增长；当它达到阈值时，它将被合并到大型文件中。

```go
writes => | new updates | => | accumulated data |
               file 1               file 2
```

合并两个排序文件会产生一个较新、较大的文件，它替换了旧的大文件并缩小了小文件。

合并操作是 *O*(*N*)，但可以与读取者和写入者并发进行。

### 通过多级减少写放大

缓存更新比每次重写整个数据集要好。如果我们把这个方案扩展到多个级别会怎样呢？

```go
 |level 1|
                    ||
                    \/
           |------level 2------|
                    ||
                    \/
|-----------------level 3-----------------|
```

在两级方案中，每当小文件达到阈值时，大文件就会被重写，额外的磁盘写入称为 *写放大*，随着大文件变大，这种情况会变得更糟。如果我们使用更多级别，可以通过将其合并到第三级来保持第二级较小，类似于我们保持第一级较小的做法。

直观地说，级别呈指数增长，两个级别的增长（合并相似大小的级别）会导致最小的写放大。但是，写放大和级别数量（查询性能）之间存在权衡。

### LSM-tree 索引

每个级别包含索引数据结构，这些结构可以简单地是一个排序数组，因为级别永远不会更新（除了第一级）。但是，在随机访问方面，二分搜索并不比二叉树好多少，因此，在级别内部使用 B 树是一个合理的选择，这就是 LSM 树中的“树”部分。无论如何，由于缺乏更新，数据结构要简单得多。

为了更好地理解“合并”的概念，你可以尝试将其应用于哈希表，即日志结构化哈希表。

### LSM 树查询

键可以存在于任何级别，因此查询 LSM 树时，需要将每个级别的结果合并（对于范围查询，进行 n 路合并）。

对于点查询，可以使用布隆过滤器作为优化，以减少搜索的级别数量。

由于级别永远不会更新，旧级别中可能会有旧版本的键，而新级别中删除的键会使用特殊标志标记（称为墓碑）。因此，在查询中，新级别具有优先级。

合并过程自然会回收旧或已删除键的空间。因此，它也被称为*压缩*。

### 真实世界的 LSM 树：SSTable、MemTable 和日志

这些是关于 LSM 树实现细节的术语。你不需要了解它们就可以从原理上构建一个，但它们确实解决了某些实际问题。

级别被分割成多个非重叠文件，称为 SSTables，而不是一个大型文件，这样就可以逐步进行合并。这减少了合并大型级别时的空闲空间需求，并且合并过程被分散到一段时间内。

第一级直接更新，日志成为可行的选择，因为第一级的大小是有限的。这是 LSM 树的“日志”部分，是结合日志与其他索引数据结构的一个例子。

即使日志很小，仍然需要一个合适的索引数据结构。日志数据在内存索引 MemTable 中被*复制*，这可以是 B 树、跳表或任何其他结构。这是一小部分有界内存数据，并且具有加速读取最近更新的场景的附加好处。

## 2.6 索引数据结构总结

有两种选项：B+树和 LSM 树。

LSM 树解决了上一章中的一些挑战，例如如何更新基于磁盘的数据结构和回收空间。虽然这些挑战对于 B+树仍然存在，这将在稍后探讨。
