["```\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\ntype customStack struct {\n    stack *list.List\n}\n\nfunc (c *customStack) Push(value string) {\n    c.stack.PushFront(value)\n}\n\nfunc (c *customStack) Pop() error {\n    if c.stack.Len() > 0 {\n        ele := c.stack.Front()\n        c.stack.Remove(ele)\n    }\n    return fmt.Errorf(\"Pop Error: Stack is empty\")\n}\n\nfunc (c *customStack) Front() (string, error) {\n    if c.stack.Len() > 0 {\n        if val, ok := c.stack.Front().Value.(string); ok {\n            return val, nil\n        }\n        return \"\", fmt.Errorf(\"Peep Error: Stack Datatype is incorrect\")\n    }\n    return \"\", fmt.Errorf(\"Peep Error: Stack is empty\")\n}\n\nfunc (c *customStack) Size() int {\n    return c.stack.Len()\n}\n\nfunc (c *customStack) Empty() bool {\n    return c.stack.Len() == 0\n}\n\nfunc main() {\n    customStack := &customStack{\n        stack: list.New(),\n    }\n    fmt.Printf(\"Push: A\\n\")\n    customStack.Push(\"A\")\n    fmt.Printf(\"Push: B\\n\")\n    customStack.Push(\"B\")\n    fmt.Printf(\"Size: %d\\n\", customStack.Size())\n    for customStack.Size() > 0 {\n        frontVal, _ := customStack.Front()\n        fmt.Printf(\"Front: %s\\n\", frontVal)\n        fmt.Printf(\"Pop: %s\\n\", frontVal)\n        customStack.Pop()\n    }\n    fmt.Printf(\"Size: %d\\n\", customStack.Size())\n}\n```", "```\nPush: A\nPush: B\nSize: 2\nFront: B\nPop: B\nFront: A\nPop: A\nSize: 0\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype customStack struct {\n    stack []string\n    lock  sync.RWMutex\n}\n\nfunc (c *customStack) Push(name string) {\n    c.lock.Lock()\n    defer c.lock.Unlock()\n    c.stack = append(c.stack, name)\n}\n\nfunc (c *customStack) Pop() error {\n    len := len(c.stack)\n    if len > 0 {\n        c.lock.Lock()\n        defer c.lock.Unlock()\n        c.stack = c.stack[:len-1]\n        return nil\n    }\n    return fmt.Errorf(\"Pop Error: Stack is empty\")\n}\n\nfunc (c *customStack) Front() (string, error) {\n    len := len(c.stack)\n    if len > 0 {\n        c.lock.Lock()\n        defer c.lock.Unlock()\n        return c.stack[len-1], nil\n    }\n    return \"\", fmt.Errorf(\"Peep Error: Stack is empty\")\n}\n\nfunc (c *customStack) Size() int {\n    return len(c.stack)\n}\n\nfunc (c *customStack) Empty() bool {\n    return len(c.stack) == 0\n}\n\nfunc main() {\n    customStack := &customStack{\n        stack: make([]string, 0),\n    }\n    fmt.Printf(\"Push: A\\n\")\n    customStack.Push(\"A\")\n    fmt.Printf(\"Push: B\\n\")\n    customStack.Push(\"B\")\n    fmt.Printf(\"Size: %d\\n\", customStack.Size())\n    for customStack.Size() > 0 {\n        frontVal, _ := customStack.Front()\n        fmt.Printf(\"Front: %s\\n\", frontVal)\n        fmt.Printf(\"Pop: %s\\n\", frontVal)\n        customStack.Pop()\n    }\n    fmt.Printf(\"Size: %d\\n\", customStack.Size())\n}\n```", "```\nPush: A\nPush: B\nSize: 2\nFront: B\nPop: B\nFront: A\nPop: A\nSize: 0\n```"]