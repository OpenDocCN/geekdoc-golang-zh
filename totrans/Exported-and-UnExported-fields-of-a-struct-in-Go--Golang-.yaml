- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:19:34'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Exported and UnExported fields of a struct in Go (Golang)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/exported-unexported-fields-struct-go/](https://golangbyexample.com/exported-unexported-fields-struct-go/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go doesn’t have any public,  private or protected keyword. The only mechanism
    to control the visibility outside the package is using the capitalized and non-capitalized
    formats
  prefs: []
  type: TYPE_NORMAL
- en: '**Capitalized Identifiers** are exported. The capital letter indicates that
    this is an exported identifier and is available outside the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-capitalized identifiers **are not exported. The lowercase indicates that
    the identifier is not exported and will only be accessed from within the same
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So any struct which starts with a capital letter is exported to other packages. 
    Similarly, any struct field which starts with capital is exported otherwise not.
    And also similarly any struct method which starts with a capital letter is exported.
    Let’s see an example that shows exporting and non-exporting of structs, struct
    fields, and methods. See **model.go** and **test.go** below. Both belong to the
    **main** package.
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct **Person** is exported
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct **company** is non-exported
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure’s Field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person** struct field **Name** is exported'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person** struct field **age** is not exported but **Name** is exported'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure’s Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person** Struct’s Method **GetAge()** is exported'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person** Struct’s Method **getName()** is not exported'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**model.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s write a file **test.go** in same **main** package. See below.
  prefs: []
  type: TYPE_NORMAL
- en: '**test.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On running this file, it is able to access all exported and un-exported fields
    in **model.go** as both lies in the same package **main**. There is no compilation
    error and it gives below output
  prefs: []
  type: TYPE_NORMAL
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s move the above file **model.go** to a different package named **model.**
    Now notice the output on running ‘go build’. It gives compilation errors. All
    the compilation error are because **test.go** in **main** package to not able
    to refer to un-exported fields of **model.go** in **model** package
  prefs: []
  type: TYPE_NORMAL
- en: '**model.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**test.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
