["```go\nfunc StreamData(src io.Reader, dst io.Writer) error {\n    buf := make([]byte, 4096) // Reusable buffer\n    _, err := io.CopyBuffer(dst, src, buf)\n    return err\n} \n```", "```go\nfunc process(buffer []byte) []byte {\n    return buffer[128:256] // returns a slice reference without copying\n} \n```", "```go\nimport \"golang.org/x/exp/mmap\"\n\nfunc ReadFileZeroCopy(path string) ([]byte, error) {\n    r, err := mmap.Open(path)\n    if err != nil {\n        return nil, err\n    }\n    defer r.Close()\n\n    data := make([]byte, r.Len())\n    _, err = r.ReadAt(data, 0)\n    return data, err\n} \n```", "```go\nfunc BenchmarkCopy(b *testing.B) {\n    data := make([]byte, 64*1024)\n    for b.Loop() {\n        buf := make([]byte, len(data))\n        copy(buf, data)\n    }\n}\n\nfunc BenchmarkSlice(b *testing.B) {\n    data := make([]byte, 64*1024)\n    for b.Loop() {\n        _ = data[:]\n    }\n} \n```", "```go\nfunc BenchmarkReadWithCopy(b *testing.B) {\n    f, err := os.Open(\"testdata/largefile.bin\")\n    if err != nil {\n        b.Fatalf(\"failed to open file: %v\", err)\n    }\n    defer f.Close()\n\n    buf := make([]byte, 4*1024*1024) // 4MB buffer\n    for b.Loop() {\n        _, err := f.ReadAt(buf, 0)\n        if err != nil && err != io.EOF {\n            b.Fatal(err)\n        }\n    }\n}\n\nfunc BenchmarkReadWithMmap(b *testing.B) {\n    r, err := mmap.Open(\"testdata/largefile.bin\")\n    if err != nil {\n        b.Fatalf(\"failed to mmap file: %v\", err)\n    }\n    defer r.Close()\n\n    buf := make([]byte, r.Len())\n    for b.Loop() {\n        _, err := r.ReadAt(buf, 0)\n        if err != nil && err != io.EOF {\n            b.Fatal(err)\n        }\n    }\n} \n```", "```go\ngo get golang.org/x/exp/mmap\nmkdir -p testdata\ndd if=/dev/urandom of=./testdata/largefile.bin bs=1M count=4 \n```", "```go\npackage perf\n\nimport \"testing\"\n\n// interface-start\n\ntype Worker interface {\n    Work()\n}\n\ntype LargeJob struct {\n    payload [4096]byte\n}\n\nfunc (LargeJob) Work() {}\n// interface-end\n\n// bench-slice-start\nfunc BenchmarkBoxedLargeSlice(b *testing.B) {\n    jobs := make([]Worker, 0, 1000)\n    for b.Loop() {\n        jobs = jobs[:0]\n        for j := 0; j < 1000; j++ {\n            var job LargeJob\n            jobs = append(jobs, job)\n        }\n    }\n}\n\nfunc BenchmarkPointerLargeSlice(b *testing.B) {\n    jobs := make([]Worker, 0, 1000)\n    for b.Loop() {\n        jobs := jobs[:0]\n        for j := 0; j < 1000; j++ {\n            job := &LargeJob{}\n            jobs = append(jobs, job)\n        }\n    }\n}\n// bench-slice-end\n\n// bench-call-start\nvar sink Worker\n\nfunc call(w Worker) {\n    sink = w\n}\n\nfunc BenchmarkCallWithValue(b *testing.B) {\n    for b.Loop() {\n        var j LargeJob\n        call(j)\n    }\n}\n\nfunc BenchmarkCallWithPointer(b *testing.B) {\n    for b.Loop() {\n        j := &LargeJob{}\n        call(j)\n    }\n}\n// bench-call-end \n```"]