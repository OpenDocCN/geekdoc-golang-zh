["```go\nvar i interface{}\ni = 42 \n```", "```go\ntype Shape interface {\n    Area() float64\n}\n\ntype Square struct {\n    Size float64\n}\n\nfunc (s Square) Area() float64 { return s.Size * s.Size }\n\nfunc main() {\n    var shapes []Shape\n    for i := 0; i < 1000; i++ {\n        s := Square{Size: float64(i)}\n        shapes = append(shapes, s) // boxing occurs here\n    }\n} \n```", "```go\n shapes = append(shapes, &s) // avoids large struct copy \n```", "```go\ntype Worker interface {\n    Work()\n}\n\ntype LargeJob struct {\n    payload [4096]byte\n}\n\nfunc (LargeJob) Work() {} \n```", "```go\nfunc BenchmarkBoxedLargeSlice(b *testing.B) {\n    jobs := make([]Worker, 0, 1000)\n    for b.Loop() {\n        jobs = jobs[:0]\n        for j := 0; j < 1000; j++ {\n            var job LargeJob\n            jobs = append(jobs, job)\n        }\n    }\n}\n\nfunc BenchmarkPointerLargeSlice(b *testing.B) {\n    jobs := make([]Worker, 0, 1000)\n    for b.Loop() {\n        jobs := jobs[:0]\n        for j := 0; j < 1000; j++ {\n            job := &LargeJob{}\n            jobs = append(jobs, job)\n        }\n    }\n} \n```", "```go\nvar sink Worker\n\nfunc call(w Worker) {\n    sink = w\n}\n\nfunc BenchmarkCallWithValue(b *testing.B) {\n    for b.Loop() {\n        var j LargeJob\n        call(j)\n    }\n}\n\nfunc BenchmarkCallWithPointer(b *testing.B) {\n    for b.Loop() {\n        j := &LargeJob{}\n        call(j)\n    }\n} \n```", "```go\npackage perf\n\nimport \"testing\"\n\n// interface-start\n\ntype Worker interface {\n    Work()\n}\n\ntype LargeJob struct {\n    payload [4096]byte\n}\n\nfunc (LargeJob) Work() {}\n// interface-end\n\n// bench-slice-start\nfunc BenchmarkBoxedLargeSlice(b *testing.B) {\n    jobs := make([]Worker, 0, 1000)\n    for b.Loop() {\n        jobs = jobs[:0]\n        for j := 0; j < 1000; j++ {\n            var job LargeJob\n            jobs = append(jobs, job)\n        }\n    }\n}\n\nfunc BenchmarkPointerLargeSlice(b *testing.B) {\n    jobs := make([]Worker, 0, 1000)\n    for b.Loop() {\n        jobs := jobs[:0]\n        for j := 0; j < 1000; j++ {\n            job := &LargeJob{}\n            jobs = append(jobs, job)\n        }\n    }\n}\n// bench-slice-end\n\n// bench-call-start\nvar sink Worker\n\nfunc call(w Worker) {\n    sink = w\n}\n\nfunc BenchmarkCallWithValue(b *testing.B) {\n    for b.Loop() {\n        var j LargeJob\n        call(j)\n    }\n}\n\nfunc BenchmarkCallWithPointer(b *testing.B) {\n    for b.Loop() {\n        j := &LargeJob{}\n        call(j)\n    }\n}\n// bench-call-end \n```", "```go\ntype Storage interface {\n    Save([]byte) error\n}\nfunc Process(s Storage) { /* ... */ } \n```", "```go\nvar i interface{}\ni = 123 // safe and cheap \n```", "```go\nfmt.Println(\"value:\", someStruct) // implicit boxing is fine \n```", "```go\nfor _, s := range []Shape{Circle{}, Square{}} {\n    fmt.Println(s.Area())\n} \n```", "```go\n    for i := range tasks {\n       result = append(result, &tasks[i]) // Avoids boxing copies\n    } \n    ```"]