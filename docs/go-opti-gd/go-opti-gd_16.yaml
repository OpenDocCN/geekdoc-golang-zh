- en: Immutable Data Sharing¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变数据共享¶
- en: 原文：[https://goperf.dev/01-common-patterns/immutable-data/](https://goperf.dev/01-common-patterns/immutable-data/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/immutable-data/](https://goperf.dev/01-common-patterns/immutable-data/)
- en: 'One common source of slowdown in high-performance Go programs is the way shared
    data is accessed under concurrency. The usual tools—mutexes and channels—work
    well, but they’re not free. Mutexes can become choke points if many goroutines
    try to grab the same lock. Channels, while elegant for coordination, can introduce
    blocking and make control flow harder to reason about. Both require careful use:
    it’s easy to introduce subtle bugs or unexpected performance issues if synchronization
    isn’t tight.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能 Go 程序中常见的性能瓶颈之一是并发下对共享数据的访问方式。常用的工具——互斥锁和通道——效果很好，但它们不是免费的。如果许多 goroutine
    尝试获取相同的锁，互斥锁可能会成为瓶颈。通道虽然优雅地用于协调，但可能会引入阻塞，使控制流更难推理。两者都需要谨慎使用：如果同步不紧密，很容易引入微妙的错误或意外的性能问题。
- en: A powerful alternative is immutable data sharing. Instead of protecting data
    with locks, you design your system so that shared data is never mutated after
    it's created. This minimizes contention and simplifies reasoning about your program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的替代方案是不可变数据共享。不是用锁来保护数据，而是设计你的系统，使得创建后的共享数据永远不会被修改。这最小化了竞争并简化了程序推理。
- en: Why Immutable Data?[¶](#why-immutable-data "Permanent link")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用不可变数据？[¶](#why-immutable-data "永久链接")
- en: 'Immutability brings several advantages to concurrent programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性为并发程序带来了几个优点：
- en: 'No locks needed: Multiple goroutines can safely read immutable data without
    synchronization.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需锁：多个 goroutine 可以安全地读取不可变数据，无需同步。
- en: 'Easier reasoning: If data can''t change, you avoid entire classes of race conditions.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易推理：如果数据不能改变，你可以避免整个类别的竞态条件。
- en: 'Copy-on-write optimizations: You can create new versions of a structure without
    altering the original, which is useful for config reloading or versioning a state.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写时复制优化：你可以创建结构的新版本而不改变原始版本，这对于配置重新加载或版本化状态很有用。
- en: 'Practical Example: Shared Config[¶](#practical-example-shared-config "Permanent
    link")'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例：共享配置[¶](#practical-example-shared-config "永久链接")
- en: Imagine you have a long-running service that periodically reloads its configuration
    from a disk or a remote source. Multiple goroutines read this configuration to
    make decisions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个长时间运行的服务，它定期从磁盘或远程源重新加载其配置。多个 goroutine 读取此配置以做出决策。
- en: 'Here''s how immutable data helps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不可变数据如何帮助的示例：
- en: 'Step 1: Define the Config Struct[¶](#step-1-define-the-config-struct "Permanent
    link")'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步：定义 Config 结构体[¶](#step-1-define-the-config-struct "永久链接")
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Step 2: Ensure Deep Immutability[¶](#step-2-ensure-deep-immutability "Permanent
    link")'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：确保深度不可变性[¶](#step-2-ensure-deep-immutability "永久链接")
- en: 'Maps and slices in Go are reference types. Even if the Config struct isn''t
    changed, someone could accidentally mutate a shared map. To prevent this, we make
    defensive copies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 Maps 和 Slices 是引用类型。即使 Config 结构体没有改变，有人也可能意外地修改共享的 Map。为了防止这种情况，我们创建防御性副本：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, every config instance is self-contained and safe to share.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个配置实例都是自包含的，可以安全地共享。
- en: 'Step 3: Atomic Swapping[¶](#step-3-atomic-swapping "Permanent link")'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：原子交换[¶](#step-3-atomic-swapping "永久链接")
- en: Use `atomic.Value` to store and safely update the current config.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `atomic.Value` 存储并安全地更新当前配置。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now all goroutines can safely call `GetConfig()` with no locks. When the config
    is reloaded, you just `Store` a new immutable copy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有 goroutine 都可以安全地调用 `GetConfig()` 而无需加锁。当配置重新加载时，只需 `Store` 一个新的不可变副本。
- en: 'Step 4: Using It in Handlers[¶](#step-4-using-it-in-handlers "Permanent link")'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：在处理器中使用它[¶](#step-4-using-it-in-handlers "永久链接")
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Practical Example: Immutable Routing Table[¶](#practical-example-immutable-routing-table
    "Permanent link")'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例：不可变路由表[¶](#practical-example-immutable-routing-table "永久链接")
- en: Suppose you're building a lightweight reverse proxy or API gateway and must
    route incoming requests based on path or host. The routing table is read thousands
    of times per second and updated only occasionally (e.g., from a config file or
    service discovery).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个轻量级的反向代理或 API 网关，必须根据路径或主机路由传入的请求。路由表每秒被读取数千次，但只偶尔更新（例如，从配置文件或服务发现）。
- en: 'Step 1: Define Route Structs[¶](#step-1-define-route-structs "Permanent link")'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步：定义路由结构体[¶](#step-1-define-route-structs "永久链接")
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Step 2: Build Immutable Version[¶](#step-2-build-immutable-version "Permanent
    link")'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：构建不可变版本[¶](#step-2-build-immutable-version "永久链接")
- en: To ensure immutability, we deep-copy the slice of routes when constructing a
    new routing table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保不可变性，我们在构建新的路由表时深度复制路由片段。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Step 3: Store It Atomically[¶](#step-3-store-it-atomically "Permanent link")'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：原子存储[¶](#step-3-store-it-atomically "永久链接")
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Step 4: Route Requests Concurrently[¶](#step-4-route-requests-concurrently
    "Permanent link")'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：并发路由请求[¶](#step-4-route-requests-concurrently "永久链接")
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, your routing logic can scale safely under load with zero locking overhead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的路由逻辑可以在负载下安全地扩展，且没有锁定开销。
- en: Scaling Immutable Routing Tables[¶](#scaling-immutable-routing-tables "Permanent
    link")
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展不可变路由表[¶](#scaling-immutable-routing-tables "永久链接")
- en: As systems grow, routing tables can expand to hundreds or even thousands of
    entries. While immutability brings clear benefits—safe concurrent access, predictable
    behavior—it becomes costly if every update means copying the entire structure.
    At some point, rebuilding the whole table for each minor change doesn’t scale.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的发展，路由表可以扩展到数百甚至数千个条目。虽然不可变性带来了明显的优势——安全并发访问、可预测的行为——但如果每次更新都意味着复制整个结构，这就会变得昂贵。在某个点上，为每个小变化重建整个表不再可扩展。
- en: To keep immutability without paying for full reconstruction on every update,
    the design needs to evolve. There are several ways to do this—each preserving
    the core benefits while reducing overhead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不每次更新时都支付完整重建的费用的情况下保持不可变性，设计需要进化。有几种方法可以实现这一点——每种方法都保留了核心优势，同时减少了开销。
- en: 'Scenario 1: Segmented Routing[¶](#scenario-1-segmented-routing "Permanent link")'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 1：分段路由[¶](#scenario-1-segmented-routing "永久链接")
- en: 'Imagine a multi-tenant system where each customer has their own set of routing
    rules. Instead of one giant slice of routes, you can split them into a map:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个多租户系统，其中每个客户都有自己的路由规则集。你不必有一个巨大的路由片段，可以将它们拆分为一个映射：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If only customer "acme" updates their rules, you clone just that slice and update
    the map. Then you atomically swap in a new version of the full map. All other
    tenants continue using their existing, untouched routing tables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有客户 "acme" 更新了他们的规则，你只需克隆那个片段并更新映射。然后你原子性地交换完整映射的新版本。所有其他租户继续使用他们现有的、未受影响的路由表。
- en: 'This approach reduces memory pressure and speeds up updates without losing
    immutability. It also isolates blast radius: a broken rule set in one segment
    doesn’t affect others.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法减少了内存压力，加快了更新速度，同时保持了不可变性。它还隔离了爆炸半径：一个段中的损坏规则集不会影响其他段。
- en: 'Scenario 2: Indexed Routing Table[¶](#scenario-2-indexed-routing-table "Permanent
    link")'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 2：索引路由表[¶](#scenario-2-indexed-routing-table "永久链接")
- en: 'Let’s say your router matches by exact path, and lookup speed is critical.
    You can use a `map[string]RouteHandler` as an index:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的路由器通过精确路径匹配，并且查找速度至关重要。你可以使用 `map[string]RouteHandler` 作为索引：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a new path is added, clone the current map, add the new route, and publish
    the new version. Because maps are shallow, this is fast for moderate numbers of
    routes. Reads are constant time, and updates are efficient because only a small
    part of the structure changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新路径时，克隆当前映射，添加新路由，并发布新版本。因为映射很浅，所以对于中等数量的路由来说，这很快。读取是常数时间，更新效率高，因为只有结构的一小部分发生变化。
- en: 'Scenario 3: Hybrid Staging and Publishing[¶](#scenario-3-hybrid-staging-and-publishing
    "Permanent link")'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景 3：混合预演和发布[¶](#scenario-3-hybrid-staging-and-publishing "永久链接")
- en: 'Suppose you’re doing a batch update — maybe reading hundreds of routes from
    a database. Instead of rebuilding live, you keep a mutable staging area:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在进行批量更新——可能从数据库中读取数百个路由。你不必重建实时数据，而是保持一个可变的预演区域：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You load and manipulate data in staging under a mutex, then convert to an immutable
    `RoutingTable` and store it atomically. This lets you safely prepare complex changes
    without locking readers or affecting live traffic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你在互斥锁下加载和操作数据，然后将其转换为不可变的 `RoutingTable` 并原子性地存储。这让你可以在不锁定读取者或影响实时流量的情况下安全地准备复杂更改。
- en: Benchmarking Impact[¶](#benchmarking-impact "Permanent link")
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响[¶](#benchmarking-impact "永久链接")
- en: Benchmarking immutable data sharing in real-world systems is difficult to do
    in a generic, meaningful way. Factors like structure size, read/write ratio, and
    memory layout all heavily influence results.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界系统中以通用、有意义的方式对不可变数据共享进行基准测试是困难的。结构大小、读写比和内存布局等因素都会严重影响结果。
- en: Rather than presenting artificial benchmarks here, we recommend reviewing the
    results in the [Atomic Operations and Synchronization Primitives](../atomic-ops/#benchmarking-impact)
    article. Those benchmarks clearly illustrate the potential performance benefits
    of using atomic.Value over traditional synchronization primitives like sync.RWMutex,
    especially in highly concurrent read scenarios.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在这里提供人工基准，我们建议回顾[原子操作和同步原语](../atomic-ops/#benchmarking-impact)文章中的结果。这些基准明确说明了使用atomic.Value而不是传统的同步原语（如sync.RWMutex）在高度并发读取场景中可能带来的性能优势。
- en: When to Use This Pattern[¶](#when-to-use-this-pattern "Permanent link")
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用此模式[¶](#when-to-use-this-pattern "永久链接")
- en: 'Immutable data sharing is ideal when:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况时，不可变数据共享是理想的：
- en: The data is read-heavy and write-light (e.g., configuration, feature flags,
    global mappings). This works well because the cost of creating new immutable versions
    is amortized over many reads, and avoiding locks provides a performance boost.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据读取密集而写入轻（例如，配置、功能标志、全局映射）。这效果很好，因为创建新不可变版本的成本被分摊到许多读取中，避免加锁提供了性能提升。
- en: You want to minimize locking without sacrificing safety. By sharing read-only
    data, you remove the need for mutexes or coordination, reducing the chances of
    deadlocks or race conditions.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望在不妨碍安全性的情况下最小化加锁。通过共享只读数据，你消除了对互斥锁或协调的需求，减少了死锁或竞态条件发生的可能性。
- en: You can tolerate minor delays between update and read (eventual consistency).
    Since data updates are not coordinated with readers, there might be a small delay
    before all goroutines see the new version. If exact timing isn't critical, this
    tradeoff simplifies your concurrency model.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以容忍更新和读取之间的轻微延迟（最终一致性）。由于数据更新没有与读取者协调，所有goroutines看到新版本之前可能会有短暂的延迟。如果精确时间不是关键，这种权衡可以简化你的并发模型。
- en: It’s less suitable when updates must be transactional across multiple pieces
    of data or happen frequently. In those cases, the cost of repeated copying or
    lack of coordination can outweigh the benefits.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新必须在多个数据项之间进行事务性操作或频繁发生时，则不太适用。在这些情况下，重复复制或缺乏协调的成本可能会超过其带来的好处。
