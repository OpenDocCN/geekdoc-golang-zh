["```\npackage main\n\ntype evictionAlgo interface {\n    evict(c *cache)\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype fifo struct {\n}\n\nfunc (l *fifo) evict(c *cache) {\n    fmt.Println(\"Evicting by fifo strtegy\")\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype lru struct {\n}\n\nfunc (l *lru) evict(c *cache) {\n    fmt.Println(\"Evicting by lru strtegy\")\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype lfu struct {\n}\n\nfunc (l *lfu) evict(c *cache) {\n    fmt.Println(\"Evicting by lfu strtegy\")\n}\n```", "```\npackage main\n\ntype cache struct {\n    storage      map[string]string\n    evictionAlgo evictionAlgo\n    capacity     int\n    maxCapacity  int\n}\n\nfunc initCache(e evictionAlgo) *cache {\n    storage := make(map[string]string)\n    return &cache{\n        storage:      storage,\n        evictionAlgo: e,\n        capacity:     0,\n        maxCapacity:  2,\n    }\n}\n\nfunc (c *cache) setEvictionAlgo(e evictionAlgo) {\n    c.evictionAlgo = e\n}\n\nfunc (c *cache) add(key, value string) {\n    if c.capacity == c.maxCapacity {\n        c.evict()\n    }\n    c.capacity++\n    c.storage[key] = value\n}\n\nfunc (c *cache) get(key string) {\n    delete(c.storage, key)\n}\n\nfunc (c *cache) evict() {\n    c.evictionAlgo.evict(c)\n    c.capacity--\n}\n```", "```\npackage main\n\nfunc main() {\n    lfu := &lfu{}\n    cache := initCache(lfu)\n    cache.add(\"a\", \"1\")\n    cache.add(\"b\", \"2\")\n    cache.add(\"c\", \"3\")\n    lru := &lru{}\n    cache.setEvictionAlgo(lru)\n    cache.add(\"d\", \"4\")\n    fifo := &fifo{}\n    cache.setEvictionAlgo(fifo)\n    cache.add(\"e\", \"5\")\n}\n```", "```\nEvicting by lfu strtegy\nEvicting by lru strtegy\nEvicting by fifo strtegy\n```"]