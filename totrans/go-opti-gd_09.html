<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Stack Allocations and Escape Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Stack Allocations and Escape Analysis</h1>
<blockquote>原文：<a href="https://goperf.dev/01-common-patterns/stack-alloc/">https://goperf.dev/01-common-patterns/stack-alloc/</a></blockquote>
                
                  


  
  



<p>When writing performance-critical Go applications, one of the subtle but significant optimizations you can make is encouraging values to be allocated on the stack rather than the heap. Stack allocations are cheaper, faster, and garbage-free—but Go doesn't always put your variables there automatically. That decision is made by the Go compiler during <strong>escape analysis</strong>.</p>
<p>In this article, we’ll explore what escape analysis is, how to read the compiler’s escape diagnostics, what causes values to escape, and how to structure your code to minimize unnecessary heap allocations. We'll also benchmark different scenarios to show the real-world impact.</p>
<h2 id="what-is-escape-analysis">What Is Escape Analysis?</h2>
<p>Escape analysis is a static analysis performed by the Go compiler to determine whether a variable can be safely allocated on the stack or if it must be moved ("escape") to the heap.</p>
<h3 id="why-does-it-matter">Why does it matter?</h3>
<ul>
<li><strong>Stack allocations</strong> are cheap: the memory is automatically freed when the function returns.</li>
<li><strong>Heap allocations</strong> are more expensive: they involve garbage collection overhead.</li>
</ul>
<p>The compiler decides where to place each variable based on how it's used. If a variable can be guaranteed to not outlive its declaring function, it can stay on the stack. If not, it escapes to the heap.</p>
<h3 id="example-stack-vs-heap">Example: Stack vs Heap</h3>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">allocate</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">x</span><span class="w"> </span><span class="c1">// x escapes to the heap</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">noEscape</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="c1">// x stays on the stack</span>
<span class="p">}</span>
</code></pre></div>
<p>In <code>allocate</code>, <code>x</code> is returned as a pointer. Since the pointer escapes the function, the Go compiler places <code>x</code> on the heap. In <code>noEscape</code>, <code>x</code> is a plain value and doesn’t escape.</p>
<h2 id="how-to-view-escape-analysis-output">How to View Escape Analysis Output</h2>
<p>You can inspect escape analysis with the <code>-gcflags</code> compiler option:</p>
<div class="highlight"><pre><span/><code>go<span class="w"> </span>build<span class="w"> </span>-gcflags<span class="o">=</span><span class="s2">"-m"</span><span class="w"> </span>./path/to/pkg
</code></pre></div>
<p>Or for a specific file:</p>
<div class="highlight"><pre><span/><code>go<span class="w"> </span>run<span class="w"> </span>-gcflags<span class="o">=</span><span class="s2">"-m"</span><span class="w"> </span>main.go
</code></pre></div>
<p>This will print lines like:</p>
<div class="highlight"><pre><span/><code>main.go:10:6: moved to heap: x
main.go:14:6: can inline noEscape
</code></pre></div>
<p>Look for messages like <code>moved to heap</code> to identify escape points.</p>
<h2 id="what-causes-variables-to-escape">What Causes Variables to Escape?</h2>
<p>Here are common scenarios that force heap allocation:</p>
<h3 id="returning-pointers-to-local-variables">Returning Pointers to Local Variables</h3>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">escape</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">10</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">x</span><span class="w"> </span><span class="c1">// escapes</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="capturing-variables-in-closures">Capturing Variables in Closures</h3>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">closureEscape</span><span class="p">()</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">5</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// x escapes</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="interface-conversions">Interface Conversions</h3>
<p>When a value is stored in an interface, it may escape:</p>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">toInterface</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="c1">// escapes if type info needed at runtime</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="assignments-to-global-variables-or-struct-fields">Assignments to Global Variables or Struct Fields</h3>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">global</span><span class="w"> </span><span class="o">*</span><span class="kt">int</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">assignGlobal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">7</span>
<span class="w">    </span><span class="nx">global</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">x</span><span class="w"> </span><span class="c1">// escapes</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="large-composite-literals">Large Composite Literals</h3>
<p>Go may allocate large structs or slices on the heap even if they don’t strictly escape.</p>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">makeLargeSlice</span><span class="p">()</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="c1">// may escape due to size</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">s</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="benchmarking-stack-vs-heap-allocations">Benchmarking Stack vs Heap Allocations</h2>
<p>Let’s run a benchmark to explore when heap allocations actually occur—and when they don’t, even if we return a pointer.</p>
<div class="highlight"><pre><span/><code><span class="kd">func</span><span class="w"> </span><span class="nx">StackAlloc</span><span class="p">()</span><span class="w"> </span><span class="nx">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">Data</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="c1">// stays on stack</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">HeapAlloc</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Data</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="c1">// escapes to heap</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkStackAlloc</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">Loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">StackAlloc</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkHeapAlloc</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">Loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">HeapAlloc</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Benchmark Results</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Iterations</th>
<th>Time per op (ns)</th>
<th>Bytes per op</th>
<th>Allocs per op</th>
</tr>
</thead>
<tbody>
<tr>
<td>BenchmarkStackAlloc-14</td>
<td>1,000,000,000</td>
<td>0.2604 ns</td>
<td>0 B</td>
<td>0</td>
</tr>
<tr>
<td>BenchmarkHeapAlloc-14</td>
<td>1,000,000,000</td>
<td>0.2692 ns</td>
<td>0 B</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>You might expect <code>HeapAlloc</code> to always allocate memory on the heap—but it doesn’t here. That’s because the compiler is smart: in this isolated benchmark, the pointer returned by <code>HeapAlloc</code> doesn’t escape the function in any meaningful way. The compiler can see it’s only used within the benchmark and short-lived, so it safely places it on the stack too.</p>
<h3 id="forcing-a-heap-allocation">Forcing a Heap Allocation</h3>
<div class="highlight"><pre><span/><code><span class="kd">var</span><span class="w"> </span><span class="nx">sink</span><span class="w"> </span><span class="o">*</span><span class="nx">Data</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">HeapAllocEscape</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Data</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span>
<span class="w">    </span><span class="nx">sink</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="c1">// d escapes to heap</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkHeapAllocEscape</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">Loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">HeapAllocEscape</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Iterations</th>
<th>Time per op (ns)</th>
<th>Bytes per op</th>
<th>Allocs per op</th>
</tr>
</thead>
<tbody>
<tr>
<td>BenchmarkHeapAllocEscape-14</td>
<td>331,469,049</td>
<td>10.55 ns</td>
<td>24 B</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>As shown in <code>BenchmarkHeapAllocEscape</code>, assigning the pointer to a global variable causes a real heap escape. This introduces real overhead: a 40x slower call, a 24-byte allocation, and one garbage-collected object per call.</p>
<details class="example">
<summary>Show the benchmark file</summary>
<div class="highlight"><pre><span/><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="s">"testing"</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Data</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">A</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="p">,</span><span class="w"> </span><span class="nx">C</span><span class="w"> </span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// heap-alloc-start</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">StackAlloc</span><span class="p">()</span><span class="w"> </span><span class="nx">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">Data</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="c1">// stays on stack</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">HeapAlloc</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">Data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Data</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="c1">// escapes to heap</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkStackAlloc</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">Loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">StackAlloc</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkHeapAlloc</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">Loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">_</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">HeapAlloc</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// heap-alloc-end</span>

<span class="c1">// escape-start</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sink</span><span class="w"> </span><span class="o">*</span><span class="nx">Data</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">HeapAllocEscape</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Data</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span>
<span class="w">    </span><span class="nx">sink</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="c1">// d escapes to heap</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkHeapAllocEscape</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">Loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">HeapAllocEscape</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// escape-end</span>
</code></pre></div>
</details>
<h2 id="when-to-optimize-for-stack-allocation">When to Optimize for Stack Allocation</h2>
<p>Not all escapes are worth preventing. Here’s when it makes sense to focus on stack allocation—and when it’s better to let values escape.</p>
<p><span class="twemoji"><svg viewbox="0 0 24 24"><path d="M20 12a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8c.76 0 1.5.11 2.2.31l1.57-1.57A9.8 9.8 0 0 0 12 2 10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10M7.91 10.08 6.5 11.5 11 16 21 6l-1.41-1.42L11 13.17z"/></svg></span> When to Avoid Escape</p>
<ul>
<li>In performance-critical paths. Reducing heap usage in tight loops or latency-sensitive code lowers GC pressure and speeds up execution.</li>
<li>For short-lived, small objects. These can be efficiently stack-allocated without involving the garbage collector, reducing memory churn.</li>
<li>When you control the full call chain. If the object stays within your code and you can restructure it to avoid escape, it’s often worth the small refactor.</li>
<li>If profiling reveals GC bottlenecks. Escape analysis helps you target and shrink memory-heavy allocations identified in real-world traces.</li>
</ul>
<p><span class="twemoji"><svg viewbox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M448 128H270.4c1 5.2 1.6 10.5 1.6 16v16h176c8.8 0 16-7.2 16-16s-7.2-16-16-16m-224 16c0-17.7-14.3-32-32-32h-24c-66.3 0-120 53.7-120 120v48c0 52.5 33.7 97.1 80.7 113.4-.5-3.1-.7-6.2-.7-9.4 0-20 9.2-37.9 23.6-49.7-4.9-9-7.6-19.4-7.6-30.3 0-15.1 5.3-29 14-40-8.8-11-14-24.9-14-40v-40c0-13.3 10.7-24 24-24s24 10.7 24 24v40c0 8.8 7.2 16 16 16s16-7.2 16-16zm-32-80c18 0 34.6 6 48 16h208c35.3 0 64 28.7 64 64s-28.7 64-64 64h-82c1.3 5.1 2 10.5 2 16 0 25.3-14.7 47.2-36 57.6 2.6 7 4 14.5 4 22.4 0 20-9.2 37.9-23.6 49.7 4.9 9 7.6 19.4 7.6 30.3 0 35.3-28.7 64-64 64h-88C75.2 448 0 372.8 0 280v-48C0 139.2 75.2 64 168 64zm64 336c8.8 0 16-7.2 16-16s-7.2-16-16-16h-64c-8.8 0-16 7.2-16 16s7.2 16 16 16zm16-176c0 5.5-.7 10.9-2 16h34c8.8 0 16-7.2 16-16s-7.2-16-16-16h-32zm-24 64h-40c-8.8 0-16 7.2-16 16s7.2 16 16 16h64c8.8 0 16-7.2 16-16s-7.2-16-16-16z"/></svg></span> When It’s Fine to Let Values Escape</p>
<ul>
<li>When returning values from constructors or factories. Returning a pointer from <code>NewThing()</code> is idiomatic Go—even if it causes an escape, it improves clarity and usability.</li>
<li>When objects must outlive the function. If you're storing data in a global, sending to a goroutine, or saving it in a struct, escaping is necessary and correct.</li>
<li>When allocation size is small and infrequent. If the heap allocation isn’t in a hot path, the benefit of avoiding it is often negligible.</li>
<li>When preventing escape hurts readability. Writing awkward code to keep everything on the stack can reduce maintainability for a micro-optimization that won’t matter.</li>
</ul>









  




                
                  
</body>
</html>