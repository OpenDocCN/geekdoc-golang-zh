- en: 'Optimizing TLS for Speed: Handshake, Reuse, and Cipher Choice'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 TLS 以提高速度：握手、重用和加密套件选择
- en: 原文：[https://goperf.dev/02-networking/tls-for-speed/](https://goperf.dev/02-networking/tls-for-speed/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/02-networking/tls-for-speed/](https://goperf.dev/02-networking/tls-for-speed/)
- en: 'TLS does what it’s supposed to: it keeps your connections private and trustworthy.
    But it also slows things down — a lot more than most people realize. In Go, if
    you care about how quickly your service responds, you can squeeze out better performance
    by tuning how TLS negotiates and what it negotiates.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 做了它应该做的事情：它保护你的连接私密且值得信赖。但这也减慢了速度——比大多数人意识到的要多得多。在 Go 语言中，如果你关心你的服务响应速度，你可以通过调整
    TLS 的协商方式和协商内容来提高性能。
- en: 'Understanding TLS Overhead: Where Performance Suffers'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 TLS 过度开销：性能受影响的区域
- en: 'Most of the slowdown in TLS happens right at the start. The handshake is a
    back-and-forth process: picking algorithms, swapping keys, proving identities,
    and setting up the session. That back-and-forth usually takes two full trips across
    the network. In something like a trading platform or a real-time app, that delay
    is noticeable.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 的大部分减速发生在开始阶段。握手是一个往返过程：选择算法、交换密钥、证明身份和设置会话。这种往返通常需要网络上的两次完整往返。在像交易平台或实时应用这样的场景中，这种延迟是明显的。
- en: To make TLS faster, the most effective place to start is cutting down the handshake
    steps and making the crypto work less expensive.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 TLS 更快，最有效的方法是减少握手步骤并使加密工作成本更低。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Session Resumption: Cutting Handshake Latency'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话恢复：减少握手延迟
- en: Because every new TLS connection runs the entire handshake — negotiating ciphers,
    exchanging keys, verifying certificates — it introduces noticeable latency. Session
    resumption sidesteps most of that by reusing the cryptographic state from an earlier
    session, making reconnects much faster.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个新的 TLS 连接都会运行完整的握手——协商加密套件、交换密钥、验证证书——它引入了明显的延迟。会话恢复通过重用早期会话的加密状态来规避大部分延迟，使重新连接变得更快。
- en: 'Session resumption is a mechanism in TLS to avoid repeating the full handshake
    on reconnect. There are two main approaches: session IDs and session tickets.
    Both rely on the idea that the server remembers (or encodes) the session’s cryptographic
    state from a prior connection. When a client reconnects, it presents either the
    session ID or the session ticket, allowing the server to restore the session state
    and skip expensive asymmetric key exchange.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 会话恢复是 TLS 中的一种机制，用于避免在重新连接时重复完整的握手过程。主要有两种方法：会话 ID 和会话票据。两者都依赖于服务器记住（或编码）从先前的连接中会话的加密状态。当客户端重新连接时，它会提供会话
    ID 或会话票据，允许服务器恢复会话状态并跳过昂贵的非对称密钥交换。
- en: A session ticket is a data blob issued by the server to the client at the end
    of the handshake. This ticket contains the encrypted session state (such as negotiated
    cipher suite, keys, and session parameters) and is opaque to the client. On reconnect,
    the client sends the ticket back, and the server decrypts it to resume the session
    without performing a full handshake.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 会话票据是服务器在握手结束时向客户端发出的数据块。此票据包含加密的会话状态（例如协商的加密套件、密钥和会话参数），对客户端来说是透明的。在重新连接时，客户端将票据发送回服务器，服务器将其解密以在无需进行完整握手的情况下恢复会话。
- en: In Go, you enable session resumption by setting up session ticket keys. The
    server uses these keys to encrypt and decrypt the session state that clients send
    back when resuming a connection. You can generate a secure 32‑byte key at startup
    with crypto/rand and reuse it if your service is running across multiple instances
    behind a load balancer. Just make sure to rotate the key now and then to keep
    it secure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，你可以通过设置会话票据密钥来启用会话恢复。服务器使用这些密钥来加密和解密客户端在恢复连接时发送回的会话状态。你可以在启动时使用 crypto/rand
    生成一个安全的 32 字节密钥，如果你的服务在负载均衡器后面的多个实例上运行，则可以重用它。只需确保定期更换密钥以保持其安全性。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What makes session resumption effective is that it avoids re‑doing the slowest
    parts of TLS. Instead of negotiating everything from scratch, the server decrypts
    the ticket, verifies it, and restores the session. That eliminates at least one
    full round trip and all the heavy asymmetric operations, which saves both time
    and resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 会话恢复之所以有效，是因为它避免了重新执行 TLS 中最慢的部分。服务器不是从头开始协商一切，而是解密票据、验证它并恢复会话。这至少消除了一个完整的往返和所有重型的非对称操作，从而节省了时间和资源。
- en: Choosing Cipher Suites Wisely
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聪明地选择加密套件
- en: Cipher suites define the combination of algorithms used for key exchange, authentication,
    encryption, and integrity checking. Selecting efficient cipher suites significantly
    impacts performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 加密套件定义了用于密钥交换、身份验证、加密和完整性检查的算法组合。选择高效的加密套件对性能有重大影响。
- en: Why prefer one over another? Some suites use RSA for key exchange, which is
    much slower than elliptic-curve Diffie–Hellman (ECDHE) and lacks forward secrecy.
    Suites with AES-GCM are faster on modern CPUs thanks to hardware acceleration,
    whereas older CBC-mode suites are slower and more error-prone. ECC-based authentication
    (ECDSA) also provides shorter signatures and lower computational cost compared
    to RSA.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择一个而不是另一个？一些套件使用 RSA 进行密钥交换，这比椭圆曲线 Diffie-Hellman (ECDHE) 慢得多，并且缺乏前向保密。具有
    AES-GCM 的套件在现代 CPU 上由于硬件加速而更快，而较旧的 CBC 模式套件较慢且更容易出错。基于 ECC 的身份验证（ECDSA）与 RSA 相比，提供更短的签名和更低的计算成本。
- en: 'To choose wisely:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明智地选择：
- en: Prioritize suites with ECDHE for forward secrecy and better performance.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择具有 ECDHE 的套件以实现前向保密和更好的性能。
- en: Prefer AES-GCM over AES-CBC or ChaCha20 unless targeting hardware that lacks
    AES acceleration (where ChaCha20 may win).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择 AES-GCM 而不是 AES-CBC 或 ChaCha20，除非目标是缺乏 AES 加速功能的硬件（在这种情况下 ChaCha20 可能更胜一筹）。
- en: Avoid suites using only RSA for key exchange, because they lack forward secrecy
    and require more expensive computations on the server side.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免仅使用 RSA 进行密钥交换的套件，因为它们缺乏前向保密，并且在服务器端需要更昂贵的计算。
- en: The Go standard library ships with a solid set of secure and reasonably fast
    defaults. For most applications, you can stick with those and be fine. But if
    you’re tuning for a high‑performance environment, defining your own preferred
    cipher suites gives you tighter control over what gets negotiated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的标准库提供了一套稳健的安全和合理快速的默认设置。对于大多数应用程序，你可以坚持使用这些设置，并且效果良好。但如果你正在为高性能环境进行调优，定义自己的首选加密套件可以让你更紧密地控制要协商的内容。
- en: An optimized config favors AES‑GCM for its hardware acceleration and ECC for
    its efficiency.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优化的配置优先选择 AES-GCM 以利用其硬件加速，并选择 ECC 以提高效率。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These suites strike a good balance between security and speed, leveraging forward
    secrecy and hardware-accelerated encryption. The second option, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
    is a reasonable choice when clients may not support ECDSA certificates — it still
    provides forward secrecy and efficient AES-GCM encryption while relying on the
    more widely deployed RSA for authentication.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些套件在安全性和速度之间取得了良好的平衡，利用了前向保密和硬件加速加密。第二个选项，TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256，当客户端可能不支持
    ECDSA 证书时是一个合理的选择——它仍然提供了前向保密和高效的 AES-GCM 加密，同时依赖于更广泛部署的 RSA 进行身份验证。
- en: Using ALPN Wisely
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ALPN 的明智之处
- en: Application-Layer Protocol Negotiation (ALPN) lets clients and servers agree
    upon the application protocol (like HTTP/2, HTTP/1.1, or gRPC) during the TLS
    handshake, avoiding additional round trips or guessing after establishing the
    connection. Without ALPN, a client would have to fall back to slower or less efficient
    methods to detect the server’s supported protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层协议协商 (ALPN) 允许客户端和服务器在 TLS 握手期间就应用协议（如 HTTP/2、HTTP/1.1 或 gRPC）达成一致，避免了在建立连接后的额外往返或猜测。没有
    ALPN，客户端将不得不回退到较慢或效率较低的方法来检测服务器支持协议。
- en: In Go, the `NextProtos` field in `tls.Config` defines which application protocols
    the server supports and in what order of preference. During the TLS handshake,
    the client sends its own list, and the server picks the highest‑priority protocol
    that both sides support, then confirms it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，`tls.Config` 中的 `NextProtos` 字段定义了服务器支持的应用协议及其优先顺序。在 TLS 握手过程中，客户端发送自己的列表，服务器选择双方都支持的最高优先级协议，然后确认它。
- en: 'If you want to support `HTTP/2` with a fallback to `HTTP/1.1`, you should set
    `NextProtos` explicitly, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要支持 `HTTP/2` 并回退到 `HTTP/1.1`，你应该显式设置 `NextProtos`，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The sequence of entries in `NextProtos` matters because the server walks the
    list in order and chooses the first protocol also offered by the client. By putting
    HTTP/2 (`h2`) at the top, the server ensures it prefers HTTP/2 when supported,
    falling back to HTTP/1.1 only when necessary. If the order is incorrect, the server
    may settle on a slower protocol or fail to agree entirely.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`NextProtos` 中条目的顺序很重要，因为服务器会按顺序遍历列表，并选择客户端也提供的第一个协议。通过将 HTTP/2 (`h2`) 放在顶部，服务器确保在支持的情况下优先选择
    HTTP/2，只有在必要时才回退到 HTTP/1.1。如果顺序不正确，服务器可能会选择一个较慢的协议，或者完全无法达成一致。'
- en: When `NextProtos` is left empty, ALPN is effectively disabled. The client assumes
    HTTP/1.1 because it never sees an indication of HTTP/2 support during the handshake.
    Explicitly setting `NextProtos` advertises the server’s capabilities and avoids
    unnecessary protocol downgrades.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当`NextProtos`留空时，ALPN实际上被禁用。客户端假设HTTP/1.1，因为它在握手过程中从未看到对HTTP/2支持的任何指示。显式设置`NextProtos`可以宣传服务器的能力，并避免不必要的协议降级。
- en: Minimizing Certificate Verification Overhead
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化证书验证开销
- en: 'Certificate verification tends to be CPU‑heavy because it involves several
    expensive asymmetric cryptographic operations, which directly increase connection
    latency. This cost can be reduced in two ways: by using smaller, faster‑to‑verify
    ECC‑based (ECDSA) certificates instead of RSA, and by caching already‑validated
    certificate chains to avoid repeating the same verification work on subsequent
    connections.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 证书验证通常很耗时，因为它涉及几个昂贵的非对称加密操作，这直接增加了连接延迟。这种成本可以通过两种方式降低：使用更小、验证速度更快的基于ECC（ECDSA）证书而不是RSA，以及通过缓存已验证的证书链以避免在后续连接中重复相同的验证工作。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A basic caching mechanism stores verification outcomes temporarily:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的缓存机制临时存储验证结果：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: While the snippet illustrates key concepts, it should not be used in production
    as-is. Cryptographic code demands careful analysis and adaptation to the specific
    environment and threat model. Always validate and test security-related code before
    deployment to avoid introducing weaknesses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该片段说明了关键概念，但不应直接在生产环境中使用。加密代码需要仔细分析和适应特定环境和威胁模型。在部署前始终验证和测试与安全相关的代码，以避免引入弱点。
- en: TLS Best Practices in Go
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go中的TLS最佳实践
- en: The following configuration brings together these techniques into a tls.Config
    that is optimized for both performance and security.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置将这些技术结合在一起，形成一个针对性能和安全都进行了优化的tls.Config。
- en: The `MinVersion` setting tells the server to reject older, broken versions of
    TLS. Anything below TLS 1.2 — like SSLv3, TLS 1.0, or 1.1 — is riddled with weaknesses
    and no longer considered safe. TLS 1.2 fixed many of those problems by introducing
    AEAD ciphers like AES‑GCM and defenses against attacks such as BEAST and POODLE.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`MinVersion`设置告诉服务器拒绝较旧、有缺陷的TLS版本。低于TLS 1.2的任何内容——如SSLv3、TLS 1.0或1.1——都存在许多弱点，不再被认为是安全的。TLS
    1.2通过引入AEAD加密（如AES-GCM）和针对BEAST和POODLE等攻击的防御措施，解决了许多这些问题。'
- en: The `CurvePreferences` field prioritizes fast and secure elliptic curves supported
    by most clients. P-256 and X25519 are efficient, widely-supported, and often hardware-accelerated.
    P-256 (also known as secp256r1) is an NIST-recommended curve with broad compatibility
    and native support in most CPUs for fast computation. X25519 is a modern curve
    designed for both speed and simplicity, offering constant-time operations to resist
    side-channel attacks, and performs especially well on low-power or embedded devices.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurvePreferences`字段优先考虑大多数客户端支持的快速且安全的椭圆曲线。P-256和X25519效率高、支持广泛，并且通常在硬件上加速。P-256（也称为secp256r1）是一个NIST推荐的曲线，具有广泛的兼容性，并在大多数CPU中提供原生支持，以实现快速计算。X25519是一个为速度和简单性而设计的现代曲线，提供恒定时间的操作以抵抗侧信道攻击，并在低功耗或嵌入式设备上表现特别出色。'
- en: Te rest parts were discussed in details above.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分已在上面详细讨论。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: TLS optimization is about balancing performance and security effectively. By
    reducing handshake overhead through session reuse, wisely selecting cipher suites
    with ECC and hardware acceleration, efficiently leveraging ALPN, and minimizing
    certificate verification overhead through caching, Go applications can achieve
    both security and speed. This approach makes TLS less a performance bottleneck
    and more a seamless security foundation for modern network services.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TLS优化是关于有效平衡性能和安全的。通过通过会话重用减少握手开销，明智地选择带有ECC和硬件加速的加密套件，高效利用ALPN，以及通过缓存最小化证书验证开销，Go应用程序可以实现安全性和速度的双重目标。这种方法使TLS不再是性能瓶颈，而是现代网络服务的无缝安全基础。
