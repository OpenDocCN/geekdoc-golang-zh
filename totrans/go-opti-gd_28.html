<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>QUIC in Go: Building Low-Latency Services with quic-go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>QUIC in Go: Building Low-Latency Services with quic-go</h1>
<blockquote>原文：<a href="https://goperf.dev/02-networking/quic-in-go/">https://goperf.dev/02-networking/quic-in-go/</a></blockquote>
                
                  


  
  



<p>QUIC has emerged as a robust protocol, solving many inherent limitations of traditional TCP connections. QUIC combines encryption, multiplexing, and connection migration into a unified protocol, designed to optimize web performance, particularly in real-time and mobile-first applications. In Go, <a href="https://github.com/quic-go/quic-go">quic-go</a> is the main QUIC implementation and serves as a practical base for building efficient, low-latency network services with built-in encryption and stream multiplexing.</p>
<h2 id="understanding-quic">Understanding QUIC</h2>
<p>Originally developed at Google and later standardized by the IETF, QUIC rethinks the transport layer to overcome longstanding TCP limitations:</p>
<ul>
<li><strong>Head-of-line blocking:</strong> TCP delivers a single ordered byte stream, so packet loss stalls everything behind it. QUIC splits data into independent streams, allowing others to proceed even when one is delayed.</li>
<li><strong>Per-packet encryption and header protection:</strong> QUIC applies encryption at the packet level, including selective header protection tied to packet numbers—something DTLS’s record-based framing can’t support.</li>
<li><strong>Built-in transport mechanisms:</strong> QUIC handles stream multiplexing, flow control, and retransmissions as part of the protocol. DTLS, by contrast, only secures datagrams and leaves reliability and ordering to the application.</li>
<li><strong>Connection ID abstraction:</strong> QUIC identifies sessions using connection IDs rather than IP and port tuples, allowing connections to persist across network changes. DTLS provides no such abstraction, making mobility difficult to implement.</li>
</ul>
<h3 id="quic-vs-tcp-key-differences">QUIC vs. TCP: Key Differences</h3>
<p>QUIC takes a fundamentally different approach from TCP. While TCP is built directly on IP and requires a connection-oriented handshake before data can flow, QUIC runs over UDP and handles its own connection logic, reducing setup overhead and improving startup latency. This architectural choice allows QUIC to provide multiplexed, independent streams that effectively eliminate the head-of-line blocking issue commonly experienced with TCP, where the delay or loss of one packet stalls subsequent packets.</p>
<p>QUIC integrates TLS 1.3 directly into its transport layer, eliminating the layered negotiation seen in TCP+TLS. This design streamlines the handshake process and enables 0-RTT data, where repeat connections can begin transmitting encrypted payloads immediately—something TCP simply doesn’t support.</p>
<p>Another key distinction is how connections are identified. TCP connections are bound to a specific IP and port, so any change in network interface results in a broken connection. QUIC avoids this by using connection IDs that remain stable across address changes, allowing sessions to continue uninterrupted when a device moves between networks—critical for mobile and latency-sensitive use cases.</p>
<h2 id="is-quic-based-on-dtls">Is QUIC Based on DTLS?</h2>
<p>Although QUIC and DTLS both use TLS cryptographic primitives over UDP, QUIC does <em>not</em> build on DTLS. Instead, QUIC incorporates <strong>TLS 1.3 directly into its transport layer</strong>, inheriting only the cryptographic handshake—not the record framing or protocol structure of DTLS.</p>
<p>QUIC defines its own packet encoding, multiplexing, retransmission, and encryption formats. It wraps TLS handshake messages within QUIC packets and tightly couples encryption state with transport features like packet numbers and stream IDs. In contrast, DTLS operates as a secured datagram layer atop UDP, providing encryption and authentication but leaving transport semantics—such as retransmit, ordering, or flow control—to higher layers.</p>
<p>The reasons for QUIC rejecting DTLS as its security base include:</p>
<ul>
<li><strong>Tighter integration of handshake and transport</strong>: QUIC merges TLS negotiation with transport state setup, enabling 0‑RTT reuse and 1‑RTT setup in fewer round trips. DTLS’s layered model introduces higher latency.</li>
<li><strong>Fine-grained encryption control</strong>: QUIC encrypts packet headers and payloads per-packet, bound to packet number and header offset. This is impossible with DTLS’s coarse record layer.</li>
<li><strong>Native transport features</strong>: QUIC implements multiplexed, independent streams, per-stream flow control, and resilient retransmission logic. DTLS treats reliability and ordering as the application's responsibility.</li>
<li><strong>Connection migration capability</strong>: QUIC uses connection IDs decoupled from IP/port endpoints, enabling smooth network-interface switches. DTLS lacks this architectural property.</li>
</ul>
<p>In summary, QUIC uses TLS 1.3 for cryptographic handshake but <strong>eschews DTLS entirely</strong>, replacing it with a tightly integrated transport protocol. This design empowers QUIC to offer secure, low-latency, multiplexed, and mobile-friendly connections that DTLS—optimized for secure datagram channels—cannot match.</p>
<h2 id="introducing-quic-go">Introducing quic-go</h2>
<p>quic-go implements the core IETF QUIC specification and supports most features required for production use, including TLS 1.3 integration, 0-RTT, stream multiplexing, and flow control. While some advanced capabilities like active connection migration are not yet implemented.</p>
<h3 id="getting-started-with-quic-go">Getting Started with quic-go</h3>
<p>To start using <code>quic-go</code>, include it via Go modules:</p>
<div class="highlight"><pre><span/><code>go<span class="w"> </span>get<span class="w"> </span>github.com/quic-go/quic-go
</code></pre></div>
<h3 id="basic-quic-server">Basic QUIC Server</h3>
<p>A basic QUIC server setup in Go is conceptually similar to writing a traditional TCP server using the <code>net</code> package, but with several important distinctions.</p>
<p>The initialization phase still involves listening on an address, but uses <code>quic.ListenAddr()</code> instead of <code>net.Listen()</code>. Unlike TCP, QUIC operates over UDP and requires a TLS configuration from the start, as all QUIC connections are encrypted by design. There’s no need to manually wrap connections in TLS—QUIC handles encryption as part of the protocol.</p>
<div class="highlight"><pre><span/><code><span class="w">    </span><span class="nx">listener</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">ListenAddr</span><span class="p">(</span><span class="s">"localhost:4242"</span><span class="p">,</span><span class="w"> </span><span class="nx">generateTLSConfig</span><span class="p">(),</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"QUIC server listening on localhost:4242"</span><span class="p">)</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">conn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">listener</span><span class="p">.</span><span class="nx">Accept</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"Accept error:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="nx">handleConn</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>After accepting a connection, handling diverges more significantly from the traditional <code>net.Conn</code> model. A single QUIC connection supports multiple independent streams, each functioning like a lightweight, ordered, bidirectional byte stream. These are accepted and handled independently, allowing concurrent interactions over a single connection without head-of-line blocking.</p>
<div class="highlight"><pre><span/><code><span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">conn</span><span class="p">.</span><span class="nx">CloseWithError</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">"bye"</span><span class="p">)</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">stream</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">conn</span><span class="p">.</span><span class="nx">AcceptStream</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">Stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">defer</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>

<span class="w">            </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadAll</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">log</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">"Received: %s"</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">appErr</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">quic</span><span class="p">.</span><span class="nx">ApplicationError</span><span class="p">);</span><span class="w"> </span><span class="p">!</span><span class="nx">ok</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">appErr</span><span class="p">.</span><span class="nx">ErrorCode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"read error:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}(</span><span class="nx">stream</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>This separation of initialization and per-stream handling is one of QUIC's most powerful features. With TCP, one connection equals one stream. With QUIC, one connection can carry dozens of concurrent, fully independent streams with isolated flow control and recovery behavior, allowing high-efficiency communication patterns with minimal latency.</p>
<h2 id="multiplexed-streams">Multiplexed Streams</h2>
<p>QUIC inherently supports stream multiplexing, enabling simultaneous bidirectional communication without additional connection overhead. Streams operate independently, preventing head-of-line blocking, thus enhancing throughput and reducing latency.</p>
<div class="highlight"><pre><span/><code><span class="nx">stream</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">session</span><span class="p">.</span><span class="nx">OpenStreamSync</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span>
<span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">stream</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">"Hello QUIC!"</span><span class="p">))</span>
</code></pre></div>
<h2 id="performance-quic-vs-http2-and-tcp">Performance: QUIC vs. HTTP/2 and TCP</h2>
<p>In performance benchmarks, QUIC frequently outperforms traditional HTTP/2 over TCP, particularly on lossy networks common in mobile environments. QUIC recovers faster from packet loss due to multiplexed streams and built-in congestion control algorithms like Cubic and BBR, integrated directly into the quic-go library.</p>
<h2 id="connection-migration">Connection Migration</h2>
<p class="annotate">One significant advantage of the QUIC protocol is its support for seamless connection migration(1), designed to allow mobile devices to maintain connections while switching networks (e.g., from Wi-Fi to cellular). This is enabled by connection IDs, which abstract away the client's IP address and port, allowing the server to continue communication even if the client's network path changes.</p>
<ol>
<li>See <a href="https://datatracker.ietf.org/doc/html/rfc9000?section-9.2#name-initiating-connection-migra">9.2. Initiating Connection Migration</a> and <a href="https://datatracker.ietf.org/doc/html/rfc9000?section-9.2#name-responding-to-connection-mi">9.3. Responding to Connection Migration</a> sections from <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>.</li>
</ol>
<p>However, in practice, connection migration depends on the specific implementation. In quic-go (as of v0.52.0), full active migration is not yet implemented. Here's what is supported:</p>
<ul>
<li><strong>NAT rebinding works:</strong> If a client's IP or port changes due to NAT behavior or DHCP renewal, and the same connection ID is used, quic-go will continue the session without requiring a new connection. This is passive migration and requires no explicit action from the client.</li>
<li><strong>Interface switching (active migration) is not supported:</strong> Switching network interfaces—such as moving from Wi-Fi to LTE—requires sending packets from a new path and validating it with PATH_CHALLENGE and PATH_RESPONSE frames. The protocol defines this behavior, but quic-go does not implement it.</li>
</ul>
<h2 id="resilience-in-practice">Resilience in Practice</h2>
<p>QUIC is particularly effective in networks where reliability is difficult to guarantee—mobile clients on LTE, IoT nodes on lossy links, or any edge system moving between access points. Rather than relying on techniques like forward error correction (dropped during IETF standardization), QUIC builds resilience into the core transport through a combination of stream isolation, fine-grained recovery, and flexible routing.</p>
<p>QUIC connections are multiplexed: each stream runs independently with a separate flow control and delivery state. Packet loss on one stream doesn’t interfere with others, avoiding the head-of-line blocking inherent in TCP. This alone gives QUIC a noticeable advantage in throughput on degraded links.</p>
<p>Loss recovery in QUIC is driven by packet-level acknowledgments and RTT-based timers—no reliance on TCP-style retransmission logic. Lost packets are detected faster, and retransmissions are scoped to the specific frames involved.</p>
<pre class="mermaid"><code>sequenceDiagram
    participant Client
    participant Server

    Note over Client, Server: RTT = 100ms

    Client-&gt;&gt;Server: Packet #1 (STREAM)
    Client-&gt;&gt;Server: Packet #2 (STREAM)
    Client--xServer: Packet #3 (lost)
    Client-&gt;&gt;Server: Packet #4 (STREAM)

    Note over Server: Server receives #1, #2, #4 (but not #3)

    Server--&gt;&gt;Client: ACK [1-2, 4] after 100ms

    Note over Client: Missing #3 is inferred lost\nonce #4 is ACKed before it

    Client-&gt;&gt;Server: Packet #5 (Retransmit lost frame from #3)
    Server--&gt;&gt;Client: ACK [5]</code></pre>
<h3 id="how-quic-acks-differ-from-tcp">How QUIC ACKs Differ from TCP</h3>
<p>While TCP includes support for SACK (Selective Acknowledgment), there are critical distinctions that make QUIC’s loss recovery more robust and deterministic:</p>
<ul>
<li><strong>SACK in TCP is optional</strong> and negotiated during handshake. QUIC’s ACK ranges are always enabled and part of the core protocol.</li>
<li><strong>TCP acknowledges bytes</strong>, while QUIC acknowledges whole packets by number.</li>
<li><strong>Retransmissions in TCP</strong> are often byte-specific and tied to stream position. In QUIC, entire packets are retransmitted.</li>
<li><strong>QUIC ACKs are encrypted</strong>, making them tamper-resistant and resilient to on-path interference.</li>
</ul>
<table>
<thead>
<tr>
<th>Feature</th>
<th>TCP</th>
<th>QUIC</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACK granularity</td>
<td>Byte-level</td>
<td>Packet-level</td>
</tr>
<tr>
<td>ACK range support</td>
<td>Optional (via SACK)</td>
<td>Mandatory</td>
</tr>
<tr>
<td>Loss detection</td>
<td>Duplicate ACKs, timers</td>
<td>Gaps + RTT-based timers</td>
</tr>
<tr>
<td>Retransmission granularity</td>
<td>Partial stream bytes</td>
<td>Full packet</td>
</tr>
<tr>
<td>Encryption of ACKs</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h3 id="connection-migration-and-middlebox-resilience">Connection Migration and Middlebox Resilience</h3>
<p>When a device moves between networks (e.g., Wi-Fi to LTE), QUIC's use of connection IDs allows it to maintain continuity. Connections aren't bound to IP-port pairs and don’t require a full reconnect. Although <code>quic-go</code> doesn’t yet support active migration, passive rebinding already works in practice.</p>
<p>Because QUIC encrypts its transport metadata, it’s also more robust against middlebox interference. Encrypted packet numbers, ACKs, and control frames reduce the risk of unintended behavior by on-path devices, which can degrade TCP performance.</p>
<h3 id="congestion-control-flexibility">Congestion Control Flexibility</h3>
<p>Finally, QUIC enables pluggable congestion control. The protocol doesn’t prescribe one algorithm—BBR, Cubic, and custom logic are all possible at the application layer. This allows fine-tuning behavior for different latency and throughput tradeoffs.</p>
<h2 id="0-rtt-connections">0-RTT Connections</h2>
<p class="annotate">QUIC supports 0-RTT handshakes, allowing clients to send application data during the initial handshake on repeat connections. This reduces startup latency significantly. However, because 0-RTT data can be replayed by an attacker, it must be used carefully—typically limited to idempotent operations and trusted clients.</p>
<ol>
<li>A replay attack occurs when an attacker captures valid network data—such as a request or handshake—and maliciously retransmits it to trick the server into executing it again. In the context of 0-RTT, since early data is sent before the handshake completes, it can be replayed by an adversary on a different connection, potentially causing duplicated actions (like double-purchasing or unauthorized state changes). This is why 0-RTT data must be idempotent or explicitly protected against replay.</li>
</ol>
<div class="highlight"><pre><span/><code><span class="w">    </span><span class="nx">earlyConn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">DialAddrEarly</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">(),</span><span class="w"> </span><span class="s">"localhost:4242"</span><span class="p">,</span><span class="w"> </span><span class="nx">tlsConf</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
</code></pre></div>
<p>0-RTT is particularly beneficial for latency-sensitive applications like gaming, VoIP, and real-time financial data feeds.</p>
<details class="example">
<summary>Show the complete 0-RTT Server/Client examples</summary>
<details class="example">
<summary>0-RTT Server</summary>
<div class="highlight"><pre><span/><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"context"</span>
<span class="w">    </span><span class="s">"crypto/tls"</span>
<span class="w">    </span><span class="s">"log"</span>
<span class="w">    </span><span class="s">"time"</span>

<span class="w">    </span><span class="s">"github.com/quic-go/quic-go"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sessionCache</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tls</span><span class="p">.</span><span class="nx">NewLRUClientSessionCache</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="w">    </span><span class="nx">tlsConf</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">        </span><span class="nx">InsecureSkipVerify</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nx">EnableActiveMigration</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nx">ClientSessionCache</span><span class="p">:</span><span class="w"> </span><span class="nx">sessionCache</span><span class="p">,</span>
<span class="w">        </span><span class="nx">NextProtos</span><span class="p">:</span><span class="w">         </span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"quic-0rtt-example"</span><span class="p">},</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 1. Establish initial connection for session priming</span>
<span class="w">    </span><span class="nx">conn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">DialAddr</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">(),</span><span class="w"> </span><span class="s">"localhost:4242"</span><span class="p">,</span><span class="w"> </span><span class="nx">tlsConf</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">conn</span><span class="p">.</span><span class="nx">CloseWithError</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">"primed"</span><span class="p">)</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">500</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// 2. 0-RTT connection</span>
<span class="w">    </span><span class="c1">// DialAddrEarly-start</span>
<span class="w">    </span><span class="nx">earlyConn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">DialAddrEarly</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">(),</span><span class="w"> </span><span class="s">"localhost:4242"</span><span class="p">,</span><span class="w"> </span><span class="nx">tlsConf</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// DialAddrEarly-end</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">"0-RTT failed:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">stream</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">earlyConn</span><span class="p">.</span><span class="nx">OpenStreamSync</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">"stream open failed:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">message</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">"Hello over 0-RTT"</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stream</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">"write failed:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Wait briefly to ensure data is sent before closing</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">200</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

<span class="w">    </span><span class="nx">stream</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="w">    </span><span class="nx">earlyConn</span><span class="p">.</span><span class="nx">CloseWithError</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">"done"</span><span class="p">)</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"0-RTT client sent:"</span><span class="p">,</span><span class="w"> </span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
</details>
<details class="example">
<summary>0-RTT Client</summary>
<div class="highlight"><pre><span/><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">"context"</span>
<span class="w">    </span><span class="s">"crypto/tls"</span>
<span class="w">    </span><span class="s">"log"</span>
<span class="w">    </span><span class="s">"time"</span>

<span class="w">    </span><span class="s">"github.com/quic-go/quic-go"</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sessionCache</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">tls</span><span class="p">.</span><span class="nx">NewLRUClientSessionCache</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="w">    </span><span class="nx">tlsConf</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">        </span><span class="nx">InsecureSkipVerify</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nx">EnableActiveMigration</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">        </span><span class="nx">ClientSessionCache</span><span class="p">:</span><span class="w"> </span><span class="nx">sessionCache</span><span class="p">,</span>
<span class="w">        </span><span class="nx">NextProtos</span><span class="p">:</span><span class="w">         </span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"quic-0rtt-example"</span><span class="p">},</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 1. Establish initial connection for session priming</span>
<span class="w">    </span><span class="nx">conn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">DialAddr</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">(),</span><span class="w"> </span><span class="s">"localhost:4242"</span><span class="p">,</span><span class="w"> </span><span class="nx">tlsConf</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">conn</span><span class="p">.</span><span class="nx">CloseWithError</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">"primed"</span><span class="p">)</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">500</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// 2. 0-RTT connection</span>
<span class="w">    </span><span class="c1">// DialAddrEarly-start</span>
<span class="w">    </span><span class="nx">earlyConn</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">quic</span><span class="p">.</span><span class="nx">DialAddrEarly</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">(),</span><span class="w"> </span><span class="s">"localhost:4242"</span><span class="p">,</span><span class="w"> </span><span class="nx">tlsConf</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// DialAddrEarly-end</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">"0-RTT failed:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">stream</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">earlyConn</span><span class="p">.</span><span class="nx">OpenStreamSync</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Background</span><span class="p">())</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">"stream open failed:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">message</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">"Hello over 0-RTT"</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">stream</span><span class="p">.</span><span class="nx">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">"write failed:"</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Wait briefly to ensure data is sent before closing</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">200</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

<span class="w">    </span><span class="nx">stream</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
<span class="w">    </span><span class="nx">earlyConn</span><span class="p">.</span><span class="nx">CloseWithError</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">"done"</span><span class="p">)</span>
<span class="w">    </span><span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">"0-RTT client sent:"</span><span class="p">,</span><span class="w"> </span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
</details>
<p><strong>Expected Output</strong></p>
<p>When the server is started and the client is executed immediately afterward, you should see:</p>
<p><strong><em>Server Console</em></strong>
</p><div class="highlight"><pre><span/><code>QUIC server listening on localhost:4242
2025/06/23 16:33:00 Received: Hello over 0-RTT
</code></pre></div><p/>
<p><strong><em>Client Console</em></strong>
</p><div class="highlight"><pre><span/><code>0-RTT client sent: Hello over 0-RTT
</code></pre></div><p/>
</details>
<p>This confirms that early data was transmitted and accepted during the 0-RTT phase of a resumed session, without waiting for the full handshake to complete.</p>
<h2 id="final-thoughts-on-quic-with-go">Final Thoughts on QUIC with Go</h2>
<p>QUIC is a transformative protocol with significant design advantages over TCP and HTTP/2, especially in the context of mobile-first and real-time systems. Its ability to multiplex streams without head-of-line blocking, reduce handshake latency through 0-RTT, and recover gracefully from packet loss makes it particularly effective in environments with unstable connectivity—such as LTE, Wi-Fi roaming, or satellite uplinks.</p>
<p>While the Go ecosystem benefits from quic-go as a mature userspace implementation, it's important to understand current limitations. Most notably, quic-go does not yet support full active connection migration as described in <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>. Although it handles NAT rebinding passively—maintaining sessions across address changes within the same network—it lacks path validation and interface-switching logic required for full multi-homing or roaming support.</p>
<p>In parallel, a Linux kernel implementation of QUIC is under active development, aiming to provide native support for the protocol alongside TCP and UDP. This effort, <a href="https://lwn.net/ml/all/cover.1725935420.git.lucien.xin@gmail.com/">led by Lucien Xin</a>, proposes a complete QUIC stack inside the kernel, including kTLS integration and socket-based API compatibility. If adopted, this would unlock new performance ceilings for QUIC under high load, bypassing userspace copy overhead and reducing syscall costs for data plane operations.</p>
<p>In short, QUIC’s architecture is well-positioned to outperform legacy transports—especially in variable network conditions. While quic-go already enables many of these benefits, it’s worth keeping in mind what’s implemented today vs. what’s defined by the spec. As ecosystem support deepens—from kernel integration to advanced path management—QUIC’s full potential will become more accessible to systems operating at the edge of latency, reliability, and mobility.</p>
<p>Using QUIC via the quic-go library gives developers access to a transport layer designed for modern network demands. Its built-in stream multiplexing, fast connection setup with 0-RTT, and ability to handle network path changes make it a strong fit for real-time systems and mobile applications where latency and reliability are critical.</p>









  




                
                  
</body>
</html>