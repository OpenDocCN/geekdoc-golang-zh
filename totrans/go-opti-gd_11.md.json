["```go\n`var  requests  atomic.Int64  func  handleRequest()  {   requests.Add(1) }` \n```", "```go\n`var  shutdown  atomic.Int32  func  mainLoop()  {   for  {   if  shutdown.Load()  ==  1  {   break   }   // do work   } }  func  stop()  {   shutdown.Store(1) }` \n```", "```go\n`import  (   \"runtime\"   \"sync/atomic\"   \"unsafe\" )  var  resource  unsafe.Pointer var  initStatus  int32  // 0: not started, 1: in progress, 2: completed  func  getResource()  *MyResource  {   if  atomic.LoadInt32(&initStatus)  ==  2  {   return  (*MyResource)(atomic.LoadPointer(&resource))   }    if  atomic.CompareAndSwapInt32(&initStatus,  0,  1)  {   newRes  :=  expensiveInit()  // initialization logic   atomic.StorePointer(&resource,  unsafe.Pointer(newRes))   atomic.StoreInt32(&initStatus,  2)   return  newRes   }    for  atomic.LoadInt32(&initStatus)  !=  2  {   runtime.Gosched()  // yield until the initializer finishes   }   return  (*MyResource)(atomic.LoadPointer(&resource)) }` \n```", "```go\n`type  node  struct  {   next  *node   val  any }  var  head  atomic.Pointer[node]  func  push(n  *node)  {   for  {   old  :=  head.Load()   n.next  =  old   if  head.CompareAndSwap(old,  n)  {   return   }   } }` \n```", "```go\n`if  atomic.LoadInt32(&someFlag)  ==  0  {   return } mu.Lock() defer  mu.Unlock() // do something heavy` \n```", "```go\n`if  !atomic.CompareAndSwapInt32(&someFlag,  0,  1)  {   return  // work already in progress or completed } mu.Lock() defer  mu.Unlock() // perform one-time expensive initialization` \n```", "```go\n`func  BenchmarkAtomicIncrement(b  *testing.B)  {   var  counter  int64   b.RunParallel(func(pb  *testing.PB)  {   for  pb.Next()  {   atomic.AddInt64(&counter,  1)   }   }) }  func  BenchmarkMutexIncrement(b  *testing.B)  {   var  (   counter  int64   mu  sync.Mutex   )   b.RunParallel(func(pb  *testing.PB)  {   for  pb.Next()  {   mu.Lock()   counter++   mu.Unlock()   }   }) }` \n```", "```go\n`package  perf  import  (   \"testing\"   \"sync/atomic\"   \"sync\" )  // bench-start func  BenchmarkAtomicIncrement(b  *testing.B)  {   var  counter  int64   b.RunParallel(func(pb  *testing.PB)  {   for  pb.Next()  {   atomic.AddInt64(&counter,  1)   }   }) }  func  BenchmarkMutexIncrement(b  *testing.B)  {   var  (   counter  int64   mu  sync.Mutex   )   b.RunParallel(func(pb  *testing.PB)  {   for  pb.Next()  {   mu.Lock()   counter++   mu.Unlock()   }   }) } // bench-end` \n```"]