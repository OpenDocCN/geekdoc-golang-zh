- en: Benchmarking and Load Testing for Networked Go Apps¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络Go应用的基准测试和负载测试
- en: 原文：[https://goperf.dev/02-networking/bench-and-load/](https://goperf.dev/02-networking/bench-and-load/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/02-networking/bench-and-load/](https://goperf.dev/02-networking/bench-and-load/)
- en: Before you reach for a mutex-free queue or tune your goroutine pool, step back.
    Optimization without a baseline is just guesswork. In Go applications, performance
    tuning starts with understanding how your system behaves under pressure, which
    means benchmarking it under load.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在您伸手去使用无锁队列或调整goroutine池之前，退后一步。没有基线的优化只是猜测。在Go应用程序中，性能调整始于了解系统在压力下的行为，这意味着在负载下对其进行基准测试。
- en: Load testing isn't just about pushing requests until things break. It's about
    simulating realistic usage patterns to extract measurable, repeatable data. That
    data anchors every optimization that follows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试不仅仅是不断发送请求直到系统崩溃。它是模拟现实使用模式以提取可测量、可重复的数据。这些数据是后续每个优化的基础。
- en: 'Test App: Simulating Fast/Slow Paths and GC pressure[¶](#test-app-simulating-fastslow-paths-and-gc-pressure
    "Permanent link")'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用程序：模拟快速/慢路径和GC压力[¶](#test-app-simulating-fastslow-paths-and-gc-pressure
    "永久链接")
- en: To benchmark meaningfully, we need endpoints that reflect different workload
    characteristics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行有意义的基准测试，我们需要反映不同工作负载特性的端点。
- en: <details class="example"><summary>Show the benchmarking app</summary>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示基准测试应用程序</summary>
- en: '[PRE0]</details>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]</details>'
- en: '`/fast`: A quick response, ideal for throughput testing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/fast`：快速响应，适用于吞吐量测试。'
- en: '`/slow`: Simulates latency and contention.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/slow`：模拟延迟和竞争。'
- en: '`/gc`: Simulate GC heavy workflow.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/gc`：模拟GC密集型工作流程。'
- en: '`net/http/pprof`: Exposes runtime profiling on `localhost:6060`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http/pprof`：在`localhost:6060`上公开运行时剖析。'
- en: 'Run it with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行它：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Simulating Load: Tools That Reflect Reality[¶](#simulating-load-tools-that-reflect-reality
    "Permanent link")'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟负载：反映现实情况的工具[¶](#simulating-load-tools-that-reflect-reality "永久链接")
- en: When to Use What[¶](#when-to-use-what "Permanent link")
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用什么[¶](#when-to-use-what "永久链接")
- en: Info
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: This is by no means an exhaustive list. The ecosystem of load-testing tools
    is broad and constantly evolving. Tools like Apache JMeter, Locust, Artillery,
    and Gatling each bring their own strengths—ranging from UI-driven test design
    to distributed execution or JVM-based scenarios. The right choice depends on your
    stack, test goals, and team workflow. The tools listed here are optimized for
    Go-based services and local-first benchmarking, but they’re just a starting point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一份详尽的列表。负载测试工具的生态系统很广泛，并且不断在发展。像Apache JMeter、Locust、Artillery和Gatling这样的工具各自带来了自己的优势——从基于UI的测试设计到分布式执行或基于JVM的场景。正确的选择取决于您的堆栈、测试目标和团队工作流程。这里列出的工具针对基于Go的服务和本地优先基准测试进行了优化，但它们只是起点。
- en: At a glance, `vegeta`, `wrk`, and `k6` all hammer HTTP endpoints. But they serve
    different roles depending on what you're testing, how much precision you need,
    and how complex your scenario is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看上去，`vegeta`、`wrk`和`k6`都在打击HTTP端点。但它们根据您要测试的内容、所需的精度以及场景的复杂度扮演不同的角色。
- en: '| Tool | Focus | Scriptable | Metrics Depth | Ideal Use Case |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 重点关注 | 可脚本化 | 指标深度 | 理想用例 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `vegeta` | Constant rate load generation | No (but composable) | High (histogram,
    percentiles) | Tracking latency percentiles over time; CI benchmarking |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `vegeta` | 恒定速率负载生成 | 否（但可组合） | 高（直方图、百分位数） | 跟踪随时间变化的延迟百分位数；CI基准测试 |'
- en: '| `wrk` | Max throughput stress tests | Yes (Lua) | Medium | Measuring raw
    server capacity and concurrency limits |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `wrk` | 最大吞吐量压力测试 | 是（Lua） | 中等 | 测量原始服务器容量和并发限制 |'
- en: '| `k6` | Scenario-based simulation | Yes (JavaScript) | High (VU metrics, dashboards)
    | Simulating real-world user workflows and pacing |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `k6` | 基于场景的模拟 | 是（JavaScript） | 高（VU指标、仪表板） | 模拟现实世界用户工作流程和节奏 |'
- en: 'Use `vegeta` when:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用`vegeta`：
- en: You need a consistent RPS load (e.g., 100 requests/sec for the 60s).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要一个一致的RPS负载（例如，60秒内每秒100个请求）。
- en: You're observing latency degradation under controlled pressure.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在受控压力下观察延迟下降。
- en: You want structured output (histograms, percentiles) for profiling.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要结构化输出（直方图、百分位数）以进行剖析。
- en: You want to verify local changes before deeper profiling.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行更深入的剖析之前，您想验证本地更改。
- en: 'Use `wrk` when:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用`wrk`：
- en: You're exploring upper-bound throughput.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您正在探索上限吞吐量。
- en: You want raw, fast load with minimal setup.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要原始、快速的负载，设置最少。
- en: You’re profiling at high concurrency (e.g., 10k connections).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在高并发（例如，10k个连接）下进行剖析。
- en: 'Use `k6` when:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用`k6`：
- en: You must model complex flows like login → API call → wait → logout.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须模拟复杂的流程，如登录 → API调用 → 等待 → 注销。
- en: You’re integrating performance tests into CI/CD.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在将性能测试集成到CI/CD中。
- en: You want thresholds, pacing, and visual feedback.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要阈值、节奏和视觉反馈。
- en: Each of these tools has a place in your benchmarking toolkit. Picking the right
    one depends on whether you're validating performance, exploring scaling thresholds,
    or simulating end-user behavior.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的每一个都适合你的基准测试工具箱。选择正确的工具取决于你是否在验证性能、探索扩展阈值或模拟最终用户行为。
- en: Vegeta[¶](#vegeta "Permanent link")
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vegeta[¶](#vegeta "永久链接")
- en: '[Vegeta](https://github.com/tsenart/vegeta) is a flexible HTTP load testing
    tool written in Go, built for generating constant request rates. This makes it
    well-suited for simulating steady, sustained traffic patterns instead of sudden
    spikes.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[Vegeta](https://github.com/tsenart/vegeta) 是一个灵活的HTTP负载测试工具，用Go语言编写，旨在生成恒定的请求速率。这使得它非常适合模拟稳定的、持续的流量模式，而不是突然的峰值。'
- en: We reach for Vegeta when precision matters. It maintains exact request rates
    and captures detailed latency distributions, which helps track how system behavior
    changes under load. It’s lightweight, easy to automate, and integrates cleanly
    into CI workflows—making it a reliable option for benchmarking Go services.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当精度很重要时，我们会选择Vegeta。它保持精确的请求速率并捕获详细的延迟分布，这有助于跟踪系统在负载下的行为变化。它是轻量级的，易于自动化，并且可以干净地集成到CI工作流程中——使其成为基准测试Go服务的可靠选择。
- en: 'Install:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Which endpoint(s) we are going to test:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试哪个（些）端点：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <details class="example"><summary>Potential output</summary>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>潜在输出</summary>
- en: '[PRE5]</details>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]</details>'
- en: 'View percentiles:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看百分位数：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Generate chart:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 生成图表：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <details class="info"><summary>Testing Multiple Endpoints with Vegeta</summary>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="info"><summary>使用Vegeta测试多个端点</summary>
- en: Depending on your goals, there are two recommended approaches for testing both
    `/fast` and `/slow` endpoints in a single run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的目标，有两种推荐的测试方法，可以在单次运行中测试`/fast`和`/slow`端点。
- en: '**Option 1: Round-Robin Between Endpoints**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项1：端点间的轮询**'
- en: 'Create a `targets.txt` with both endpoints:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含两个端点的`targets.txt`文件：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the test:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Requests are randomly distributed between the two endpoints.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求在两个端点之间随机分布。
- en: Useful for observing aggregate behavior of mixed traffic.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于观察混合流量的总体行为。
- en: Easy to set up and analyze combined performance.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于设置和分析组合性能。
- en: '**Option 2: Weighted Mix Using Multiple Vegeta Runs**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项2：使用多个Vegeta运行加权混合**'
- en: 'To simulate different traffic proportions (e.g., 80% fast, 20% slow):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟不同的流量比例（例如，80%快速，20%慢）：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then merge the results and generate a report:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将结果合并并生成报告：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Gives you precise control over traffic distribution.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对流量分布的精确控制。
- en: Better for simulating realistic traffic mixes.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更适合模拟真实的流量混合。
- en: Enables per-endpoint benchmarking when analyzed separately.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当单独分析时，启用每个端点的基准测试。
- en: Both methods are valid—choose based on whether you need simplicity or control.</details>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是有效的——根据你需要简单性还是控制来选择。</details>
- en: wrk[¶](#wrk "Permanent link")
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wrk[¶](#wrk "永久链接")
- en: '[wrk](https://github.com/wg/wrk) is a high-performance HTTP benchmarking tool
    written in C. It''s designed for raw speed and concurrency, making it ideal for
    stress testing your server’s throughput and connection handling capacity.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[wrk](https://github.com/wg/wrk) 是一个用C语言编写的性能HTTP基准测试工具。它旨在提供原始速度和并发性，使其非常适合压力测试服务器的吞吐量和连接处理能力。'
- en: We use `wrk` when we want to push the system to its upper limits. It excels
    at flooding endpoints with high request volumes using multiple threads and connections.
    While it doesn’t offer detailed percentiles like `vegeta`, it's perfect for quick
    saturation tests and measuring how much traffic your Go server can handle before
    it starts dropping requests or stalling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将系统推到极限时，我们会使用`wrk`。它擅长使用多个线程和连接向端点发送高请求量。虽然它不像`vegeta`那样提供详细的百分位数，但它非常适合快速饱和测试和测量Go服务器在开始丢弃请求或停滞之前可以处理多少流量。
- en: 'Install:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <details class="example"><summary>Potential output</summary>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>潜在输出</summary>
- en: '[PRE14]</details>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]</details>'
- en: k6[¶](#k6 "Permanent link")
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: k6[¶](#k6 "永久链接")
- en: '[k6](https://k6.io) is a modern load testing tool built around scripting realistic
    client behavior in JavaScript. It’s designed for simulating time-based load profiles—ramp-up,
    steady-state, ramp-down—and supports custom flows, pacing, and threshold-based
    validation.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[k6](https://k6.io) 是一个围绕在 JavaScript 中编写现实客户行为的现代负载测试工具。它旨在模拟基于时间的负载配置文件——上升、稳定状态、下降——并支持自定义流程、节奏和基于阈值的验证。'
- en: We use `k6` when raw throughput isn’t enough and we need to simulate how real
    users interact with the system. It handles chained requests, models session-like
    flows, and supports stage-based testing out of the box. With rich metrics and
    seamless CI/CD integration, `k6` helps surface regressions before they reach production.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当原始吞吐量不足且我们需要模拟真实用户如何与系统交互时，我们使用 `k6`。它处理链式请求，模拟会话式流程，并支持开箱即用的基于阶段的测试。凭借丰富的指标和无缝的
    CI/CD 集成，`k6` 有助于在生产之前揭示回归。
- en: 'Install:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <details class="example"><summary>Potential output</summary>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>潜在输出</summary>
- en: '[PRE18]</details>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]</details>'
- en: Profiling Networked Go Applications with `pprof`[¶](#profiling-networked-go-applications-with-pprof
    "Permanent link")
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `pprof` 配置文件网络 Go 应用程序[¶](#profiling-networked-go-applications-with-pprof
    "永久链接")
- en: 'Profiling Go applications that heavily utilize networking is crucial to identifying
    and resolving bottlenecks that impact performance under high-traffic scenarios.
    Go''s built-in `net/http/pprof` package provides insights specifically beneficial
    for network-heavy operations. Set up continuous profiling by enabling an HTTP
    endpoint:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件 Go 应用程序，这些应用程序大量使用网络，对于识别和解决在高流量场景下影响性能的瓶颈至关重要。Go 内置的 `net/http/pprof`
    包提供了针对网络密集型操作特别有益的见解。通过启用 HTTP 端点来设置持续配置文件：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s possible to inspect the application in real time, even under heavy load.
    To capture a CPU profile:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在实时状态下检查应用程序，即使在重负载下也是如此。要捕获 CPU 配置文件：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This grabs a 30-second snapshot of CPU usage. With the `pprof` HTTP server exposed,
    all runtime data—CPU, memory, goroutines, contention, flamegraphs—is available
    without pausing or restarting the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这会捕获 CPU 使用情况的 30 秒快照。通过暴露 `pprof` HTTP 服务器，所有运行时数据——CPU、内存、goroutines、竞争、火焰图——都可在不暂停或重新启动应用程序的情况下获得。
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: the actual `cpu.prof` path will be something like `$HOME/pprof/pprof.net-app.samples.cpu.004.pb.gz`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的 `cpu.prof` 路径可能类似于 `$HOME/pprof/pprof.net-app.samples.cpu.004.pb.gz`
- en: CPU Profiling[¶](#cpu-profiling "Permanent link")
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU 配置文件[¶](#cpu-profiling "永久链接")
- en: Profiling a system at rest rarely tells the full story. Real bottlenecks show
    up under pressure—when requests stack up, threads compete, and memory churn increases.
    CPU profiling during load reveals where execution time concentrates, often exposing
    slow serialization, inefficient handler logic, or contention between goroutines.
    These are the paths that quietly limit throughput and inflate latency when traffic
    scales.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件在静态系统上很少能完全说明问题。真正的瓶颈在压力下出现——当请求堆积，线程竞争，内存碎片增加时。在负载期间进行 CPU 配置文件分析揭示了执行时间集中的地方，通常暴露出缓慢的序列化、低效的处理逻辑或
    goroutines 之间的竞争。这些是在流量扩展时悄无声息地限制吞吐量和增加延迟的路径。
- en: What to Look For[¶](#what-to-look-for "Permanent link")
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要查找的内容[¶](#what-to-look-for "永久链接")
- en: 'Network Serialization Hotspots: Frequent use of `json.Marshal` or similar serialization
    methods during network response generation.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络序列化热点：在网络响应生成期间频繁使用 `json.Marshal` 或类似序列化方法。
- en: 'Syscall Overhead: Extensive syscall usage (e.g., `syscall.Read`) suggesting
    inefficient socket handling or excessive blocking I/O.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用开销：广泛的系统调用使用（例如，`syscall.Read`），表明不高效的套接字处理或过多的阻塞 I/O。
- en: 'GC Activity: High frequency of `runtime.gc` indicating inefficient memory management
    impacting response latency.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC 活动：`runtime.gc` 高频出现，表明内存管理效率低下，影响响应延迟。
- en: '**Why This Matters:** Identifying and optimizing CPU-intensive operations in
    networking contexts reduces latency, boosts throughput, and improves reliability
    during traffic spikes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要：**在网络环境中识别和优化 CPU 密集型操作可以减少延迟，提高吞吐量，并在流量激增时提高可靠性。'
- en: Flamegraphs[¶](#flamegraphs "Permanent link")
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 火焰图[¶](#flamegraphs "永久链接")
- en: Flamegraphs provide a visual summary of where CPU time is spent by aggregating
    and collapsing stack traces into a single view. They make it easy to identify
    performance hotspots without digging through raw profiling data. In server applications,
    this often highlights issues in request handling, serialization, or blocking I/O.
    Under load, flamegraphs are especially useful for catching subtle inefficiencies
    that scale into major performance problems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图通过聚合和折叠堆栈跟踪到一个单一视图，提供了CPU时间花费的视觉总结。它们使得识别性能热点变得容易，无需深入原始分析数据。在服务器应用程序中，这通常突出了请求处理、序列化或阻塞I/O的问题。在负载下，火焰图特别有用，可以捕捉到微小的低效率，这些低效率会扩展成主要性能问题。
- en: What to Look For[¶](#what-to-look-for_1 "Permanent link")
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需要关注的内容[¶](#what-to-look-for_1 "永久链接")
- en: Functions related to network I/O or data transfer that appear as wide blocks
    in a flamegraph often point to excessive time spent on serialization, buffering,
    or socket operations.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在火焰图中表现为宽块的与网络I/O或数据传输相关的函数通常指向在序列化、缓冲或套接字操作上花费过多时间。
- en: Deep Call Chains Deep stacks could reveal inefficient middleware or unnecessary
    layers in network request handling.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深层调用链深层堆栈可能揭示了效率低下的中间件或网络请求处理中不必要的层。
- en: Unexpected Paths Look for unexpected serialization, reflection, or routing inefficiencies.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找意外路径寻找意外的序列化、反射或路由效率低下。
- en: '**Why This Matters:** Flamegraphs simplify diagnosing complex inefficiencies
    visually, leading to quicker optimization and reduced downtime.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要：**火焰图通过视觉诊断复杂低效，导致更快优化和减少停机时间。'
- en: Managing Garbage Collection (GC) Pressure[¶](#managing-garbage-collection-gc-pressure
    "Permanent link")
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理垃圾回收（GC）压力[¶](#managing-garbage-collection-gc-pressure "永久链接")
- en: Memory profiling helps identify where your application is wasting heap space,
    especially in network-heavy code paths. Common issues include repeated allocation
    of response buffers, temporary objects, or excessive use of slices and maps. These
    patterns often go unnoticed until they trigger GC pressure or latency under load.
    Profiling with `pprof` follows the same basic steps as CPU profiling, making it
    easy to integrate into your existing workflow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析有助于确定应用程序在哪里浪费堆空间，尤其是在网络密集型代码路径中。常见问题包括重复分配响应缓冲区、临时对象或过度使用切片和映射。这些模式通常直到触发GC压力或负载下的延迟才会被发现。使用`pprof`进行内存分析遵循与CPU分析相同的基本步骤，使其易于集成到现有工作流程中。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, again, you can view results interactively.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次，你可以交互式地查看结果。
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: the actual `mem.prof` path will be something like `$HOME/pprof/pprof.net-app.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz`
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的`mem.prof`路径可能类似于`$HOME/pprof/pprof.net-app.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz`
- en: What to Look For[¶](#what-to-look-for_2 "Permanent link")
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需要关注的内容[¶](#what-to-look-for_2 "永久链接")
- en: 'Frequent Temporary Buffers: High frequency of allocations in network buffers,
    such as repeatedly creating byte slices for each request.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁的临时缓冲区：网络缓冲区中分配的高频率，例如为每个请求重复创建字节切片。
- en: 'Persistent Network Objects: Accumulation of long-lived network connections
    or sessions.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久的网络对象：长期存在的网络连接或会话的积累。
- en: 'Excessive Serialization Overhead: High object creation rate due to repeated
    encoding/decoding of network payloads.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度的序列化开销：由于重复编码/解码网络负载，导致对象创建率过高。
- en: 'Example: Optimizing buffer reuse using `sync.Pool` greatly reduces GC pressure
    during high-volume network operations.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：使用`sync.Pool`优化缓冲区重用，在大量网络操作期间显著降低GC压力。
- en: '**Why This Matters:** Reducing memory churn from network activities improves
    response times and minimizes latency spikes caused by GC.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要：**减少网络活动引起的内存波动可以提高响应时间并最小化由GC引起的延迟峰值。'
- en: Identifying CPU Bottlenecks[¶](#identifying-cpu-bottlenecks "Permanent link")
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别CPU瓶颈[¶](#identifying-cpu-bottlenecks "永久链接")
- en: Networked applications often hit CPU limits first when pushed under sustained
    load. Profiling helps surface where time is actually being spent and what’s getting
    in the way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序在持续负载下首先达到CPU限制。分析可以帮助揭示实际花费时间和阻碍的因素。
- en: What to Look For[¶](#what-to-look-for_3 "Permanent link")
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 需要关注的内容[¶](#what-to-look-for_3 "永久链接")
- en: 'Latency Rising While Throughput Stalls: A sign the CPU is saturated, often
    from request processing or serialization overhead.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟上升而吞吐量停滞：这是CPU饱和的迹象，通常是由于请求处理或序列化开销造成的。
- en: 'Scheduler Overhead (runtime.schedule, mcall): Too many goroutines can overwhelm
    the scheduler, especially when each connection gets its own handler.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度开销（runtime.schedule, mcall）：过多的goroutine可能会压倒调度器，尤其是在每个连接都有自己的处理器时。
- en: 'Lock Contention: Repeated locking on shared network state or blocking channel
    operations slows down throughput and limits parallelism.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁竞争：在共享网络状态上重复加锁或阻塞通道操作会降低吞吐量并限制并行性。
- en: For example, if profiling shows excessive time spent in TLS handshake routines,
    the fix might involve moving handshakes off the hot path or reducing handshake
    frequency with connection reuse.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果分析显示在TLS握手例程中花费了过多时间，修复可能涉及将握手操作从热点路径移除或通过连接重用减少握手频率。
- en: '**Why it matters:** CPU bottlenecks cap your ability to scale. Fixing them
    is often the difference between a system that handles 5K clients and one that
    handles 50K.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这很重要：** CPU瓶颈限制了您扩展的能力。修复它们通常是处理5K客户端和50K客户端的系统之间的区别。'
- en: Practicle example of Profiling Networked Go Applications with `pprof`[¶](#practicle-example-of-profiling-networked-go-applications-with-pprof
    "Permanent link")
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`pprof`对网络化Go应用程序进行性能分析的实际示例[¶](#practicle-example-of-profiling-networked-go-applications-with-pprof
    "永久链接")
- en: To illustrate these concepts practically, our demo application integrates profiling
    and benchmarking tools and provides comprehensive profiling and load testing scenarios.
    The demo covers identifying performance bottlenecks, analyzing flame graphs, and
    benchmarking under various simulated network conditions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际说明这些概念，我们的演示应用程序集成了分析和基准测试工具，并提供了全面的分析和负载测试场景。演示涵盖了识别性能瓶颈、分析火焰图以及在各种模拟网络条件下的基准测试。
- en: Due to its significant size, [Practicle example of Profiling Networked Go Applications
    with `prof`](../gc-endpoint-profiling/) is a separate article.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其显著的大小，[使用`prof`对网络化Go应用程序进行性能分析的实际示例](../gc-endpoint-profiling/)是一篇单独的文章。
- en: Benchmarking as a Feedback Loop[¶](#benchmarking-as-a-feedback-loop "Permanent
    link")
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试作为反馈循环[¶](#benchmarking-as-a-feedback-loop "永久链接")
- en: A single load test run means little in isolation. But if you treat benchmarking
    as part of your development cycle—before and after changes—you start building
    a performance narrative. You can see exactly how a change impacted throughput
    or whether it traded latency for memory overhead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单次负载测试运行在孤立状态下意义不大。但如果你将基准测试视为开发周期的一部分——在更改前后——你开始构建性能叙事。你可以确切地看到更改是如何影响吞吐量或是否以内存开销为代价换取了延迟。
- en: The Go standard library gives you `testing.B` for microbenchmarks. Combine profiling
    with robust integration testing as part of your CI/CD pipeline using tools like
    `Vegeta` and `k6`. This practice ensures early detection of regressions, continuous
    validation of performance enhancements, and reliable application performance maintenance
    under realistic production conditions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了`testing.B`用于微基准测试。将分析与健壮的集成测试相结合，作为CI/CD管道的一部分，使用像`Vegeta`和`k6`这样的工具。这种做法确保了早期检测回归，持续验证性能改进，并在实际生产条件下可靠地维护应用程序性能。
