["```go\n[](#cb1-1)// find the closest position that is less or equal to the input key\n[](#cb1-2)func (tree *BTree) SeekLE(key []byte) *BIter\n[](#cb1-3)\n[](#cb1-4)// get the current KV pair\n[](#cb1-5)func (iter *BIter) Deref() ([]byte, []byte)\n[](#cb1-6)// precondition of the Deref()\n[](#cb1-7)func (iter *BIter) Valid() bool\n[](#cb1-8)// moving backward and forward\n[](#cb1-9)func (iter *BIter) Prev()\n[](#cb1-10)func (iter *BIter) Next()\n```", "```go\n[](#cb2-1)for iter := tree.SeekLE(key); iter.Valid(); iter.Prev() {\n[](#cb2-2)    k, v := iter.Deref()\n[](#cb2-3)    // ...\n[](#cb2-4)}\n```", "```go\n[](#cb3-1)type BIter struct {\n[](#cb3-2)    tree *BTree\n[](#cb3-3)    path []BNode  // from root to leaf\n[](#cb3-4)    pos  []uint16 // indexes into nodes\n[](#cb3-5)}\n```", "```go\n[](#cb4-1)func (iter *BIter) Next() {\n[](#cb4-2)    iterNext(iter, len(iter.path)-1)\n[](#cb4-3)}\n[](#cb4-4)func iterNext(iter *BIter, level int) {\n[](#cb4-5)    if iter.pos[level]+1 < iter.path[level].nkeys() {\n[](#cb4-6)        iter.pos[level]++ // move within this node\n[](#cb4-7)    } else if level > 0 {\n[](#cb4-8)        iterNext(iter, level-1) // move to a sibling node\n[](#cb4-9)    } else {\n[](#cb4-10)        iter.pos[len(iter.pos)-1]++ // past the last key\n[](#cb4-11)        return\n[](#cb4-12)    }\n[](#cb4-13)    if level+1 < len(iter.pos) { // update the child node\n[](#cb4-14)        node := iter.path[level]\n[](#cb4-15)        kid := BNode(iter.tree.get(node.getPtr(iter.pos[level])))\n[](#cb4-16)        iter.path[level+1] = kid\n[](#cb4-17)        iter.pos[level+1] = 0\n[](#cb4-18)    }\n[](#cb4-19)}\n```", "```go\n[](#cb5-1)// find the closest position that is less or equal to the input key\n[](#cb5-2)func (tree *BTree) SeekLE(key []byte) *BIter {\n[](#cb5-3)    iter := &BIter{tree: tree}\n[](#cb5-4)    for ptr := tree.root; ptr != 0; {\n[](#cb5-5)        node := tree.get(ptr)\n[](#cb5-6)        idx := nodeLookupLE(node, key)\n[](#cb5-7)        iter.path = append(iter.path, node)\n[](#cb5-8)        iter.pos = append(iter.pos, idx)\n[](#cb5-9)        ptr = node.getPtr(idx)\n[](#cb5-10)    }\n[](#cb5-11)    return iter\n[](#cb5-12)}\n```", "```go\n[](#cb6-1)const (\n[](#cb6-2)    CMP_GE = +3 // >=\n[](#cb6-3)    CMP_GT = +2 // >\n[](#cb6-4)    CMP_LT = -2 // <\n[](#cb6-5)    CMP_LE = -3 // <=\n[](#cb6-6))\n[](#cb6-7)func (tree *BTree) Seek(key []byte, cmp int) *BIter\n```", "```go\n0x0000000000000001 -> 00 00 00 00 00 00 00 01\n0x0000000000000002 -> 00 00 00 00 00 00 00 02\n                  ...\n0x00000000000000ff -> 00 00 00 00 00 00 00 ff\n0x0000000000000100 -> 00 00 00 00 00 00 01 00\n```", "```go\n[](#cb8-1)            var buf [8]byte\n[](#cb8-2)            u := uint64(v.I64) + (1 << 63)        // flip the sign bit\n[](#cb8-3)            binary.BigEndian.PutUint64(buf[:], u) // big endian\n```", "```go\n00 -> 01 01\n01 -> 01 02\n```", "```go\n[](#cb10-1)// within the range or not?\n[](#cb10-2)func (sc *Scanner) Valid() bool\n[](#cb10-3)// move the underlying B-tree iterator\n[](#cb10-4)func (sc *Scanner) Next()\n[](#cb10-5)// fetch the current row\n[](#cb10-6)func (sc *Scanner) Deref(rec *Record)\n[](#cb10-7)\n[](#cb10-8)func (db *DB) Scan(table string, req *Scanner) error\n```", "```go\n[](#cb11-1)type Scanner struct {\n[](#cb11-2)    // the range, from Key1 to Key2\n[](#cb11-3)    Cmp1 int // CMP_??\n[](#cb11-4)    Cmp2 int\n[](#cb11-5)    Key1 Record\n[](#cb11-6)    Key2 Record\n[](#cb11-7)    // ...\n[](#cb11-8)}\n```"]