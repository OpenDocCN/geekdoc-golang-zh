- en: Memory Preallocation¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存预分配¶
- en: 原文：[https://goperf.dev/01-common-patterns/mem-prealloc/](https://goperf.dev/01-common-patterns/mem-prealloc/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://goperf.dev/01-common-patterns/mem-prealloc/](https://goperf.dev/01-common-patterns/mem-prealloc/)'
- en: Memory preallocation is a simple but effective way to improve performance in
    Go programs that work with slices or maps that grow over time. Instead of letting
    the runtime resize these structures as they fill up—often at unpredictable points—you
    allocate the space you need upfront. This avoids the cost of repeated allocations,
    internal copying, and extra GC pressure as intermediate objects are created and
    discarded.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内存预分配是提高 Go 程序性能的一种简单但有效的方法，这些程序处理随时间增长的切片或映射。而不是让运行时在结构填满时——通常在不可预测的点——调整这些结构的大小，你可以预先分配所需的空间。这避免了重复分配、内部复制以及创建和丢弃中间对象时额外的
    GC 压力。
- en: In high-throughput or latency-sensitive systems, preallocating memory makes
    execution more predictable and helps avoid performance cliffs that show up under
    load. If the workload size is known or can be reasonably estimated, there’s no
    reason to let the allocator do the guessing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在高吞吐量或延迟敏感的系统上，预分配内存可以使执行更加可预测，并有助于避免在负载下出现的性能悬崖。如果工作负载大小已知或可以合理估计，就没有理由让分配器进行猜测。
- en: Why Preallocation Matters[¶](#why-preallocation-matters "Permanent link")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么预分配很重要[¶](#why-preallocation-matters "永久链接")
- en: Go’s slices and maps grow automatically as new elements are added, but that
    convenience comes with a cost. When capacity is exceeded, the runtime allocates
    a larger backing array or hash table and copies the existing data over. This reallocation
    adds memory pressure, burns CPU cycles, and can stall tight loops in high-throughput
    paths. In performance-critical code—especially where the size is known or can
    be estimated—frequent resizing is unnecessary overhead. Preallocating avoids these
    penalties by giving the runtime enough room to work without interruption.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的切片和映射在添加新元素时会自动增长，但这种便利也伴随着成本。当容量超出时，运行时会分配一个更大的支持数组或哈希表，并将现有数据复制过来。这种重新分配增加了内存压力，消耗
    CPU 周期，并可能导致高吞吐量路径中的紧密循环停滞。在性能关键代码中——特别是在大小已知或可以估计的情况下——频繁调整大小是不必要的开销。预分配通过给运行时足够的空间来工作，避免了这些惩罚。
- en: Go uses a hybrid growth strategy for slices to balance speed and memory efficiency.
    Early on, capacities double with each expansion—2, 4, 8, 16—minimizing the number
    of allocations. But once a slice exceeds around 1024 elements, the growth rate
    slows to roughly 25%. So instead of jumping from 1024 to 2048, the next allocation
    might grow to about 1280.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go 为切片使用混合增长策略，以平衡速度和内存效率。一开始，容量随着每次扩展而加倍——2, 4, 8, 16——最小化分配次数。但一旦切片超过大约 1024
    个元素，增长率会减慢到大约 25%。因此，而不是从 1024 跳到 2048，下一次分配可能增长到大约 1280。
- en: This shift reduces memory waste on large slices but increases the frequency
    of allocations if the final size is known but not preallocated. In those cases,
    using make([]T, 0, expectedSize) is the more efficient choice—it avoids repeated
    resizing and cuts down on unnecessary copying.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转变减少了大型切片上的内存浪费，但如果最终大小已知但未预分配，会增加分配的频率。在这种情况下，使用 `make([]T, 0, expectedSize)`
    是更有效的选择——它避免了重复调整大小并减少了不必要的复制。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Output illustrating typical growth:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 展示典型增长的输出：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Practical Preallocation Examples[¶](#practical-preallocation-examples "Permanent
    link")
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际预分配示例[¶](#practical-preallocation-examples "永久链接")
- en: Slice Preallocation[¶](#slice-preallocation "Permanent link")
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片预分配[¶](#slice-preallocation "永久链接")
- en: 'Without preallocation, each append operation might trigger new allocations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有预分配，每次追加操作可能会触发新的分配：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This pattern causes Go to allocate larger underlying arrays repeatedly as the
    slice grows, resulting in memory copying and GC pressure. We can avoid that by
    using `make` with a specified capacity:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式会导致 Go 在切片增长时反复分配更大的底层数组，从而引起内存复制和 GC 压力。我们可以通过使用 `make` 并指定容量来避免这种情况：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it is known that the slice will be fully populated, we can be even more
    efficient by avoiding bounds checks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知切片将被完全填充，我们可以通过避免边界检查来进一步提高效率：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Map Preallocation[¶](#map-preallocation "Permanent link")
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射预分配[¶](#map-preallocation "永久链接")
- en: Maps grow similarly. By default, Go doesn’t know how many elements you’ll add,
    so it resizes the underlying structure as needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 映射（Map）的增长方式类似。默认情况下，Go 不知道你会添加多少元素，因此它会根据需要调整底层结构的大小。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Starting with Go 1.11, you can preallocate `map` capacity too:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Go 1.11 版本开始，你也可以预分配 `map` 容量：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This helps the runtime allocate enough internal storage upfront, avoiding rehashing
    and resizing costs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于运行时预先分配足够的内部存储，避免重新哈希和调整大小的成本。
- en: Benchmarking Impact[¶](#benchmarking-impact "Permanent link")
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响[¶](#benchmarking-impact "永久链接")
- en: 'Here’s a simple benchmark comparing appending to a preallocated slice vs. a
    zero-capacity slice:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的基准测试，比较将元素追加到预分配的切片与追加到零容量切片：
- en: <details class="example"><summary>Show the benchmark file</summary>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示基准测试文件</summary>
- en: '[PRE7]</details>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]</details>'
- en: You’ll typically observe that preallocation reduces allocations to a single
    one per operation and significantly improves throughput.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会观察到预分配将分配减少到每次操作一个，并显著提高吞吐量。
- en: '| Benchmark | Iterations | Time per op (ns) | Bytes per op | Allocs per op
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 基准测试 | 迭代次数 | 每次操作时间（纳秒） | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| BenchmarkAppendNoPrealloc-14 | 41,727 | 28,539 | 357,626 | 19 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 基准测试：不带预分配的追加-14 | 41,727 | 28,539 | 357,626 | 19 |'
- en: '| BenchmarkAppendWithPrealloc-14 | 170,154 | 7,093 | 81,920 | 1 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 基准测试：带预分配的追加-14 | 170,154 | 7,093 | 81,920 | 1 |'
- en: When To Preallocate[¶](#when-to-preallocate "Permanent link")
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预分配的时机[¶](#when-to-preallocate "永久链接")
- en: 'Preallocate when:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下预分配：
- en: The number of elements in slices or maps is known or reasonably predictable.
    Allocating memory up front avoids the cost of repeated resizing as the data structure
    grows.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片或映射中的元素数量已知或可合理预测。预先分配内存可以避免随着数据结构增长而重复调整大小的成本。
- en: Your application involves tight loops or high-throughput data processing. Preallocation
    reduces per-iteration overhead and helps maintain steady performance under load.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序涉及紧密的循环或高吞吐量数据处理。预分配减少了每次迭代的开销，并有助于在负载下保持稳定的性能。
- en: Minimizing garbage collection overhead is crucial for your application's performance.
    Fewer allocations mean less work for the garbage collector, resulting in lower
    latency and more consistent behavior.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化垃圾收集开销对你的应用程序性能至关重要。更少的分配意味着垃圾收集器的工作量更少，从而降低延迟并提高行为的一致性。
- en: 'Avoid preallocation when:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下避免预分配：
- en: The data size is highly variable and unpredictable. If input sizes fluctuate
    widely, any fixed-size preallocation risks being either too small (leading to
    reallocations) or too large (wasting memory).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据大小高度可变且不可预测。如果输入大小波动很大，任何固定大小的预分配都可能导致要么太小（导致重新分配），要么太大（浪费内存）。
- en: Over-allocation risks significant memory waste. Reserving more memory than needed
    increases your application’s footprint and can negatively impact cache locality
    or trigger unnecessary GC activity.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度分配可能导致显著的内存浪费。预留比所需更多的内存会增加应用程序的内存占用，并可能对缓存局部性产生负面影响或触发不必要的垃圾收集活动。
- en: You’re prematurely optimizing. Always verify with profiling. Preallocation is
    effective, but only when it addresses a real bottleneck or allocation hotspot
    in your workload.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在过早地进行优化。始终使用性能分析来验证。预分配是有效的，但只有当它解决你工作负载中的真实瓶颈或分配热点时。
