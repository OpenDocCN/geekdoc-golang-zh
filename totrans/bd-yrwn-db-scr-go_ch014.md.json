["```go\n select\n       /   |   \\\ncolumns  table  condition\n  ...     foo      and\n                 /     \\\n                >       <\n               / \\     / \\\n              a   b   a   c\n```", "```go\n +\n / \\\na   *\n   / \\\n  b   c\n```", "```go\n[](#cb3-1)# pseudo code\n[](#cb3-2)def eval(node):\n[](#cb3-3)    if is_binary_operator(node):\n[](#cb3-4)        left, right = eval(node.left), eval(node.right)\n[](#cb3-5)        return node.operator(left, right)\n[](#cb3-6)    elif is_value(node):\n[](#cb3-7)        return node.value\n[](#cb3-8)    ...\n```", "```go\n[](#cb4-1)create table table_name (\n[](#cb4-2)    a type1,\n[](#cb4-3)    b type2,\n[](#cb4-4)    ...\n[](#cb4-5)    index (c, b, a),\n[](#cb4-6)    index (d, e, f),\n[](#cb4-7)    primary key (a, b),\n[](#cb4-8));\n[](#cb4-9)\n[](#cb4-10)select expr... from table_name conditions limit x, y;\n[](#cb4-11)insert into table_name (cols...) values (a, b, c)...;\n[](#cb4-12)delete from table_name conditions limit x, y;\n[](#cb4-13)update table_name set a = expr, b = expr, ... conditions limit x, y;\n```", "```go\n[](#cb5-1)-- one of the 3 forms\n[](#cb5-2)select expr... from table_name index by a = 1;\n[](#cb5-3)select expr... from table_name index by a > 1;\n[](#cb5-4)select expr... from table_name index by a > 1 and a < 5;\n[](#cb5-5)-- the last query in descending order\n[](#cb5-6)select expr... from table_name index by a < 5 and a > 1;\n```", "```go\n[](#cb6-1)-- the filter condition can be arbitrary\n[](#cb6-2)select expr... from table_name index by condition1 filter condition2;\n[](#cb6-3)select expr... from table_name filter condition2;\n```", "```go\n[](#cb7-1)a OR b\n[](#cb7-2)a AND b\n[](#cb7-3)NOT a\n[](#cb7-4)a = b, a < b, ...   -- comparisons\n[](#cb7-5)a + b, a - b\n[](#cb7-6)a * b, a / b\n[](#cb7-7)-a\n```", "```go\n[](#cb8-1)type QLNode struct {\n[](#cb8-2)    Type uint32 // tagged union\n[](#cb8-3)    I64  int64\n[](#cb8-4)    Str  []byte\n[](#cb8-5)    Kids []QLNode // operands\n[](#cb8-6)}\n```", "```go\n[](#cb9-1)// statements: select, update, delete\n[](#cb9-2)type QLSelect struct {\n[](#cb9-3)    QLScan\n[](#cb9-4)    Names  []string // expr AS name\n[](#cb9-5)    Output []QLNode\n[](#cb9-6)}\n[](#cb9-7)type QLUpdate struct {\n[](#cb9-8)    QLScan\n[](#cb9-9)    Names  []string\n[](#cb9-10)    Values []QLNode\n[](#cb9-11)}\n[](#cb9-12)type QLDelete struct {\n[](#cb9-13)    QLScan\n[](#cb9-14)}\n[](#cb9-15)// common structure for statements: `INDEX BY`, `FILTER`, `LIMIT`\n[](#cb9-16)type QLScan struct {\n[](#cb9-17)    Table  string // table name\n[](#cb9-18)    Key1   QLNode // index by\n[](#cb9-19)    Key2   QLNode\n[](#cb9-20)    Filter QLNode // filter expression\n[](#cb9-21)    Offset int64  // limit\n[](#cb9-22)    Limit  int64\n[](#cb9-23)}\n```", "```go\n[](#cb10-1)func pStmt(p *Parser) (r interface{}) {\n[](#cb10-2)    switch {\n[](#cb10-3)    case pKeyword(p, \"create\", \"table\"):\n[](#cb10-4)        r = pCreateTable(p)\n[](#cb10-5)    case pKeyword(p, \"select\"):\n[](#cb10-6)        r = pSelect(p)\n[](#cb10-7)    // ...\n[](#cb10-8)    }\n[](#cb10-9)    return r\n[](#cb10-10)}\n```", "```go\n[](#cb11-1)func pSelect(p *Parser) *QLSelect {\n[](#cb11-2)    stmt := QLSelect{}\n[](#cb11-3)    pSelectExprList(p, &stmt)   // SELECT xxx\n[](#cb11-4)    pExpect(p, \"from\", \"expect `FROM` table\")\n[](#cb11-5)    stmt.Table = pMustSym(p)    // FROM table\n[](#cb11-6)    pScan(p, &stmt.QLScan)      // INDEX BY xxx FILTER yyy LIMIT zzz\n[](#cb11-7)    return &stmt\n[](#cb11-8)}\n```", "```go\n[](#cb12-1)func pSelectExprList(p *Parser, node *QLSelect) {\n[](#cb12-2)    pSelectExpr(p, node)\n[](#cb12-3)    for pKeyword(p, \",\") {\n[](#cb12-4)        pSelectExpr(p, node)\n[](#cb12-5)    }\n[](#cb12-6)}\n```", "```go\n[](#cb13-1)func pScan(p *Parser, node *QLScan) {\n[](#cb13-2)    if pKeyword(p, \"index\", \"by\") {\n[](#cb13-3)        pIndexBy(p, node)\n[](#cb13-4)    }\n[](#cb13-5)    if pKeyword(p, \"filter\") {\n[](#cb13-6)        pExprOr(p, &node.Filter)\n[](#cb13-7)    }\n[](#cb13-8)    node.Offset, node.Limit = 0, math.MaxInt64\n[](#cb13-9)    if pKeyword(p, \"limit\") {\n[](#cb13-10)        pLimit(p, node)\n[](#cb13-11)    }\n[](#cb13-12)}\n```", "```go\nterm\nterm + term\nterm + term + term + ...\n```", "```go\n +\n   / \\\nleft right\n```", "```go\n +\n   / \\\n  +   R\n / \\\nLL LR\n```", "```go\n[](#cb17-1)def parse_terms():\n[](#cb17-2)    node = parse_column()\n[](#cb17-3)    while consume('+'):\n[](#cb17-4)        right = parse_column()\n[](#cb17-5)        node = QLNode(type='+', kids=[node, right])\n[](#cb17-6)    return node\n```", "```go\nexpr := expr + term\nexpr := term\n```", "```go\nexpr := expr + term\nexpr := term\nterm := term * factor\nterm := factor\n```", "```go\n[](#cb20-1)def parse_terms():\n[](#cb20-2)    node = parse_factors()\n[](#cb20-3)    while consume('+'):\n[](#cb20-4)        right = parse_factors()\n[](#cb20-5)        node = QLNode(type='+', kids=[node, right])\n[](#cb20-6)    return node\n[](#cb20-7)\n[](#cb20-8)def parse_factors():\n[](#cb20-9)    node = parse_column()\n[](#cb20-10)    while consume('*'):\n[](#cb20-11)        right = parse_column()\n[](#cb20-12)        node = QLNode(type='*', kids=[node, right])\n[](#cb20-13)    return node\n```", "```go\n[](#cb21-1)a OR b          -- pExprOr\n[](#cb21-2)a AND b         -- pExprAnd\n[](#cb21-3)NOT a           -- pExprNot\n[](#cb21-4)a = b, a < b    -- pExprCmp\n[](#cb21-5)a + b, a - b    -- pExprAdd\n[](#cb21-6)a * b, a / b    -- pExprMul\n[](#cb21-7)-a              -- pExprUnop\n```"]