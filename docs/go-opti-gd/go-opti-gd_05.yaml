- en: Object Pooling¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池[¶]
- en: 原文：[https://goperf.dev/01-common-patterns/object-pooling/](https://goperf.dev/01-common-patterns/object-pooling/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/object-pooling/](https://goperf.dev/01-common-patterns/object-pooling/)
- en: Object pooling helps reduce allocation churn in high-throughput Go programs
    by reusing objects instead of allocating fresh ones each time. This avoids repeated
    work for the allocator and eases pressure on the garbage collector, especially
    when dealing with short-lived or frequently reused structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用对象而不是每次都分配新的对象，对象池有助于减少高吞吐量 Go 程序中的分配波动。这避免了分配器的重复工作，并减轻了垃圾回收器的压力，尤其是在处理短生命周期或频繁重用的结构时。
- en: Go’s `sync.Pool` provides a built-in way to implement pooling with minimal code.
    It’s particularly effective for objects that are expensive to allocate or that
    would otherwise contribute to frequent garbage collection cycles. While not a
    silver bullet, it’s a low-friction tool that can lead to noticeable gains in latency
    and CPU efficiency under sustained load.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `sync.Pool` 提供了一种用最少的代码实现池化的内置方式。它特别适用于分配成本高昂或可能导致频繁垃圾回收周期的对象。虽然不是万能的解决方案，但它是一个低摩擦的工具，可以在持续负载下带来显著的延迟和
    CPU 效率提升。
- en: How Object Pooling Works[¶](#how-object-pooling-works "Permanent link")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池工作原理[¶](#how-object-pooling-works "永久链接")
- en: Object pooling allows programs to reuse memory by recycling previously allocated
    objects instead of creating new ones on every use. Rather than hitting the heap
    each time, objects are retrieved from a shared pool and returned once they’re
    no longer needed. This reduces the number of allocations, cuts down on garbage
    collection workload, and leads to more predictable performance—especially in workloads
    with high object churn or tight latency requirements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回收先前分配的对象而不是每次使用时都创建新的对象，对象池允许程序重用内存。而不是每次都击中堆，对象从共享池中检索，并在不再需要时返回。这减少了分配次数，减少了垃圾回收工作负载，并导致更可预测的性能——特别是在对象周转率高或对延迟要求严格的作业中。
- en: Using `sync.Pool` for Object Reuse[¶](#using-syncpool-for-object-reuse "Permanent
    link")
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 进行对象重用[¶](#using-syncpool-for-object-reuse "永久链接")
- en: Without Object Pooling (Inefficient Memory Usage)[¶](#without-object-pooling-inefficient-memory-usage
    "Permanent link")
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不使用对象池（低效的内存使用）[¶](#without-object-pooling-inefficient-memory-usage "永久链接")
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the above example, every iteration creates a new `Data` instance, leading
    to unnecessary allocations and increased GC pressure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，每次迭代都会创建一个新的 `Data` 实例，导致不必要的分配和增加垃圾回收压力。
- en: With Object Pooling (Optimized Memory Usage)[¶](#with-object-pooling-optimized-memory-usage
    "Permanent link")
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用对象池（优化内存使用）[¶](#with-object-pooling-optimized-memory-usage "永久链接")
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pooling Byte Buffers for Efficient I/O[¶](#pooling-byte-buffers-for-efficient-io
    "Permanent link")
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为高效 I/O 池化字节缓冲区[¶](#pooling-byte-buffers-for-efficient-io "永久链接")
- en: Object pooling is especially effective when working with large byte slices that
    would otherwise lead to high allocation and garbage collection overhead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池在处理大型字节切片时特别有效，否则会导致高分配和垃圾回收开销。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using `sync.Pool` for byte buffers significantly reduces memory pressure when
    dealing with high-frequency I/O operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 处理字节缓冲区可以显著降低处理高频 I/O 操作时的内存压力。
- en: Benchmarking Impact[¶](#benchmarking-impact "Permanent link")
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响[¶](#benchmarking-impact "永久链接")
- en: To prove that object pooling actually reduces allocations and improves speed,
    we can use Go's built-in memory profiling tools (`pprof`) and compare memory allocations
    between the non-pooled and pooled versions. Simulating a full-scale application
    that actively uses memory for benchmarking is challenging, so we need a controlled
    test to evaluate direct heap allocations versus pooled allocations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明对象池实际上减少了分配并提高了速度，我们可以使用 Go 的内置内存分析工具 (`pprof`) 并比较非池化和池化版本之间的内存分配。模拟一个全面使用内存进行基准测试的应用程序具有挑战性，因此我们需要一个受控的测试来评估直接堆分配与池化分配之间的差异。
- en: <details class="example"><summary>Show the benchmark file</summary>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示基准文件</summary>
- en: '[PRE3]</details>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]</details>'
- en: '| Benchmark | Iterations | Time per op (ns) | Bytes per op | Allocs per op
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 基准 | 迭代次数 | 每次操作时间 (ns) | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| BenchmarkWithoutPooling-14 | 1,692,014 | 705.4 | 8,192 | 1 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkWithoutPooling-14 | 1,692,014 | 705.4 | 8,192 | 1 |'
- en: '| BenchmarkWithPooling-14 | 160,440,506 | 7.455 | 0 | 0 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkWithPooling-14 | 160,440,506 | 7.455 | 0 | 0 |'
- en: The benchmark results highlight the contrast in performance and memory usage
    between direct allocations and object pooling. In `BenchmarkWithoutPooling`, each
    iteration creates a new object on the heap, leading to higher execution time and
    increased memory consumption. This constant allocation pressure triggers more
    frequent garbage collection, which adds latency and reduces throughput. The presence
    of nonzero allocation counts per operation confirms that each iteration contributes
    to GC load, making this approach less efficient in high-throughput scenarios.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果突出了直接分配和对象池化在性能和内存使用上的差异。在`BenchmarkWithoutPooling`中，每次迭代都会在堆上创建一个新的对象，导致执行时间增加和内存消耗增加。这种持续的分配压力会触发更频繁的垃圾收集，增加延迟并降低吞吐量。每个操作的非零分配计数确认了每次迭代都会对GC负载做出贡献，这使得这种方法在高吞吐量场景中效率较低。
- en: When Should You Use `sync.Pool`?[¶](#when-should-you-use-syncpool "Permanent
    link")
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该在何时使用`sync.Pool`？[¶](#when-should-you-use-syncpool "永久链接")
- en: 'Use sync.Pool when:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况时使用`sync.Pool`：
- en: You have short-lived, reusable objects (e.g., buffers, scratch memory, request
    state). Pooling avoids repeated allocations and lets you recycle memory efficiently.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有短暂存在且可重用的对象（例如，缓冲区、临时内存、请求状态）。池化避免了重复分配，并允许你高效地回收内存。
- en: Allocation overhead or GC churn is measurable and significant. Reusing objects
    reduces the number of heap allocations, which in turn lowers garbage collection
    frequency and pause times.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配开销或GC波动是可以测量且显著的。重用对象减少了堆分配的数量，这反过来又降低了垃圾收集的频率和暂停时间。
- en: The object’s lifecycle is local and can be reset between uses. When objects
    don’t need complex teardown and are safe to reuse after a simple reset, pooling
    is straightforward and effective.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的生命周期是局部的，可以在使用之间重置。当对象不需要复杂的拆解，并且在简单重置后可以安全重用时，池化简单且有效。
- en: You want to reduce pressure on the garbage collector in high-throughput systems.
    In systems handling thousands of requests per second, pooling helps maintain consistent
    performance and minimizes GC-related latency spikes.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望减少高吞吐量系统中对垃圾收集器的压力。在每秒处理数千个请求的系统中，池化有助于保持一致的性能并最小化与GC相关的延迟峰值。
- en: 'Avoid sync.Pool when:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况时避免使用`sync.Pool`：
- en: Objects are long-lived or shared across multiple goroutines. `sync.Pool` is
    optimized for short-lived, single-use objects and doesn’t manage shared ownership
    or coordination.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是长期存在或跨多个goroutine共享的。`sync.Pool`针对短暂的单次使用对象进行了优化，不管理共享所有权或协调。
- en: The reuse rate is low and pooled objects are not frequently accessed. If objects
    sit idle in the pool, you gain little benefit and may even waste memory.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用率低且池化对象不常被访问。如果对象在池中闲置，你获得的收益很少，甚至可能浪费内存。
- en: Predictability or lifecycle control is more important than allocation speed.
    Pooling makes lifecycle tracking harder and may not be worth the tradeoff.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测性或生命周期控制比分配速度更重要。池化使得生命周期跟踪更加困难，可能不值得这种权衡。
- en: Memory savings are negligible or code complexity increases significantly. If
    pooling doesn’t provide clear benefits, it can add unnecessary complexity to otherwise
    simple code.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存节省微不足道或代码复杂性显著增加。如果池化没有提供明显的优势，它可能会给原本简单的代码增加不必要的复杂性。
