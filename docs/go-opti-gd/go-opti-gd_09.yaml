- en: Zero-Copy Techniques¶
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零拷贝技术¶
- en: 原文：[https://goperf.dev/01-common-patterns/zero-copy/](https://goperf.dev/01-common-patterns/zero-copy/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://goperf.dev/01-common-patterns/zero-copy/](https://goperf.dev/01-common-patterns/zero-copy/)
- en: When writing performance-critical Go code, how memory is managed often has a
    bigger impact than it first appears. Zero-copy techniques are one of the more
    effective ways to tighten that control. Instead of moving bytes from buffer to
    buffer, these techniques work directly on existing memory—avoiding copies altogether.
    That means less pressure on the CPU, better cache behavior, and fewer GC-triggered
    pauses. For I/O-heavy systems—whether you’re streaming files, handling network
    traffic, or parsing large datasets—this can translate into much higher throughput
    and lower latency without adding complexity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写性能关键型的 Go 代码时，内存管理的影响往往比最初看起来更大。零拷贝技术是加强这种控制的有效方法之一。这些技术不是在缓冲区之间移动字节，而是直接在现有内存上工作——完全避免拷贝。这意味着对
    CPU 的压力更小，缓存行为更好，以及更少的由 GC 触发的暂停。对于 I/O 密集型系统——无论是流式传输文件、处理网络流量还是解析大型数据集——这可以转化为更高的吞吐量和更低的延迟，而不会增加复杂性。
- en: Understanding Zero-Copy[¶](#understanding-zero-copy "Permanent link")
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解零拷贝[¶](#understanding-zero-copy "永久链接")
- en: In the usual I/O path, data moves back and forth between user space and kernel
    space—first copied into a kernel buffer, then into your application’s buffer,
    or the other way around. It works, but it’s wasteful. Every copy burns CPU cycles
    and clogs up memory bandwidth. Zero-copy changes that. Instead of bouncing data
    between buffers, it lets applications work directly with what’s already in place—no
    detours, no extra copies. The result? Lower CPU load, better use of memory, and
    faster I/O, especially when throughput or latency actually matter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规 I/O 路径中，数据在用户空间和内核空间之间来回移动——首先复制到内核缓冲区，然后到你的应用程序的缓冲区，或者反过来。这虽然可行，但很浪费。每次拷贝都会消耗
    CPU 周期并阻塞内存带宽。零拷贝技术改变了这一点。它不是在缓冲区之间弹跳数据，而是让应用程序直接与现有的内容工作——没有绕路，没有额外的拷贝。结果？更低的
    CPU 负载，更好的内存使用，以及更快的 I/O，尤其是在吞吐量或延迟真正重要的时候。
- en: Common Zero-Copy Techniques in Go[¶](#common-zero-copy-techniques-in-go "Permanent
    link")
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的常见零拷贝技术[¶](#common-zero-copy-techniques-in-go "永久链接")
- en: Using `io.Reader` and `io.Writer` Interfaces[¶](#using-ioreader-and-iowriter-interfaces
    "Permanent link")
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `io.Reader` 和 `io.Writer` 接口[¶](#using-ioreader-and-iowriter-interfaces "永久链接")
- en: Using interfaces like `io.Reader` and `io.Writer` gives you fine-grained control
    over how data flows. Instead of spinning up new buffers every time, you can reuse
    existing ones and keep memory usage steady. In practice, this avoids unnecessary
    garbage collection pressure and keeps your I/O paths clean and efficient—especially
    when you’re dealing with high-throughput or streaming workloads.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `io.Reader` 和 `io.Writer` 等接口可以让你对数据流有更精细的控制。不必每次都启动新的缓冲区，你可以重用现有的缓冲区，并保持内存使用稳定。在实践中，这避免了不必要的垃圾收集压力，并保持了你的
    I/O 路径清洁高效——尤其是在处理高吞吐量或流式工作负载时。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`io.CopyBuffer` reuses a provided buffer, avoiding repeated allocations and
    intermediate copies. An in-depth `io.CopyBuffer` explanation is [available on
    SO](https://stackoverflow.com/questions/71082021/what-exactly-is-buffer-last-parameter-in-io-copybuffer).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.CopyBuffer` 重新使用提供的缓冲区，避免了重复分配和中间拷贝。关于 `io.CopyBuffer` 的深入解释可以在 SO 上找到：[什么是
    io.CopyBuffer 中的 buffer 最后一个参数？](https://stackoverflow.com/questions/71082021/what-exactly-is-buffer-last-parameter-in-io-copybuffer)。'
- en: Slicing for Efficient Data Access[¶](#slicing-for-efficient-data-access "Permanent
    link")
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为高效数据访问进行切片[¶](#slicing-for-efficient-data-access "永久链接")
- en: 'Slicing large byte arrays or buffers instead of copying data into new slices
    is a powerful zero-copy strategy:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将数据复制到新的切片中，不如切片大型字节数组或缓冲区是一种强大的零拷贝策略：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Slices in Go are inherently zero-copy since they reference the underlying array.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的切片天生就是零拷贝的，因为它们引用了底层的数组。
- en: Memory Mapping (`mmap`)[¶](#memory-mapping-mmap "Permanent link")
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存映射 (`mmap`)[¶](#memory-mapping-mmap "永久链接")
- en: 'Using memory mapping enables direct access to file contents without explicit
    read operations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存映射可以直接访问文件内容，而无需显式读取操作：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This approach maps file contents directly into memory, entirely eliminating
    copying between kernel and user-space.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法直接将文件内容映射到内存中，完全消除了内核和用户空间之间的拷贝。
- en: Benchmarking Impact[¶](#benchmarking-impact "Permanent link")
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试影响[¶](#benchmarking-impact "永久链接")
- en: 'Here''s a basic benchmark illustrating performance differences between explicit
    copying and zero-copy slicing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个基本的基准测试，说明了显式拷贝和零拷贝切片之间的性能差异：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In `BenchmarkCopy`, each iteration copies a 64KB buffer into a fresh slice—allocating
    memory and duplicating data every time. That cost adds up fast. `BenchmarkSlice`,
    on the other hand, just re-slices the same buffer—no allocation, no copying, just
    new view on the same data. The difference is night and day. When performance matters,
    avoiding copies isn’t just a micro-optimization—it’s fundamental.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BenchmarkCopy` 中，每次迭代都会将 64KB 缓冲区复制到一个新的切片中——每次都会分配内存和复制数据。这种成本很快就会累积起来。另一方面，`BenchmarkSlice`
    只是对相同的缓冲区进行重新切片——没有分配，没有复制，只是对相同数据的新的视图。这种差异是巨大的。当性能至关重要时，避免复制不仅仅是一个微优化——这是基础。
- en: Info
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: These two functions are not equivalent in behavior—`BenchmarkCopy` makes an
    actual deep copy of the buffer, while `BenchmarkSlice` only creates a new slice
    header pointing to the same underlying data. This benchmark is not comparing functional
    correctness but is intentionally contrasting performance characteristics to highlight
    the cost of unnecessary copying.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数在行为上并不相同——`BenchmarkCopy` 对缓冲区进行了实际的深度复制，而 `BenchmarkSlice` 只创建了一个指向相同底层数据的新切片头。这个基准测试并不是比较功能正确性，而是有意对比性能特性，以突出不必要的复制的成本。
- en: '| Benchmark | Time per op (ns) | Bytes per op | Allocs per op |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 基准测试 | 每次操作时间 (ns) | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| BenchmarkCopy | 4,246 | 65536 | 1 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkCopy | 4,246 | 65536 | 1 |'
- en: '| BenchmarkSlice | 0.592 | 0 | 0 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| BenchmarkSlice | 0.592 | 0 | 0 |'
- en: 'File I/O: Memory Mapping vs. Standard Read[¶](#file-io-memory-mapping-vs-standard-read
    "Permanent link")'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件 I/O：内存映射与标准读取[¶](#file-io-memory-mapping-vs-standard-read "永久链接")
- en: We also benchmarked file reading performance using `os.ReadAt` versus `mmap.Open`
    for a 4MB binary file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `os.ReadAt` 与 `mmap.Open` 对 4MB 二进制文件的文件读取性能进行了基准测试。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <details class="info"><summary>How to run the benchmark</summary>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="info"><summary>如何运行基准测试</summary>
- en: 'To run the benchmark involving `mmap`, you’ll need to install the required
    package and create a test file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行涉及 `mmap` 的基准测试，您需要安装所需的软件包并创建一个测试文件：
- en: '[PRE5]</details>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]</details>'
- en: Benchmark Results
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果
- en: '| Benchmark | Time per op (ns) | Bytes per op | Allocs per op |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 基准测试 | 每次操作时间 (ns) | 每次操作字节数 | 每次操作分配数 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ReadWithCopy | 94,650 | 0 | 0 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| ReadWithCopy | 94,650 | 0 | 0 |'
- en: '| ReadWithMmap | 50,082 | 0 | 0 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| ReadWithMmap | 50,082 | 0 | 0 |'
- en: The memory-mapped version (`mmap`) is nearly 2× faster than the standard read
    call. This illustrates how zero-copy access through memory mapping can substantially
    reduce read latency and CPU usage for large files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射版本（`mmap`）比标准读取调用快近 2 倍。这说明了通过内存映射实现的零拷贝访问如何显著减少大文件的读取延迟和 CPU 使用率。
- en: <details class="example"><summary>Show the complete benchmark file</summary>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="example"><summary>显示完整的基准测试文件</summary>
- en: '[PRE6]</details>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]</details>'
- en: When to Use Zero-Copy[¶](#when-to-use-zero-copy "Permanent link")
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用零拷贝[¶](#when-to-use-zero-copy "永久链接")
- en: 'Zero-copy techniques are highly beneficial for:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 零拷贝技术对于以下方面高度有益：
- en: Network servers handling large amounts of concurrent data streams. Avoiding
    unnecessary memory copies helps reduce CPU usage and latency, especially under
    high load.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大量并发数据流的网络服务器。避免不必要的内存复制有助于减少 CPU 使用率和延迟，尤其是在高负载下。
- en: Applications with heavy I/O operations like file streaming or real-time data
    processing. Zero-copy allows data to move through the system efficiently without
    redundant allocations or copies.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有大量 I/O 操作的应用程序，如文件流或实时数据处理。零拷贝允许数据在系统中高效地移动，无需冗余分配或复制。
- en: Warning
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Zero-copy isn’t a free win. Slices share underlying memory, so reusing them
    means you’re also sharing state. If one part of your code changes the data while
    another is still reading it, you’re setting yourself up for subtle, hard-to-track
    bugs. This kind of shared memory requires discipline—clear ownership and tight
    control. It also adds complexity, which might not be worth it unless the performance
    gains are real and measurable. Always benchmark before committing to it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 零拷贝并非免费的胜利。切片共享底层内存，因此重用它们意味着您也在共享状态。如果代码的一部分在另一部分仍在读取数据时更改了数据，您就会为自己设置微妙且难以追踪的bug。这种共享内存需要纪律——清晰的拥有权和严格控制。它还增加了复杂性，除非性能提升是真实且可衡量的，否则可能不值得。始终在做出决定之前进行基准测试。
- en: Real-World Use Cases and Libraries[¶](#real-world-use-cases-and-libraries "Permanent
    link")
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际应用案例和库[¶](#real-world-use-cases-and-libraries "永久链接")
- en: 'Zero-copy strategies aren''t just theoretical—they''re used in production by
    performance-critical Go systems:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 零拷贝策略不仅仅是理论上的——它们被性能关键型 Go 系统在生产中实际使用：
- en: '[fasthttp](https://github.com/valyala/fasthttp): A high-performance HTTP server
    designed to avoid allocations. It returns slices directly and avoids `string`
    conversions to minimize copying.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fasthttp](https://github.com/valyala/fasthttp)：一个高性能的 HTTP 服务器，旨在避免分配。它直接返回切片，并避免
    `string` 转换来最小化复制。'
- en: '[gRPC-Go](https://github.com/grpc/grpc-go): Uses internal buffer pools and
    avoids deep copying of large request/response messages to reduce GC pressure.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gRPC-Go](https://github.com/grpc/grpc-go)：使用内部缓冲池，避免对大型请求/响应消息进行深度复制，以减少垃圾回收压力。'
- en: '[MinIO](https://github.com/minio/minio): An object storage system that streams
    data directly between disk and network using `io.Reader` without unnecessary buffer
    replication.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MinIO](https://github.com/minio/minio)：一个对象存储系统，它使用 `io.Reader` 在磁盘和网络之间直接传输数据，而不进行不必要的缓冲区复制。'
- en: '[Protobuf](https://github.com/protocolbuffers/protobuf) and [MsgPack](https://github.com/vmihailenco/msgpack)
    libraries: Efficient serialization frameworks like `google.golang.org/protobuf`
    and `vmihailenco/msgpack` support decoding directly into user-managed buffers.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Protobuf](https://github.com/protocolbuffers/protobuf) 和 [MsgPack](https://github.com/vmihailenco/msgpack)
    库：高效的序列化框架，如 `google.golang.org/protobuf` 和 `vmihailenco/msgpack`，支持直接解码到用户管理的缓冲区。'
- en: '[InfluxDB](https://github.com/influxdata/influxdb) and [Badger](https://github.com/hypermodeinc/badger):
    These storage engines use `mmap` extensively for fast, zero-copy access to database
    files.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[InfluxDB](https://github.com/influxdata/influxdb) 和 [Badger](https://github.com/hypermodeinc/badger)：这些存储引擎广泛使用
    `mmap` 以实现快速、零拷贝访问数据库文件。'
- en: These libraries show how zero-copy techniques help reduce allocations, GC overhead,
    and system call frequency—all while increasing throughput.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库展示了零拷贝技术如何帮助减少分配、垃圾回收开销和系统调用频率，同时提高吞吐量。
