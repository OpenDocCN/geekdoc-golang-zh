- en: Patterns and Techniques for Writing High-Performance Applications with Go¶
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/](https://goperf.dev/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The **Go App Optimization Guide** is a long-form series about making Go services
    faster in ways that actually translate to production. No folklore. No “best practices”
    without numbers. The focus is on understanding what the runtime is doing, where
    the costs come from, and how to reduce them without turning your codebase into
    a science experiment.
  prefs: []
  type: TYPE_NORMAL
- en: This guide is written for people running real systems. APIs under sustained
    traffic, background pipelines that move serious volume, and distributed services
    where tail latency matters. If your Go code runs only in benchmarks or toy projects,
    most of this will feel unnecessary. If it runs under load, it probably won’t.
  prefs: []
  type: TYPE_NORMAL
- en: Go deliberately hides much of its low-level control. You don’t get explicit
    memory management, and you don’t get to micromanage threads. What you do get is
    enough visibility to reason about allocations, scheduling, and I/O behavior. Combined
    with solid tooling, that’s usually sufficient to build fast, predictable systems.
    The articles in this series stay in that space. Practical leverage, not theoretical
    perfection.
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is not cleverness. It’s boring code that stays fast when traffic
    spikes and doesn’t fall apart six months later.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1\. [Common Go Patterns for Performance](01-common-patterns/)[¶](#part-1-common-go-patterns-for-performance
    "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section covers performance patterns that show up repeatedly in real Go
    codebases. Not exhaustive, not academic. Just the areas where small, disciplined
    changes tend to pay off:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `sync.Pool` where it actually helps, not everywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing allocation pressure on hot paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Struct layout, padding, and why cache behavior still matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping error handling off the fast path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces without accidental indirection costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing slices and sorting in place instead of reallocating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete examples and measurements back each pattern. If there’s no observable
    impact, it doesn’t belong here.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2\. [High-Performance Networking in Go](02-networking/)[¶](#part-2-high-performance-networking-in-go
    "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This part focuses on networked services and the constraints that show up once
    concurrency stops being theoretical. The standard library gets you surprisingly
    far, but defaults are not magic. At scale, details matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient use of `net/http`, `net.Conn`, and connection pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling thousands of concurrent connections without resource collapse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduler behavior, `GOMAXPROCS`, and OS-level mechanics like epoll and kqueue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backpressure, load shedding, and failure containment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding memory leaks in long-lived connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trade-offs between TCP, HTTP/2, gRPC, and QUIC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section is intentionally more theoretical, but still grounded in tests
    and measurements where that’s possible. Networking behavior depends heavily on
    workload shape and environmental details, including kernel settings, network topology,
    deployment model, and hardware. Universal rules are rare. When conclusions rely
    on assumptions rather than guarantees, those assumptions are stated explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3\. TBD[¶](#part-3-tbd "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scope is still being defined, but the direction is clear: runtime behavior
    under sustained load, profiling and observability that work in real systems, and
    failure modes that don’t show up in benchmarks. As with the rest of the guide,
    the emphasis will be on measured behavior and trade-offs, not generic advice.'
  prefs: []
  type: TYPE_NORMAL
- en: Who This Is For[¶](#who-this-is-for "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This guide is aimed at engineers who care about how their Go programs behave
    after deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: Backend engineers running services where latency and throughput matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams pushing Go into performance-critical paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers who want to understand Go’s trade-offs instead of guessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone tired of profiling after incidents instead of before them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More articles are coming. At the end, this is one of my favorite pet projects.
    As the series grows, it will stay focused on applied performance work rather than
    abstract tuning advice. If that’s useful to you, bookmark it and come back later.
  prefs: []
  type: TYPE_NORMAL
