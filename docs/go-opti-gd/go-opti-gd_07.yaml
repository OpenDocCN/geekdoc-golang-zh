- en: Struct Field Alignment¶
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/01-common-patterns/fields-alignment/](https://goperf.dev/01-common-patterns/fields-alignment/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When optimizing Go programs for performance, struct layout and memory alignment
    often go unnoticed—yet they have a measurable impact on memory usage and cache
    efficiency. Go automatically aligns struct fields based on platform-specific rules,
    inserting padding to satisfy alignment constraints. Understanding and controlling
    memory alignment isn’t just a low-level detail—it can have a real impact on how
    your Go programs perform, especially in tight loops or high-throughput systems.
    Proper alignment can reduce the overall memory footprint, make better use of CPU
    caches, and eliminate subtle performance penalties that add up under load.
  prefs: []
  type: TYPE_NORMAL
- en: Why Alignment Matters[¶](#why-alignment-matters "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern CPUs are tuned for predictable memory access. When struct fields are
    misaligned or split across cache lines, the processor often has to do extra work
    to fetch the data. That can mean additional memory cycles, more cache misses,
    and slower performance overall. These costs are easy to overlook in everyday code
    but show up quickly in code that’s sensitive to throughput or latency. In Go,
    struct fields are aligned according to their type requirements, and the compiler
    inserts padding bytes to meet these constraints. If fields are arranged without
    care, unnecessary padding may inflate struct size significantly, affecting memory
    use and bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On a 64-bit system, `PoorlyAligned` requires 24 bytes due to the padding between
    fields, whereas `WellAligned` fits into 16 bytes by ordering fields from largest
    to smallest alignment requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking Impact[¶](#benchmarking-impact "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We benchmarked both struct layouts by allocating 10 million instances of each
    and measuring allocation time and memory usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Benchmark Results
  prefs: []
  type: TYPE_NORMAL
- en: '| Benchmark | Iterations | Time per op (ns) | Bytes per op | Allocs per op
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PoorlyAligned-14 | 177 | 20,095,621 | 240,001,029 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| WellAligned-14 | 186 | 19,265,714 | 160,006,148 | 1 |'
  prefs: []
  type: TYPE_TB
- en: In a test with 10 million structs, the `WellAligned` version used 80MB less
    memory than its poorly aligned counterpart—and it also ran a bit faster. This
    isn’t just about saving RAM; it shows how struct layout directly affects allocation
    behavior and memory bandwidth. When you’re working with large volumes of data
    or performance-critical paths, reordering fields for better alignment can lead
    to measurable gains with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding False Sharing in Concurrent Workloads[¶](#avoiding-false-sharing-in-concurrent-workloads
    "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to memory layout efficiency, struct alignment also plays a crucial
    role in concurrent systems. When multiple goroutines access different fields of
    the same struct that reside on the same CPU cache line, they may suffer from false
    sharing—where changes to one field cause invalidations in the other, even if logically
    unrelated.
  prefs: []
  type: TYPE_NORMAL
- en: On modern CPUs, a typical cache line is 64 bytes wide. When a struct is accessed
    in memory, the CPU loads the entire cache line that contains it, not just the
    specific field. This means that two unrelated fields within the same 64-byte block
    will both reside in the same line—even if they are used independently by separate
    goroutines. If one goroutine writes to its field, the cache line becomes invalidated
    and must be reloaded on the other core, leading to degraded performance due to
    false sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, we compared two structs—one vulnerable to false sharing, and
    another with padding to separate fields across cache lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Each field is incremented by a separate goroutine 1 million times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`FalseSharing` and `NoFalseSharing` benchmarks are identical, except we will
    use `SharedCounterGood` for the `NoFalseSharing` benchmark.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Benchmark Results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Benchmark | Time per op (ns) | Bytes per op | Allocs per op |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| FalseSharing | 996,234 | 55 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| NoFalseSharing | 958,180 | 58 | 2 |'
  prefs: []
  type: TYPE_TB
- en: Placing padding between the two fields prevented false sharing, resulting in
    a measurable performance improvement. The version with padding completed ~3.8%
    faster (the value could vary between re-runs from 3% to 6%), which can make a
    difference in tight concurrent loops or high-frequency counters. It also shows
    how false sharing may unpredictably affect memory use due to invalidation overhead.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="example"><summary>Show the complete benchmark file</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: When To Align Structs[¶](#when-to-align-structs "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always align structs. It's free to implement and often leads to better memory
    efficiency without changing any logic—only field order needs to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guidelines for struct alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: Order fields from largest to smallest. Starting with larger fields helps the
    compiler avoid inserting padding to meet alignment requirements. Smaller fields
    can fill in the gaps naturally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group fields of the same size together. This lets the compiler pack them more
    efficiently and minimizes wasted space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert padding intentionally when needed. In concurrent code, separating fields
    that are accessed by different goroutines can prevent false sharing—a subtle but
    costly issue where multiple goroutines compete over the same cache line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid interleaving small and large fields. Mixing sizes leads to inefficient
    memory usage due to extra alignment padding between fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the [fieldalignment](https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment)
    linter to verify. This tool helps catch suboptimal layouts automatically during
    development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
