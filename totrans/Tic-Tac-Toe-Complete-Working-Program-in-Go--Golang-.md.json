["```\nPlayer 1 Move with Symbol * at Position X:1 Y:1\n...\n.*.\n...\n\nPlayer 2 Move with Symbol o at Position X:1 Y:2\n...\n.*o\n...\n\nPlayer 1 Move with Symbol * at Position X:2 Y:0\n...\n.*o\n*..\n\nPlayer 2 Move with Symbol o at Position X:0 Y:2\n..o\n.*o\n*..\n\nPlayer 1 Move with Symbol * at Position X:2 Y:2\n..o\n.*o\n*.*\n\nPlayer 2 Move with Symbol o at Position X:0 Y:0\no.o\n.*o\n*.*\n\nPlayer 1 Move with Symbol * at Position X:2 Y:1\no.o\n.*o\n***\n\nFirst Player Win\no.o\n.*o\n***\n```", "```\npackage main\n\ntype Symbol uint8\n\nconst (\n    Cross Symbol = iota\n    Circle\n    Dot\n)\n```", "```\npackage main\n\ntype iPlayer interface {\n    getSymbol() Symbol\n    getNextMove() (int, int, error)\n    getID() int\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\nvar (\n\tMovesPlayer1 = [4][2]int{{1, 1}, {2, 0}, {2, 2}, {2, 1}}\n\tMovesPlayer2 = [4][2]int{{1, 2}, {0, 2}, {0, 0}, {0, 0}}\n)\n\ntype humanPlayer struct {\n\tsymbol Symbol\n\tindex  int\n\tid     int\n}\n\nfunc (h *humanPlayer) getSymbol() Symbol {\n\treturn h.symbol\n}\n\nfunc (h *humanPlayer) getNextMove() (int, int, error) {\n\tif h.symbol == Cross {\n\t\th.index = h.index + 1\n\t\treturn MovesPlayer1[h.index-1][0], MovesPlayer1[h.index-1][1], nil\n\t} else if h.symbol == Circle {\n\t\th.index = h.index + 1\n\t\treturn MovesPlayer2[h.index-1][0], MovesPlayer2[h.index-1][1], nil\n\t}\n\treturn 0, 0, fmt.Errorf(\"Invalid Symbol\")\n}\n\nfunc (h *humanPlayer) getID() int {\n\treturn h.id\n}\n```", "```\npackage main\n\ntype computerPlayer struct {\n\tsymbol Symbol\n\tid     int\n}\n\nfunc (c *computerPlayer) getSymbol() Symbol {\n\treturn c.symbol\n}\n\nfunc (c *computerPlayer) getNextMove() (int, int, error) {\n\t//To be implemented\n\treturn 0, 0, nil\n}\n\nfunc (c *computerPlayer) getID() int {\n\treturn c.id\n}\n```", "```\npackage main\n\ntype GameStatus uint8\n\nconst (\n\tGameInProgress GameStatus = iota\n\tGameDraw\n\tFirstPlayerWin\n\tSecondPlayerWin\n)\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype board struct {\n\tsquare    [][]Symbol\n\tdimension int\n}\n\nfunc (b *board) printBoard() {\n\tfor i := 0; i < b.dimension; i++ {\n\t\tfor j := 0; j < b.dimension; j++ {\n\t\t\tif b.square[i][j] == Dot {\n\t\t\t\tfmt.Print(\".\")\n\t\t\t} else if b.square[i][j] == Cross {\n\t\t\t\tfmt.Print(\"*\")\n\t\t\t} else {\n\t\t\t\tfmt.Print(\"o\")\n\t\t\t}\n\n\t\t}\n\t\tfmt.Println(\"\")\n\t}\n}\n\nfunc (b *board) markSymbol(i, j int, symbol Symbol) (bool, Symbol, error) {\n\tif i > b.dimension || j > b.dimension {\n\t\treturn false, Dot, fmt.Errorf(\"index input is greater than dimension\")\n\t}\n\tif b.square[i][j] != Dot {\n\t\treturn false, Dot, fmt.Errorf(\"input square already marked\")\n\t}\n\tif symbol != Cross && symbol != Circle {\n\t\treturn false, Dot, fmt.Errorf(\"incorrect Symbol\")\n\t}\n\tb.square[i][j] = symbol\n\twin := b.checkWin(i, j, symbol)\n\n\treturn win, symbol, nil\n}\n\nfunc (b *board) checkWin(i, j int, symbol Symbol) bool {\n\t//Check Row\n\trowMatch := true\n\tfor k := 0; k < b.dimension; k++ {\n\t\tif b.square[i][k] != symbol {\n\t\t\trowMatch = false\n\t\t}\n\t}\n\n\tif rowMatch {\n\t\treturn rowMatch\n\t}\n\n\t//Check Row\n\tcolumnMatch := true\n\tfor k := 0; k < b.dimension; k++ {\n\t\tif b.square[k][j] != symbol {\n\t\t\tcolumnMatch = false\n\t\t}\n\t}\n\n\tif columnMatch {\n\t\treturn columnMatch\n\t}\n\n\t//Check diagonal\n\tdiagonalMatch := false\n\tif i == j {\n\t\tdiagonalMatch = true\n\t\tfor k := 0; k < b.dimension; k++ {\n\t\t\tif b.square[k][k] != symbol {\n\t\t\t\tdiagonalMatch = false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn diagonalMatch\n\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype game struct {\n    board           *board\n    firstPlayer     iPlayer\n    secondPlayer    iPlayer\n    firstPlayerTurn bool\n    moveIndex       int\n    gameStatus      GameStatus\n}\n\nfunc initGame(b *board, p1, p2 iPlayer) *game {\n    game := &game{\n        board:           b,\n        firstPlayer:     p1,\n        secondPlayer:    p2,\n        firstPlayerTurn: true,\n        gameStatus:      GameInProgress,\n    }\n    return game\n}\n\nfunc (g *game) play() error {\n    var win bool\n    var symbol Symbol\n    for {\n        if g.firstPlayerTurn {\n            x, y, err := g.firstPlayer.getNextMove()\n            if err != nil {\n                return err\n            }\n            win, symbol, err = g.board.markSymbol(x, y, g.firstPlayer.getSymbol())\n            if err != nil {\n                return err\n            }\n            g.firstPlayerTurn = false\n            g.printMove(g.firstPlayer, x, y)\n        } else {\n            x, y, err := g.secondPlayer.getNextMove()\n            if err != nil {\n                return err\n            }\n            win, symbol, err = g.board.markSymbol(x, y, g.secondPlayer.getSymbol())\n            if err != nil {\n                return err\n            }\n            g.firstPlayerTurn = true\n            g.printMove(g.secondPlayer, x, y)\n        }\n        g.moveIndex = g.moveIndex + 1\n        g.setGameStatus(win, symbol)\n        if g.gameStatus != GameInProgress {\n            break\n        }\n    }\n    return nil\n}\n\nfunc (g *game) setGameStatus(win bool, symbol Symbol) {\n    if win {\n        if g.firstPlayer.getSymbol() == symbol {\n            g.gameStatus = FirstPlayerWin\n            return\n        } else if g.secondPlayer.getSymbol() == symbol {\n            g.gameStatus = SecondPlayerWin\n            return\n        }\n    }\n    if g.moveIndex == g.board.dimension*g.board.dimension {\n        g.gameStatus = GameDraw\n        return\n    }\n    g.gameStatus = GameInProgress\n}\n\nfunc (g *game) printMove(player iPlayer, x, y int) {\n\tsymbolString := \"\"\n\tsymbol := player.getSymbol()\n\tif symbol == Cross {\n\t\tsymbolString = \"*\"\n\t} else if symbol == Circle {\n\t\tsymbolString = \"o\"\n\t}\n\tfmt.Printf(\"Player %d Move with Symbol %s at Position X:%d Y:%d\\n\", player.getID(), symbolString, x, y)\n\tg.board.printBoard()\n\tfmt.Println(\"\")\n}\n\nfunc (g *game) printResult() {\n    switch g.gameStatus {\n    case GameInProgress:\n        fmt.Println(\"Game in Between\")\n    case GameDraw:\n        fmt.Println(\"Game Drawn\")\n    case FirstPlayerWin:\n        fmt.Println(\"First Player Win\")\n    case SecondPlayerWin:\n        fmt.Println(\"Second Player Win\")\n    default:\n        fmt.Println(\"Invalid Game Status\")\n    }\n    g.board.printBoard()\n}\n```", "```\nPlayer 1 Move with Symbol * at Position X:1 Y:1\n...\n.*.\n...\n\nPlayer 2 Move with Symbol o at Position X:1 Y:2\n...\n.*o\n...\n\nPlayer 1 Move with Symbol * at Position X:2 Y:0\n...\n.*o\n*..\n\nPlayer 2 Move with Symbol o at Position X:0 Y:2\n..o\n.*o\n*..\n\nPlayer 1 Move with Symbol * at Position X:2 Y:2\n..o\n.*o\n*.*\n\nPlayer 2 Move with Symbol o at Position X:0 Y:0\no.o\n.*o\n*.*\n\nPlayer 1 Move with Symbol * at Position X:2 Y:1\no.o\n.*o\n***\n\nFirst Player Win\no.o\n.*o\n***\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype Symbol uint8\n\nconst (\n\tCross Symbol = iota\n\tCircle\n\tDot\n)\n\ntype GameStatus uint8\n\nconst (\n\tGameInProgress GameStatus = iota\n\tGameDraw\n\tFirstPlayerWin\n\tSecondPlayerWin\n)\n\ntype iPlayer interface {\n\tgetSymbol() Symbol\n\tgetNextMove() (int, int, error)\n\tgetID() int\n}\n\nvar (\n\tMovesPlayer1 = [4][2]int{{1, 1}, {2, 0}, {2, 2}, {2, 1}}\n\tMovesPlayer2 = [4][2]int{{1, 2}, {0, 2}, {0, 0}, {0, 0}}\n)\n\ntype humanPlayer struct {\n\tsymbol Symbol\n\tindex  int\n\tid     int\n}\n\nfunc (h *humanPlayer) getSymbol() Symbol {\n\treturn h.symbol\n}\n\nfunc (h *humanPlayer) getNextMove() (int, int, error) {\n\tif h.symbol == Cross {\n\t\th.index = h.index + 1\n\t\treturn MovesPlayer1[h.index-1][0], MovesPlayer1[h.index-1][1], nil\n\t} else if h.symbol == Circle {\n\t\th.index = h.index + 1\n\t\treturn MovesPlayer2[h.index-1][0], MovesPlayer2[h.index-1][1], nil\n\t}\n\treturn 0, 0, fmt.Errorf(\"Invalid Symbol\")\n}\n\nfunc (h *humanPlayer) getID() int {\n\treturn h.id\n}\n\ntype computerPlayer struct {\n\tsymbol Symbol\n\tid     int\n}\n\nfunc (c *computerPlayer) getSymbol() Symbol {\n\treturn c.symbol\n}\n\nfunc (c *computerPlayer) getNextMove() (int, int, error) {\n\t//To be implemented\n\treturn 0, 0, nil\n}\n\nfunc (c *computerPlayer) getID() int {\n\treturn c.id\n}\n\ntype board struct {\n\tsquare    [][]Symbol\n\tdimension int\n}\n\nfunc (b *board) printBoard() {\n\tfor i := 0; i < b.dimension; i++ {\n\t\tfor j := 0; j < b.dimension; j++ {\n\t\t\tif b.square[i][j] == Dot {\n\t\t\t\tfmt.Print(\".\")\n\t\t\t} else if b.square[i][j] == Cross {\n\t\t\t\tfmt.Print(\"*\")\n\t\t\t} else {\n\t\t\t\tfmt.Print(\"o\")\n\t\t\t}\n\n\t\t}\n\t\tfmt.Println(\"\")\n\t}\n}\n\nfunc (b *board) markSymbol(i, j int, symbol Symbol) (bool, Symbol, error) {\n\tif i > b.dimension || j > b.dimension {\n\t\treturn false, Dot, fmt.Errorf(\"index input is greater than dimension\")\n\t}\n\tif b.square[i][j] != Dot {\n\t\treturn false, Dot, fmt.Errorf(\"input square already marked\")\n\t}\n\tif symbol != Cross && symbol != Circle {\n\t\treturn false, Dot, fmt.Errorf(\"incorrect Symbol\")\n\t}\n\tb.square[i][j] = symbol\n\twin := b.checkWin(i, j, symbol)\n\n\treturn win, symbol, nil\n}\n\nfunc (b *board) checkWin(i, j int, symbol Symbol) bool {\n\t//Check Row\n\trowMatch := true\n\tfor k := 0; k < b.dimension; k++ {\n\t\tif b.square[i][k] != symbol {\n\t\t\trowMatch = false\n\t\t}\n\t}\n\n\tif rowMatch {\n\t\treturn rowMatch\n\t}\n\n\t//Check Row\n\tcolumnMatch := true\n\tfor k := 0; k < b.dimension; k++ {\n\t\tif b.square[k][j] != symbol {\n\t\t\tcolumnMatch = false\n\t\t}\n\t}\n\n\tif columnMatch {\n\t\treturn columnMatch\n\t}\n\n\t//Check diagonal\n\tdiagonalMatch := false\n\tif i == j {\n\t\tdiagonalMatch = true\n\t\tfor k := 0; k < b.dimension; k++ {\n\t\t\tif b.square[k][k] != symbol {\n\t\t\t\tdiagonalMatch = false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn diagonalMatch\n\n}\n\ntype game struct {\n\tboard           *board\n\tfirstPlayer     iPlayer\n\tsecondPlayer    iPlayer\n\tfirstPlayerTurn bool\n\tmoveIndex       int\n\tgameStatus      GameStatus\n}\n\nfunc initGame(b *board, p1, p2 iPlayer) *game {\n\tgame := &game{\n\t\tboard:           b,\n\t\tfirstPlayer:     p1,\n\t\tsecondPlayer:    p2,\n\t\tfirstPlayerTurn: true,\n\t\tgameStatus:      GameInProgress,\n\t}\n\treturn game\n}\n\nfunc (g *game) play() error {\n\tvar win bool\n\tvar symbol Symbol\n\tfor {\n\t\tif g.firstPlayerTurn {\n\t\t\tx, y, err := g.firstPlayer.getNextMove()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\twin, symbol, err = g.board.markSymbol(x, y, g.firstPlayer.getSymbol())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.firstPlayerTurn = false\n\t\t\tg.printMove(g.firstPlayer, x, y)\n\t\t} else {\n\t\t\tx, y, err := g.secondPlayer.getNextMove()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\twin, symbol, err = g.board.markSymbol(x, y, g.secondPlayer.getSymbol())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg.firstPlayerTurn = true\n\t\t\tg.printMove(g.secondPlayer, x, y)\n\t\t}\n\t\tg.moveIndex = g.moveIndex + 1\n\n\t\tg.setGameStatus(win, symbol)\n\t\tif g.gameStatus != GameInProgress {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (g *game) setGameStatus(win bool, symbol Symbol) {\n\tif win {\n\t\tif g.firstPlayer.getSymbol() == symbol {\n\t\t\tg.gameStatus = FirstPlayerWin\n\t\t\treturn\n\t\t} else if g.secondPlayer.getSymbol() == symbol {\n\t\t\tg.gameStatus = SecondPlayerWin\n\t\t\treturn\n\t\t}\n\t}\n\tif g.moveIndex == g.board.dimension*g.board.dimension {\n\t\tg.gameStatus = GameDraw\n\t\treturn\n\t}\n\tg.gameStatus = GameInProgress\n}\n\nfunc (g *game) printMove(player iPlayer, x, y int) {\n\tsymbolString := \"\"\n\tsymbol := player.getSymbol()\n\tif symbol == Cross {\n\t\tsymbolString = \"*\"\n\t} else if symbol == Circle {\n\t\tsymbolString = \"o\"\n\t}\n\tfmt.Printf(\"Player %d Move with Symbol %s at Position X:%d Y:%d\\n\", player.getID(), symbolString, x, y)\n\tg.board.printBoard()\n\tfmt.Println(\"\")\n}\n\nfunc (g *game) printResult() {\n\tswitch g.gameStatus {\n\tcase GameInProgress:\n\t\tfmt.Println(\"Game in Between\")\n\tcase GameDraw:\n\t\tfmt.Println(\"Game Drawn\")\n\tcase FirstPlayerWin:\n\t\tfmt.Println(\"First Player Win\")\n\tcase SecondPlayerWin:\n\t\tfmt.Println(\"Second Player Win\")\n\tdefault:\n\t\tfmt.Println(\"Invalid Game Status\")\n\t}\n\tg.board.printBoard()\n}\n\nfunc main() {\n\n\tboard := &board{\n\t\tsquare:    [][]Symbol{{Dot, Dot, Dot}, {Dot, Dot, Dot}, {Dot, Dot, Dot}},\n\t\tdimension: 3,\n\t}\n\n\tplayer1 := &humanPlayer{\n\t\tsymbol: Cross,\n\t\tid:     1,\n\t}\n\n\tplayer2 := &humanPlayer{\n\t\tsymbol: Circle,\n\t\tid:     2,\n\t}\n\n\tgame := initGame(board, player1, player2)\n\tgame.play()\n\tgame.printResult()\n\n}\n```", "```\nPlayer 1 Move with Symbol * at Position X:1 Y:1\n...\n.*.\n...\n\nPlayer 2 Move with Symbol o at Position X:1 Y:2\n...\n.*o\n...\n\nPlayer 1 Move with Symbol * at Position X:2 Y:0\n...\n.*o\n*..\n\nPlayer 2 Move with Symbol o at Position X:0 Y:2\n..o\n.*o\n*..\n\nPlayer 1 Move with Symbol * at Position X:2 Y:2\n..o\n.*o\n*.*\n\nPlayer 2 Move with Symbol o at Position X:0 Y:0\no.o\n.*o\n*.*\n\nPlayer 1 Move with Symbol * at Position X:2 Y:1\no.o\n.*o\n***\n\nFirst Player Win\no.o\n.*o\n***\n```"]