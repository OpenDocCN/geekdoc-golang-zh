- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:03:16'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: Bridge Design Pattern in Go (Golang)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/bridge-design-pattern-in-go/](https://golangbyexample.com/bridge-design-pattern-in-go/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note: Interested in understanding how all other design patterns can be implemented
    in GO. Please see this full reference – [All Design Patterns in Go (Golang)](https://golangbyexample.com/all-design-patterns-golang/)'
  prefs: []
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Introduction:](#Introduction "Introduction:")'
  prefs: []
  type: TYPE_NORMAL
- en: '[UML Diagram:](#UML_Diagram "UML Diagram:")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping ](#Mapping "Mapping ")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Practical Example](#Practical_Example "Practical Example")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Full Working Code:](#Full_Working_Code "Full Working Code:")*  *## **Introduction:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge design pattern is a structural design pattern that allows the separation
    of abstraction from its implementation. Sounds confusing? Don’t worry, it will
    be more clear as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern suggests dividing a large class into two separate hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction – It is an interface and children of the **Abstraction** are referred
    to as **Refined Abstraction.** The abstraction contains a reference to the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation – It is also an interface and children’s of the **Implementation**
    are referred to as **Concrete Implementation**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction hierarchy is being referred to by clients without worrying about
    the implementation. Let’s take an example. Assume you have two types of computer
    **mac** and **windows.** Also, let’s say two types of printer **epson** and **hp**
    . Both computers and printers needs to work with each other in any combination. 
    The client will only access the computer without worrying about how print is happening.
    Instead of creating four structs for the 2*2 combination, we create two hierarchies
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction Hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation Hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the below figure. These two hierarchies communicate with each other via
    a bridge where **Abstraction** (computer here) contains a reference to the **Implementation**(printer
    here). Both the abstraction and implementation can continue to develop independently
    without affecting each other.  Notice how **win** and **mac** embed the reference
    to **printer**. We can change the **Abstraction’sImplementation** (i.e., computer’s
    printer) at run time as abstraction refers to implementation via the interface.
    On calling **mac.print() or windows.print()** it dispatches the request to **printer.printFile()**.
    This acts as a bridge and provides a loose coupling between the two.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1ef67b3d09bdb372d54f7c333450e2d.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '**UML Diagram:**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/48c2e70e2b624d3502b34735bce83f06.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '**Mapping **'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The below table represents the mapping from the UML diagram actors to actual
    implementation actors in **“Practical Example”** below
  prefs: []
  type: TYPE_NORMAL
- en: '| Abstraction | computer.go |'
  prefs: []
  type: TYPE_TB
- en: '| Refined Abstraction 1 | win.go |'
  prefs: []
  type: TYPE_TB
- en: '| Refined Abstraction 2 | mac.go |'
  prefs: []
  type: TYPE_TB
- en: '| Implementation | printer.go |'
  prefs: []
  type: TYPE_TB
- en: '| Concrete Implementation 1 | epson.go |'
  prefs: []
  type: TYPE_TB
- en: '| Concrete Implementation 2 | hp.go |'
  prefs: []
  type: TYPE_TB
- en: '| Client | main.go |'
  prefs: []
  type: TYPE_TB
- en: '**Practical Example**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**computer.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**mac.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**windows.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**printer.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**epson.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**hp.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**main.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Full Working Code:**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[bridge design pattern](https://golangbyexample.com/tag/bridge-design-pattern/)*   [design
    pattern](https://golangbyexample.com/tag/design-pattern/)*   [go](https://golangbyexample.com/tag/go/)*   [golang](https://golangbyexample.com/tag/golang/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
