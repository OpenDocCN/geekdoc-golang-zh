["```\ntype Context interface {\n    //It retures a channel when a context is cancelled, timesout (either when deadline is reached or timeout time has finished)\n    Done() <-chan struct{}\n\n    //Err will tell why this context was cancelled. A context is cancelled in three scenarios.\n    // 1\\. With explicit cancellation signal\n    // 2\\. Timeout is reached\n    // 3\\. Deadline is reached\n    Err() error\n\n    //Used for handling deallines and timeouts\n    Deadline() (deadline time.Time, ok bool)\n\n    //Used for passing request scope values\n    Value(key interface{}) interface{}\n}\n```", "```\nrootCtx := context.Background()\nchildCtx := context.WithValue(rootCtx, \"msgId\", \"someMsgId\")\n```", "```\nrootCtx := context.Background()\nchildCtx := context.WithValue(rootCtx, \"msgId\", \"someMsgId\")\nchildOfChildCtx, cancelFunc := context.WithCancel(childCtx)\n```", "```\nrootCtx := context.Background()\nchildCtx1 := context.WithValue(rootCtx, \"msgId\", \"someMsgId\")\nchildCtx2, cancelFunc := context.WithCancel(childCtx1)\nchildCtx3 := context.WithValue(rootCtx, \"user_id\", \"some_user_id)\n```", "```\nchildCtx4 := context.WithValue(childCtx1, \"current_time\", \"some_time)\n```", "```\nwithValue(parent Context, key, val interface{}) (ctx Context)\n```", "```\n#Root Context\nctxRoot := context.Background() - #Root context \n\n#Below ctxChild has acess to only one pair {\"a\":\"x\"}\nctxChild := context.WithValue(ctxRoot, \"a\", \"x\") \n\n#Below ctxChildofChild has access to both pairs {\"a\":\"x\", \"b\":\"y\"} as it is derived from ctxChild\nctxChildofChild := context.WithValue(ctxChild, \"b\", \"y\") \n```", "```\npackage main\n\nimport (\n    \"context\"\n    \"net/http\"\n    \"github.com/google/uuid\"\n)\n\nfunc main() {\n    helloWorldHandler := http.HandlerFunc(HelloWorld)\n    http.Handle(\"/welcome\", inejctMsgID(helloWorldHandler))\n    http.ListenAndServe(\":8080\", nil)\n}\n\n//HelloWorld hellow world handler\nfunc HelloWorld(w http.ResponseWriter, r *http.Request) {\n    msgID := \"\"\n    if m := r.Context().Value(\"msgId\"); m != nil {\n        if value, ok := m.(string); ok {\n            msgID = value\n        }\n    }\n    w.Header().Add(\"msgId\", msgID)\n    w.Write([]byte(\"Hello, world\"))\n}\n\nfunc inejctMsgID(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        msgID := uuid.New().String()\n        ctx := context.WithValue(r.Context(), \"msgId\", msgID)\n        req := r.WithContext(ctx)\n        next.ServeHTTP(w, req)\n\n    })\n}\n```", "```\ncurl -v http://localhost/welcome\n```", "```\ncurl -v http://localhost:8080/welcome\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8080 (#0)\n> GET /do HTTP/1.1\n> Host: localhost:8080\n> User-Agent: curl/7.54.0\n> Accept: */*\n> \n< HTTP/1.1 200 OK\n< Msgid: a03ff1d4-1464-42e5-a0a8-743c5af29837\n< Date: Mon, 23 Dec 2019 16:51:01 GMT\n< Content-Length: 12\n< Content-Type: text/plain; charset=utf-8\n< \n* Connection #0 to host localhost left intact\n```", "```\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)\n```", "```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    cancelCtx, cancelFunc := context.WithCancel(ctx)\n    go task(cancelCtx)\n    time.Sleep(time.Second * 3)\n    cancelFunc()\n    time.Sleep(time.Second * 1)\n}\n\nfunc task(ctx context.Context) {\n    i := 1\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println(\"Gracefully exit\")\n            fmt.Println(ctx.Err())\n            return\n        default:\n            fmt.Println(i)\n            time.Sleep(time.Second * 1)\n            i++\n        }\n    }\n}\n```", "```\n1\n2\n3\nGracefully exit\ncontext canceled\n```", "```\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\n```", "```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    cancelCtx, cancel := context.WithTimeout(ctx, time.Second*3)\n    defer cancel()\n    go task1(cancelCtx)\n    time.Sleep(time.Second * 4)\n}\n\nfunc task1(ctx context.Context) {\n    i := 1\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println(\"Gracefully exit\")\n            fmt.Println(ctx.Err())\n            return\n        default:\n            fmt.Println(i)\n            time.Sleep(time.Second * 1)\n            i++\n        }\n    }\n}\n```", "```\n1\n2\n3\nGracefully exit\ncontext deadline exceeded\n```", "```\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc)\n```", "```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    cancelCtx, cancel := context.WithDeadline(ctx, time.Now().Add(time.Second*5))\n    defer cancel()\n    go task(cancelCtx)\n    time.Sleep(time.Second * 6)\n}\n\nfunc task(ctx context.Context) {\n    i := 1\n    for {\n        select {\n        case <-ctx.Done():\n            fmt.Println(\"Gracefully exit\")\n            fmt.Println(ctx.Err())\n            return\n        default:\n            fmt.Println(i)\n            time.Sleep(time.Second * 1)\n            i++\n        }\n    }\n}\n```", "```\n1\n2\n3\n4\n5\nGracefully exit\ncontext deadline exceeded\n```"]