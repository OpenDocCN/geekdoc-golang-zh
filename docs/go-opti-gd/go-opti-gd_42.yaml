- en: 'Optimizing TLS for Speed: Handshake, Reuse, and Cipher Choice¶'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://goperf.dev/02-networking/tls-for-speed/](https://goperf.dev/02-networking/tls-for-speed/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'TLS does what it’s supposed to: it keeps your connections private and trustworthy.
    But it also slows things down — a lot more than most people realize. In Go, if
    you care about how quickly your service responds, you can squeeze out better performance
    by tuning how TLS negotiates and what it negotiates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding TLS Overhead: Where Performance Suffers[¶](#understanding-tls-overhead-where-performance-suffers
    "Permanent link")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the slowdown in TLS happens right at the start. The handshake is a
    back-and-forth process: picking algorithms, swapping keys, proving identities,
    and setting up the session. That back-and-forth usually takes two full trips across
    the network. In something like a trading platform or a real-time app, that delay
    is noticeable.'
  prefs: []
  type: TYPE_NORMAL
- en: To make TLS faster, the most effective place to start is cutting down the handshake
    steps and making the crypto work less expensive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Session Resumption: Cutting Handshake Latency[¶](#session-resumption-cutting-handshake-latency
    "Permanent link")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because every new TLS connection runs the entire handshake — negotiating ciphers,
    exchanging keys, verifying certificates — it introduces noticeable latency. Session
    resumption sidesteps most of that by reusing the cryptographic state from an earlier
    session, making reconnects much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Session resumption is a mechanism in TLS to avoid repeating the full handshake
    on reconnect. There are two main approaches: session IDs and session tickets.
    Both rely on the idea that the server remembers (or encodes) the session’s cryptographic
    state from a prior connection. When a client reconnects, it presents either the
    session ID or the session ticket, allowing the server to restore the session state
    and skip expensive asymmetric key exchange.'
  prefs: []
  type: TYPE_NORMAL
- en: A session ticket is a data blob issued by the server to the client at the end
    of the handshake. This ticket contains the encrypted session state (such as negotiated
    cipher suite, keys, and session parameters) and is opaque to the client. On reconnect,
    the client sends the ticket back, and the server decrypts it to resume the session
    without performing a full handshake.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, you enable session resumption by setting up session ticket keys. The
    server uses these keys to encrypt and decrypt the session state that clients send
    back when resuming a connection. You can generate a secure 32‑byte key at startup
    with crypto/rand and reuse it if your service is running across multiple instances
    behind a load balancer. Just make sure to rotate the key now and then to keep
    it secure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What makes session resumption effective is that it avoids re‑doing the slowest
    parts of TLS. Instead of negotiating everything from scratch, the server decrypts
    the ticket, verifies it, and restores the session. That eliminates at least one
    full round trip and all the heavy asymmetric operations, which saves both time
    and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Cipher Suites Wisely[¶](#choosing-cipher-suites-wisely "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cipher suites define the combination of algorithms used for key exchange, authentication,
    encryption, and integrity checking. Selecting efficient cipher suites significantly
    impacts performance.
  prefs: []
  type: TYPE_NORMAL
- en: Why prefer one over another? Some suites use RSA for key exchange, which is
    much slower than elliptic-curve Diffie–Hellman (ECDHE) and lacks forward secrecy.
    Suites with AES-GCM are faster on modern CPUs thanks to hardware acceleration,
    whereas older CBC-mode suites are slower and more error-prone. ECC-based authentication
    (ECDSA) also provides shorter signatures and lower computational cost compared
    to RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'To choose wisely:'
  prefs: []
  type: TYPE_NORMAL
- en: Prioritize suites with ECDHE for forward secrecy and better performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer AES-GCM over AES-CBC or ChaCha20 unless targeting hardware that lacks
    AES acceleration (where ChaCha20 may win).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid suites using only RSA for key exchange, because they lack forward secrecy
    and require more expensive computations on the server side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go standard library ships with a solid set of secure and reasonably fast
    defaults. For most applications, you can stick with those and be fine. But if
    you’re tuning for a high‑performance environment, defining your own preferred
    cipher suites gives you tighter control over what gets negotiated.
  prefs: []
  type: TYPE_NORMAL
- en: An optimized config favors AES‑GCM for its hardware acceleration and ECC for
    its efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These suites strike a good balance between security and speed, leveraging forward
    secrecy and hardware-accelerated encryption. The second option, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
    is a reasonable choice when clients may not support ECDSA certificates — it still
    provides forward secrecy and efficient AES-GCM encryption while relying on the
    more widely deployed RSA for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Using ALPN Wisely[¶](#using-alpn-wisely "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application-Layer Protocol Negotiation (ALPN) lets clients and servers agree
    upon the application protocol (like HTTP/2, HTTP/1.1, or gRPC) during the TLS
    handshake, avoiding additional round trips or guessing after establishing the
    connection. Without ALPN, a client would have to fall back to slower or less efficient
    methods to detect the server’s supported protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, the `NextProtos` field in `tls.Config` defines which application protocols
    the server supports and in what order of preference. During the TLS handshake,
    the client sends its own list, and the server picks the highest‑priority protocol
    that both sides support, then confirms it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to support `HTTP/2` with a fallback to `HTTP/1.1`, you should set
    `NextProtos` explicitly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The sequence of entries in `NextProtos` matters because the server walks the
    list in order and chooses the first protocol also offered by the client. By putting
    HTTP/2 (`h2`) at the top, the server ensures it prefers HTTP/2 when supported,
    falling back to HTTP/1.1 only when necessary. If the order is incorrect, the server
    may settle on a slower protocol or fail to agree entirely.
  prefs: []
  type: TYPE_NORMAL
- en: When `NextProtos` is left empty, ALPN is effectively disabled. The client assumes
    HTTP/1.1 because it never sees an indication of HTTP/2 support during the handshake.
    Explicitly setting `NextProtos` advertises the server’s capabilities and avoids
    unnecessary protocol downgrades.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing Certificate Verification Overhead[¶](#minimizing-certificate-verification-overhead
    "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certificate verification tends to be CPU‑heavy because it involves several
    expensive asymmetric cryptographic operations, which directly increase connection
    latency. This cost can be reduced in two ways: by using smaller, faster‑to‑verify
    ECC‑based (ECDSA) certificates instead of RSA, and by caching already‑validated
    certificate chains to avoid repeating the same verification work on subsequent
    connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A basic caching mechanism stores verification outcomes temporarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: While the snippet illustrates key concepts, it should not be used in production
    as-is. Cryptographic code demands careful analysis and adaptation to the specific
    environment and threat model. Always validate and test security-related code before
    deployment to avoid introducing weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: TLS Best Practices in Go[¶](#tls-best-practices-in-go "Permanent link")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following configuration brings together these techniques into a tls.Config
    that is optimized for both performance and security.
  prefs: []
  type: TYPE_NORMAL
- en: The `MinVersion` setting tells the server to reject older, broken versions of
    TLS. Anything below TLS 1.2 — like SSLv3, TLS 1.0, or 1.1 — is riddled with weaknesses
    and no longer considered safe. TLS 1.2 fixed many of those problems by introducing
    AEAD ciphers like AES‑GCM and defenses against attacks such as BEAST and POODLE.
  prefs: []
  type: TYPE_NORMAL
- en: The `CurvePreferences` field prioritizes fast and secure elliptic curves supported
    by most clients. P-256 and X25519 are efficient, widely-supported, and often hardware-accelerated.
    P-256 (also known as secp256r1) is an NIST-recommended curve with broad compatibility
    and native support in most CPUs for fast computation. X25519 is a modern curve
    designed for both speed and simplicity, offering constant-time operations to resist
    side-channel attacks, and performs especially well on low-power or embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: Te rest parts were discussed in details above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: TLS optimization is about balancing performance and security effectively. By
    reducing handshake overhead through session reuse, wisely selecting cipher suites
    with ECC and hardware acceleration, efficiently leveraging ALPN, and minimizing
    certificate verification overhead through caching, Go applications can achieve
    both security and speed. This approach makes TLS less a performance bottleneck
    and more a seamless security foundation for modern network services.
  prefs: []
  type: TYPE_NORMAL
