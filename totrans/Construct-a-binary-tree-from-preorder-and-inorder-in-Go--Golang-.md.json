["```\n[1,2,4,3,5,6]\n```", "```\n[4,2,1,5,3,6]\n```", "```\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n\n\tlenOfTree := len(preorder)\n\n\tcurrent := 0\n\tnewRoot := buildTreeUtil(preorder, inorder, &current, 0, lenOfTree-1)\n\n\treturn newRoot\n}\n\nfunc buildTreeUtil(preorder []int, inorder []int, current *int, low, high int) *TreeNode {\n\tif low > high {\n\t\treturn nil\n\t}\n\n\tif low == high {\n\t\trootNode := &TreeNode{Val: preorder[*current]}\n\t\t(*current)++\n\t\treturn rootNode\n\t}\n\n\trootNode := &TreeNode{Val: preorder[*current]}\n\trootValue := preorder[*current]\n\t(*current)++\n\n\tvar rootIndex int\n\tfor i := low; i <= high; i++ {\n\t\tif inorder[i] == rootValue {\n\t\t\trootIndex = i\n\t\t}\n\t}\n\n\trootNode.Left = buildTreeUtil(preorder, inorder, current, low, rootIndex-1)\n\trootNode.Right = buildTreeUtil(preorder, inorder, current, rootIndex+1, high)\n\n\treturn rootNode\n}\n\nfunc main() {\n\tinorder := []int{4, 2, 1, 5, 3, 6}\n\tpreorder := []int{1, 2, 4, 3, 5, 6}\n\n\troot := buildTree(preorder, inorder)\n\tfmt.Printf(\"root: %d\\n\", root.Val)\n\tfmt.Printf(\"root.Left: %d\\n\", root.Left.Val)\n\tfmt.Printf(\"root.Left.Left: %d\\n\", root.Left.Left.Val)\n\tfmt.Printf(\"root.Right: %d\\n\", root.Right.Val)\n\tfmt.Printf(\"root.Right.Left: %d\\n\", root.Right.Left.Val)\n\tfmt.Printf(\"root.Right.Right: %d\\n\", root.Right.Right.Val)\n}\n```", "```\nroot: 1\nroot.Left: 2\nroot.Left.Left: 4\nroot.Right: 3\nroot.Right.Left: 5\nroot.Right.Right: 6\n```"]