["```go\n`import  (   \"context\"   \"log\"   \"net\"   \"time\" )  func  resolveWithTracing(ctx  context.Context,  hostname  string)  ([]string,  error)  {   start  :=  time.Now()   ips,  err  :=  net.DefaultResolver.LookupHost(ctx,  hostname)   elapsed  :=  time.Since(start)    log.Printf(\"dns: host=%s duration=%s ips=%v err=%v\",  hostname,  elapsed,  ips,  err)   return  ips,  err }` \n```", "```go\n`func  dialWithTracing(ctx  context.Context,  network,  addr  string)  (net.Conn,  error)  {   var  d  net.Dialer   start  :=  time.Now()   conn,  err  :=  d.DialContext(ctx,  network,  addr)   elapsed  :=  time.Since(start)    log.Printf(\"dial: addr=%s duration=%s err=%v\",  addr,  elapsed,  err)   return  conn,  err }` \n```", "```go\n`import  (   \"crypto/tls\" )  func  handshakeWithTracing(conn  net.Conn,  config  *tls.Config)  (*tls.Conn,  error)  {   tlsConn  :=  tls.Client(conn,  config)   start  :=  time.Now()   err  :=  tlsConn.Handshake()   elapsed  :=  time.Since(start)    log.Printf(\"handshake: duration=%s err=%v\",  elapsed,  err)   return  tlsConn,  err }` \n```", "```go\n`type  tracedConn  struct  {   net.Conn }  func  (c  *tracedConn)  Read(b  []byte)  (int,  error)  {   start  :=  time.Now()   n,  err  :=  c.Conn.Read(b)   elapsed  :=  time.Since(start)    log.Printf(\"read: bytes=%d duration=%s err=%v\",  n,  elapsed,  err)   return  n,  err }  func  (c  *tracedConn)  Write(b  []byte)  (int,  error)  {   start  :=  time.Now()   n,  err  :=  c.Conn.Write(b)   elapsed  :=  time.Since(start)    log.Printf(\"write: bytes=%d duration=%s err=%v\",  n,  elapsed,  err)   return  n,  err }` \n```", "```go\n`func  closeWithTracing(c  net.Conn)  error  {   start  :=  time.Now()   err  :=  c.Close()   elapsed  :=  time.Since(start)    log.Printf(\"close: duration=%s err=%v\",  elapsed,  err)   return  err }` \n```", "```go\n`import  (   \"go.opentelemetry.io/otel/trace\" )  func  tracePhase(ctx  context.Context,  tracer  trace.Tracer,  phase  string,  fn  func()  error)  error  {   ctx,  span  :=  tracer.Start(ctx,  phase)   defer  span.End()   return  fn() }` \n```", "```go\n`atomicLevel  :=  zap.NewAtomicLevel() logger  :=  zap.New(zapcore.NewCore(   zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),   zapcore.AddSync(os.Stdout),   atomicLevel, ))  // Adjust at runtime atomicLevel.SetLevel(zap.WarnLevel)` \n```", "```go\n`core  :=  zapcore.NewSamplerWithOptions(   logger.Core(),   time.Second,   100,  // first 100 per second   10,  // thereafter ) logger  :=  zap.New(core)` \n```", "```go\n`phases  :=  map[string]time.Duration{   \"dns\":  10  *  time.Millisecond,   \"dial\":  40  *  time.Millisecond,   \"handshake\":  50  *  time.Millisecond, } logger.Info(\"connection completed\",  zap.Any(\"phases\",  phases))` \n```", "```go\n`import  (   \"go.uber.org/zap\" )  var  logger,  _  =  zap.NewProduction()  logger.Info(\"dns\",   zap.String(\"host\",  hostname),   zap.Duration(\"duration\",  elapsed),   zap.Strings(\"ips\",  ips),   zap.Error(err), )` \n```"]