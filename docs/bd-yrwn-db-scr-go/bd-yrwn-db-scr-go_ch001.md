# 00. 简介

## 通过构建自己的数据库来掌握基础知识

### 要学习什么？

复杂系统如数据库是建立在几个简单原则之上的。

1.  **原子性和持久性**。数据库不仅仅是文件！

    +   使用`fsync`持久化数据。

    +   故障恢复。

1.  基于**B 树**的**键值存储**。

    +   基于磁盘的数据结构。

    +   使用自由列表进行空间管理。

1.  **关系型数据库**建立在键值对之上。

    +   表和索引如何映射到底层的 B 树。

    +   类 SQL **查询语言**；解析器和解释器。

1.  **并发控制**事务。

### 用 3000 行代码逐步编写数据库

令人惊讶的是，一个有趣且广泛的话题可以包含在 3000 行代码中。你可能有过更大的项目经验，但并非所有经验都是平等的。

| LoC | Step |
| --- | --- |
| 366 | B+树数据结构。 |
| 601 | 只追加键值对。 |
| 731 | 带有自由列表的实用键值对。 |
| 1107 | 基于键值对的表。 |
| 1294 | 范围查询。 |
| 1438 | 二级索引。 |
| 1461 | 事务性接口。 |
| 1702 | 并发控制。 |
| 2795 | 类 SQL 查询语言。 |

### 通过实践学习：原则而非术语

数据库文献充满了令人困惑、含义重叠的术语，没有一致的意义。阅读时很容易迷失方向。另一方面，费曼曾经说过：“我不会构建的，我不理解”。你能通过阅读数据库来构建数据库吗？测试你的理解！

虽然有很多东西要学习，但并非所有知识都同等重要，**构建数据库只需要几个原则**，所以任何人都可以尝试。

## 主题 1：持久性和原子性

### 不仅仅是一种数据格式

智能手机大量使用 SQLite（基于文件的数据库）。为什么用 SQLite 存储数据而不是其他格式，比如 JSON？因为如果在更新过程中崩溃，你会面临数据丢失的风险。文件可能最终是半写状态、截断，甚至丢失。

有技术可以解决这个问题，它们导致了数据库的出现。

### 使用`fsync`实现持久性和原子性

原子性意味着数据要么被更新，要么没有被更新，不会处于中间状态。持久性意味着数据在某个点之后有保证存在。它们不是独立的问题，因为我们必须同时实现它们。

首先要学习的是`fsync`系统调用。文件写入不会同步到达磁盘，有多个级别的缓冲（操作系统页面缓存和设备上的 RAM）。`fsync`刷新挂起的数据并等待完成。这使得写入持久，但原子性怎么办？

## 主题 2：索引数据结构

### 通过索引控制延迟和成本

数据库将查询转换为结果，而用户并不知道如何做到。但结果并非唯一关注点，*延迟*和*成本*（内存、I/O、计算）也很相关，因此区分了分析型（OLAP）和事务型（OLTP）。

+   OLAP 可能涉及大量数据，包括聚合或连接操作。索引可能有限或不存在。

+   OLTP 通过索引触及少量数据。低延迟和成本。

“事务性”这个词并不是指数据库事务，它只是一个有趣的术语。

### 内存数据结构 vs. 磁盘数据结构

在磁盘上放置索引数据结构时会有额外的挑战。（关于更简单的内存数据库，请参阅我的书籍《构建自己的 Redis》）。

其中一个问题是在磁盘上**就地**更新数据，因为崩溃后你必须处理损坏的状态。磁盘不仅仅是比 RAM 慢。

RAM 中的 R 代表“随机”，这对于基于磁盘的数据来说又是一个问题，因为随机访问比顺序访问慢得多，即使在 SSD 上也是如此。所以像二叉树这样的数据结构不可行，而 B 树和 LSM 树是可行的。**并发**访问数据结构也是一个话题。

## 主题 3：基于键值对的关系型数据库

### 两层数据库接口

SQL 几乎是数据库的同义词。但 SQL 只是一个用户界面，它不是数据库的基本组成部分。重要的是其底层的**功能**。

另一个更简单的接口是键值（KV）。你可以获取、设置和删除单个键，最重要的是，可以按顺序列出键的范围。KV 比 SQL 简单，因为它低一层。关系型数据库建立在类似于 KV 的接口之上，称为**存储引擎**。

### 查询语言：解析器和解释器

最后一步虽然代码行数较多，但很容易，因为解析器和解释器都是用**递归**编写的！这个教训可以应用到几乎任何计算机语言，或者创建自己的编程语言或领域特定语言（更多挑战请参阅我的书籍《从源代码到机器代码》）。

## *构建自己的 X* 书系

X 包括 Redis、Web 服务器和编译器。在网站上阅读网页版。

[`build-your-own.org`](https://build-your-own.org)
