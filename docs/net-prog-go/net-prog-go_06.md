# 第四章：发送 TCP 数据

![](img/chapterart.png)

现在你已经了解了如何在 Go 中正确建立和优雅地终止 TCP 连接，是时候将这些知识应用到数据传输中。本章介绍了使用 TCP 进行数据发送和接收的各种技术。

我们将讨论从网络连接读取数据的最常见方法。你将创建一个简单的消息协议，允许你在节点之间传输动态大小的有效负载。接下来，你将探索 `net.Conn` 接口提供的网络可能性。本章最后将深入探讨 `TCPConn` 对象及 Go 开发者可能遇到的一些隐蔽的 TCP 网络问题。

## 使用 `net.Conn` 接口

本书中的大多数网络代码都尽可能使用 Go 的 `net.Conn` 接口，因为它为大多数情况提供了所需的功能。你可以使用 `net.Conn` 接口编写强大的网络代码，而无需断言其底层类型，从而确保你的代码在不同操作系统间兼容，并且可以编写更为健壮的测试。（你将在本章稍后学习如何访问 `net.Conn` 的底层类型，以便使用其更高级的方法。）`net.Conn` 上可用的方法涵盖了大多数使用场景。

`net.Conn` 最有用的两个方法是 `Read` 和 `Write`。这两个方法分别实现了 `io.Reader` 和 `io.Writer` 接口，这些接口在 Go 标准库和生态系统中广泛使用。因此，你可以利用为这些接口编写的大量代码，创建功能强大的网络应用程序。

你可以使用 `net.Conn` 的 `Close` 方法来关闭网络连接。如果连接成功关闭，该方法将返回 `nil`，否则返回错误。`SetReadDeadline` 和 `SetWriteDeadline` 方法接受一个 `time.Time` 对象，设置读取和写入网络连接时的绝对时间，超时后将返回错误。`SetDeadline` 方法则同时设置读取和写入的截止时间。如在第 62 页的“实现截止时间”部分所述，截止时间可以帮助你控制网络连接空闲的最长时间，并及时发现网络连接问题。

## 发送和接收数据

从网络连接读取数据和写入数据与读写文件对象没有区别，因为 `net.Conn` 实现了 `io.ReadWriteCloser` 接口，后者用于文件的读写。在这一节中，你将首先学习如何将数据读入固定大小的缓冲区。接下来，你将学习如何使用 `bufio.Scanner` 从网络连接中读取数据，直到遇到特定的分隔符。然后，你将探索 TLV（标签-长度-值）编码方法，它使你能够定义一种基本协议来动态分配适应不同有效负载大小的缓冲区。最后，你将了解如何在从网络连接读取和写入数据时处理错误。

### 将数据读取到固定缓冲区

Go 中的 TCP 连接实现了`io.Reader`接口，这允许你从网络连接中读取数据。要从网络连接中读取数据，你需要提供一个缓冲区供网络连接的`Read`方法填充。

如果连接的接收缓冲区中有足够的数据，`Read`方法会填充缓冲区至其容量。如果接收缓冲区中的字节少于你提供的缓冲区的容量，`Read`会用数据填充给定的缓冲区并返回，而不是等待更多数据到达。换句话说，`Read`并不保证在返回之前填充缓冲区至其容量。示例 4-1 演示了从网络连接读取数据到字节切片的过程。

```
package main

import (
    "crypto/rand"
    "io"
    "net"
    "testing"
)

func TestReadIntoBuffer(t *testing.T) {
    1 payload := make([]byte, 1<<24) // 16 MB
    _, err := rand.Read(payload)   // generate a random payload
    if err != nil {
        t.Fatal(err)
    }

    listener, err := net.Listen("tcp", "127.0.0.1:")
    if err != nil {
        t.Fatal(err)
    }

    go func() {
        conn, err := listener.Accept()
        if err != nil {
            t.Log(err)
            return
        }
        defer conn.Close()

        2 _, err = conn.Write(payload)
        if err != nil {
            t.Error(err)
        }
    }()

    conn, err := net.Dial("tcp", listener.Addr().String())
    if err != nil {
        t.Fatal(err)
    }

    buf := make([]byte, 31<<19) // 512 KB

    for {
        4 n, err := conn.Read(buf)
        if err != nil {
            if err != io.EOF {
                t.Error(err)
            }
            break
 }

        t.Logf("read %d bytes", n) // buf[:n] is the data read from conn
    }

    conn.Close()
}
```

示例 4-1：通过网络连接接收数据（*read_test.go*）

你需要给客户端提供一些可以读取的内容，所以你创建了一个 16MB 的随机数据负载——比客户端可以在其选择的 512KB 缓冲区大小中读取的数据要多，这样它至少会在`for`循环中执行几次。使用更大的缓冲区或更小的负载并一次性通过`Read`调用读取完整负载是完全可以接受的。Go 会正确处理数据，无论负载和接收缓冲区的大小如何。

然后你启动监听器并创建一个 goroutine 来监听传入连接。一旦接受到连接，服务器将把整个负载写入网络连接。客户端随后从连接中读取最多 512KB 的数据，然后继续执行循环。客户端继续每次读取最多 512KB，直到发生错误或客户端读取完整个 16MB 的负载。

### 使用扫描器进行分隔读取

使用我刚才展示的方法从网络连接中读取数据意味着你的代码需要理解它接收到的数据。由于 TCP 是面向流的协议，客户端可以通过多个数据包接收一个字节流。与句子不同，二进制数据不包含固有的标点符号来告诉你一条消息的开始和结束。

例如，如果你的代码正在从服务器读取一系列电子邮件消息，那么你的代码将需要检查每个字节，以查找分隔符，这些分隔符表示消息在字节流中的边界。或者，你的客户端与服务器之间可能有一个既定协议，服务器发送固定数量的字节来指示服务器接下来将发送的负载大小。你的代码可以使用这个大小来创建一个合适的负载缓冲区。你将在本章稍后看到这种技术的示例。

然而，如果你选择使用分隔符来指示一条消息的结束和另一条消息的开始，那么编写代码来处理边界情况就不那么简单了。例如，你可能从网络连接的一个`Read`中读取了 1KB 的数据，并发现其中包含了两个分隔符。这意味着你有两条完整的消息，但你没有足够的信息来判断第二个分隔符后面的数据块是否也是一条完整的消息。如果你再读取 1KB 的数据并且没有发现分隔符，你可以得出结论，整个数据块是上一条 1KB 消息的延续。但是，如果你读取了 1KB 的数据，而这些数据全是分隔符呢？

如果这开始听起来有点复杂，那是因为你必须考虑跨多个`Read`调用的数据，并在过程中处理任何错误。每当你想自己动手解决这样的问题时，检查标准库，看看是否已经有经过验证的实现。在这种情况下，`bufio.Scanner`做到了你需要的功能。

`bufio.Scanner`是 Go 标准库中一个方便的代码，它允许你读取带分隔符的数据。`Scanner`接受一个`io.Reader`作为输入。由于`net.Conn`有一个实现了`io.Reader`接口的`Read`方法，你可以使用`Scanner`轻松地从网络连接中读取带分隔符的数据。Listing 4-2 设置了一个监听器，以提供带分隔符的数据，供以后由`bufio.Scanner`解析。

```
package main

import (
    "bufio"
    "net"
    "reflect"
    "testing"
)

const 1payload = "The bigger the interface, the weaker the abstraction."

func TestScanner(t *testing.T) {
    listener, err := net.Listen("tcp", "127.0.0.1:")
    if err != nil {
        t.Fatal(err)
    }

    go func() {
        conn, err := listener.Accept()
        if err != nil {
            t.Error(err)
            return
        }
        defer conn.Close()

        _, err = conn.Write([]byte(payload))
        if err != nil {
            t.Error(err)
        }
    }()

`--snip--`
```

Listing 4-2：创建一个测试来提供一个常量有效负载（*scanner_test.go*）

这个监听器现在应该让你感到熟悉。它的目的就是提供有效负载。Listing 4-3 使用`bufio.Scanner`从网络中读取字符串，并通过空格拆分每个数据块。

```
`--snip--`

    conn, err := net.Dial("tcp", listener.Addr().String())
    if err != nil {
 t.Fatal(err)
    }
    defer conn.Close()

    1 scanner := bufio.NewScanner(conn)
    scanner.Split(bufio.ScanWords)

    var words []string

    2 for scanner.Scan() {
        words = append(words, 3scanner.Text())
    }

    err = scanner.Err()
    if err != nil {
        t.Error(err)
    }

    expected := []string{"The", "bigger", "the", "interface,", "the", 
        "weaker", "the", "abstraction."}

    if !reflect.DeepEqual(words, expected) {
        t.Fatal("inaccurate scanned word list")
    }
    4 t.Logf("Scanned words: %#v", words)
}
```

Listing 4-3：使用`bufio.Scanner`从网络中读取以空格分隔的文本（*scanner_test.go*）

既然你知道自己正在从服务器读取字符串，你可以通过创建一个从网络连接中读取数据的`bufio.Scanner`来开始。默认情况下，当扫描器在数据流中遇到换行符（`\n`）时，它会将读取的数据拆分。相反，你选择使用`bufio.ScanWords`来让扫描器在每个单词的结尾处拆分输入数据，这样它会在遇到单词边界时拆分数据，例如空格或句子结束符号。

你会继续从扫描器中读取数据，只要它告诉你它已经从连接中读取了数据。每次调用`Scan`时，可能会多次调用网络连接的`Read`方法，直到扫描器找到分隔符或从连接中读取到错误。它隐藏了跨一次或多次读取网络连接来寻找分隔符并返回结果消息的复杂性。

调用扫描器的`Text`方法会返回刚从网络连接中读取的那块数据作为字符串——在这个例子中是一个单词和相邻的标点符号。代码继续在`for`循环中迭代，直到扫描器从网络连接接收到`io.EOF`或其他错误。如果是后者，扫描器的`Err`方法将返回一个非`nil`的错误。你可以通过在`go test`命令中添加`-v`标志来查看扫描到的单词。

### 动态分配缓冲区大小

你可以从网络连接中读取变长数据，前提是发送方和接收方都已达成协议。*类型-长度-值*（TLV）编码方案是一个不错的选择。TLV 编码使用固定字节数表示数据的类型，使用固定字节数表示值的大小，并使用可变字节数表示值本身。我们的实现使用一个 5 字节的头部：1 字节表示类型，4 字节表示长度。TLV 编码方案允许你将类型作为字节序列发送到远程节点，并根据这些字节序列在远程节点上重构相同的类型。

示例 4-4 定义了我们的 TLV 编码协议将接受的类型。

```
package main

import (
    "bytes"
    "encoding/binary"
    "errors"
    "fmt"
    "io"
)

const (
    1 BinaryType uint8 = iota + 1
    2 StringType

    3 MaxPayloadSize uint32 = 10 << 20 // 10 MB
)

var ErrMaxPayloadSize = errors.New("maximum payload size exceeded")

type 4Payload interface {
    fmt.Stringer
    io.ReaderFrom
    io.WriterTo
    Bytes() []byte
}
```

示例 4-4：消息结构体实现了一个简单的协议（*types.go*）。

你从创建常量开始，表示你将定义的每个类型。在这个例子中，你将创建一个`BinaryType`和一个`StringType`。在消化每种类型的实现细节后，你应该能够创建适合你需求的类型。出于安全考虑，我们稍后会讨论，你必须定义一个最大有效负载大小。

你还定义了一个名为`Payload`的接口，描述了每个类型必须实现的方法。每个类型必须具有以下方法：`Bytes`、`String`、`ReadFrom` 和 `WriteTo`。`io.ReaderFrom` 和 `io.WriterTo` 接口分别允许你的类型从读取器读取数据并写入到写入器。你在这方面有一些灵活性。你也可以让`Payload`实现`encoding.BinaryMarshaler`接口，将其自己编码为字节切片，并实现`encoding.BinaryUnmarshaler`接口，从字节切片解码。但字节切片是从网络连接中剥离的一个层次，所以你将保持现有的`Payload`接口。此外，你将在下一章中使用二进制编码接口。

````You now have the foundation built to create TLV-based types. Listing 4-5 details the first type, `Binary`.    ``` *--snip--*    type 1Binary []byte    func (m Binary) 2Bytes() []byte  { return m }  func (m Binary) 3String() string { return string(m) }    func (m Binary) 4WriteTo(w io.Writer) (int64, error) {      err := 5binary.Write(w, binary.BigEndian, BinaryType) // 1-byte type      if err != nil {          return 0, err      }      var n int64 = 1        err = 6binary.Write(w, binary.BigEndian, uint32(len(m))) // 4-byte size      if err != nil {          return n, err      }      n += 4        o, err := 7w.Write(m) // payload        return n + int64(o), err  } ```    Listing 4-5: Creating the `Binary` type (*types.go*)    The `Binary` type 1 is a byte slice; therefore, its `Bytes` method 2 simply returns itself. Its `String` method 3 casts itself as a `string` before returning. The `WriteTo` method accepts an `io.Writer` and returns the number of bytes written to the writer and an `error` interface 4. The `WriteTo` method first writes the 1-byte type to the writer 5. It then writes the 4-byte length of the `Binary` to the writer 6. Finally, it writes the `Binary` value itself 7.    Listing 4-6 rounds out the `Binary` type with its `ReadFrom` method.    ``` `--snip--`    func (m *Binary) ReadFrom(r io.Reader) (int64, error) {      var typ uint8      err := 1binary.Read(r, binary.BigEndian, &typ) // 1-byte type      if err != nil {          return 0, err      }      var n int64 = 1      if typ != 2BinaryType {   return n, errors.New("invalid Binary")      }        var size uint32      err = 3binary.Read(r, binary.BigEndian, &size) // 4-byte size      if err != nil {          return n, err      }      n += 4      4 if size > MaxPayloadSize {          return n, ErrMaxPayloadSize      }        5 *m = make([]byte, size)      o, err := 6r.Read(*m) // payload        return n + int64(o), err  } ```    Listing 4-6: Completing the `Binary` type’s implementation (*types.go*)    The `ReadFrom` method reads 1 1 byte from the reader into the `typ` variable. It next verifies 2 that the type is `BinaryType` before proceeding. Then it reads 3 the next 4 bytes into the `size` variable, which sizes the new `Binary` byte slice 5. Finally, it populates the `Binary` byte slice 6.    Notice that you enforce a maximum payload size 4. This is because the 4-byte integer you use to designate the payload size has a maximum value of 4,294,967,295, indicating a payload of over 4GB. With such a large payload size, it would be easy for a malicious actor to perform a denial-of-service attack that exhausts all the available random access memory (RAM) on your computer. Keeping the maximum payload size reasonable makes memory exhaustion attacks harder to execute.    Listing 4-7 introduces the `String` type, which, like `Binary`, implements the `Payload` interface.    ``` `--snip--`    type String string    func (m String) 1Bytes() []byte  { return []byte(m) }  func (m String) 2String() string { return string(m) }    func (m String) 3WriteTo(w io.Writer) (int64, error) {      err := 4binary.Write(w, binary.BigEndian, StringType) // 1-byte type      if err != nil {          return 0, err      }      var n int64 = 1        err = binary.Write(w, binary.BigEndian, uint32(len(m))) // 4-byte size      if err != nil {          return n, err      }   n += 4        o, err := 5w.Write([]byte(m)) // payload        return n + int64(o), err  } ```    Listing 4-7: Creating the `String` type (*types.go*)    The `String` implementation’s `Bytes` method 1 casts the `String` to a byte slice. The `String` method 2 casts the `String` type to its base type, `string`. The `String` type’s `WriteTo` method 3 is like `Binary`’s `WriteTo` method except the first byte written 4 is the `StringType` and it casts the `String` to a byte slice before writing it to the writer 5.    Listing 4-8 finishes up the `String` type’s `Payload` implementation.    ``` `--snip--`    func (m *String) ReadFrom(r io.Reader) (int64, error) {      var typ uint8      err := binary.Read(r, binary.BigEndian, &typ) // 1-byte type      if err != nil {          return 0, err      }      var n int64 = 1      if typ != 1StringType {          return n, errors.New("invalid String")      }        var size uint32      err = binary.Read(r, binary.BigEndian, &size) // 4-byte size      if err != nil {          return n, err      }      n += 4        buf := make([]byte, size)      o, err := r.Read(buf) // payload      if err != nil {          return n, err      }      2 *m = String(buf)        return n + int64(o), nil  } ```    Listing 4-8: Completing the `String` type’s implementation (*types.go*)    Here, too, `String`’s `ReadFrom` method is like `Binary`’s `ReadFrom` method, with two exceptions. First, the method compares the `typ` variable against the `StringType`1 before proceeding. Second, the method casts the value read from the reader to a `String`2.    All that’s left to implement is a way to read arbitrary data from a network connection and use it to constitute one of our two types. For that, we turn to Listing 4-9.    ``` `--snip--`    func 1decode(r io.Reader) (Payload, error) {      var typ uint8      err := 2binary.Read(r, binary.BigEndian, &typ)      if err != nil {          return nil, err      }        3 var payload Payload        switch 4typ {      case BinaryType:          payload = new(Binary)      case StringType:          payload = new(String)      default:          return nil, errors.New("unknown type")      }        _, err = payload.ReadFrom(          5 io.MultiReader(bytes.NewReader([]byte{typ}), r))      if err != nil {          return nil, err      }        return payload, nil  } ```    Listing 4-9: Decoding bytes from a reader into a `Binary` or `String` type (*types.go*)    The `decode` function 1 accepts an `io.Reader` and returns a `Payload` interface and an `error` interface. If `decode` cannot decode the bytes read from the reader into a `Binary` or `String` type, it will return an error along with a nil `Payload`.    You must first read a byte from the reader 2 to determine the type and create a `payload` variable 3 to hold the decoded type. If the type you read from the reader is an expected type constant 4, you assign the corresponding type to the payload variable.    You now have enough information to finish decoding the binary data from the reader into the `payload` variable by using its `ReadFrom` method. But you have a problem here. You cannot simply pass the reader to the `ReadFrom` method. You’ve already read a byte from it corresponding to the type, yet the `ReadFrom` method expects the first byte it reads to be the type as well. Thankfully, the `io` package has a helpful function you can use: `MultiReader`. We cover `io.MultiReader` in more detail later in this chapter, but here you use it to concatenate the byte you’ve already read with the reader 5. From the `ReadFrom` method’s perspective, it will read the bytes in the sequence it expects.    Although the use of `io.MultiReader` shows you how to inject bytes back into a reader, it isn’t optimal in this use case. The proper fix is to remove each type’s need to read the first byte in its `ReadFrom` method. Then, the `ReadFrom` method would read only the 4-byte size and the payload, eliminating the need to inject the type byte back into the reader before passing it on to `ReadFrom`. As an exercise, I recommend you refactor the code to eliminate the need for `io.MultiReader`.    Let’s see the `decode` function in action in the form of a test. Listing 4-10 illustrates how you can send your two distinct types over a network connection and properly decode them back into their original type on the receiver’s end.    ``` package main    import (      "bytes"      "encoding/binary"      "net"      "reflect"      "testing"  )    func TestPayloads(t *testing.T) {      b1 := 1Binary("Clear is better than clever.")      b2 := Binary("Don't panic.")      s1 := 2String("Errors are values.")      payloads := 3[]Payload{&b1, &s1, &b2}        listener, err := net.Listen("tcp", "127.0.0.1:")      if err != nil {          t.Fatal(err)      }        go func() {          conn, err := listener.Accept()          if err != nil {              t.Error(err)              return          }          defer conn.Close()            for _, p := range payloads {              _, err = 4p.WriteTo(conn)              if err != nil {                  t.Error(err)                  break              }          }      }()    `--snip--` ```    Listing 4-10: Creating the `TestPayloads` test (*types_test.go*)    Your test should first create at least one of each type. You create two `Binary` types 1 and one `String` type 2. Next, you create a slice of `Payload` interfaces and add pointers to the `Binary` and `String` types you created 3. You then create a listener that will accept a connection and write each type in the `payloads` slice to it 4.    This is a good start. Let’s finish up the client side of the test in Listing 4-11.    ``` `--snip--`        conn, err := 1net.Dial("tcp", listener.Addr().String())      if err != nil {          t.Fatal(err)      }      defer conn.Close()        for i := 0; i < len(payloads); i++ {          actual, err := 2decode(conn)          if err != nil {              t.Fatal(err)          }            3 if expected := payloads[i]; !reflect.DeepEqual(expected, actual) {              t.Errorf("value mismatch: %v != %v", expected, actual)              continue          }            4 t.Logf("[%T] %[1]q", actual)      }  } ```    Listing 4-11: Completing the `TestPayloads` test (*types_test.go*)    You know how many types to expect in the payloads slice, so you initiate a connection to the listener 1 and attempt to decode each one 2. Finally, your test compares the type you decoded with the type the server sent 3. If there’s any discrepancy with the variable type or its contents, the test fails. You can run the test with the `-v` flag to see the type and its value 4.    Let’s make sure the `Binary` type enforces the maximum payload size in Listing 4-12.    ``` `--snip--`    func TestMaxPayloadSize(t *testing.T) {      buf := new(bytes.Buffer)      err := buf.WriteByte(BinaryType)      if err != nil {          t.Fatal(err)      }        err = binary.Write(buf, binary.BigEndian, 1uint32(1<<30)) // 1 GB      if err != nil {   t.Fatal(err)      }        var b Binary      _, err = b.ReadFrom(buf)      2 if err != ErrMaxPayloadSize {          t.Fatalf("expected ErrMaxPayloadSize; actual: %v", err)      }  } ```    Listing 4-12: Testing the maximum payload size (*types_test.go*)    This test starts with the creation of a `bytes.Buffer` containing the `BinaryType` byte and a 4-byte, unsigned integer indicating the payload is 1GB 1. When this buffer is passed to the `Binary` type’s `ReadFrom` method, you receive the `ErrMaxPayloadSize` error in return 2. The test cases in Listings 4-10 and 4-11 should cover the use case of a payload that is less than the maximum size, but I encourage you to modify this test to make sure that’s the case.    ### Handling Errors While Reading and Writing Data    Unlike writing to file objects, writing to network connections can be unreliable, especially if your network connection is spotty. Files don’t often return errors while you’re writing to them, but the receiver on the other end of a network connection may abruptly disconnect before you write your entire payload.    Not all errors returned when reading from or writing to a network connection are permanent. The connection can recover from some errors. For example, writing data to a network connection where adverse network conditions delay the receiver’s ACK packets, and where your connection times out while waiting to receive them, can result in a temporary error. This can occur if someone temporarily unplugs a network cable between you and the receiver. In that case, the network connection is still active, and you can either attempt to recover from the error or gracefully terminate your end of the connection.    Listing 4-13 illustrates how to check for temporary errors while writing data to a network connection.    ``` var (      err error      n int      i = 7 // maximum number of retries  )    1 for ; i > 0; i-- {      n, err = 2conn.Write(3[]byte("hello world"))      if err != nil {          if nErr, ok := 4err.(net.Error); ok && 5nErr.Temporary() {              log.Println("temporary error:", nErr)   time.Sleep(10 * time.Second)              continue          }         6 return err      }      break  }    if i == 0 {      return errors.New("temporary write failure threshold exceeded")  }    log.Printf("wrote %d bytes to %s\n", n, conn.RemoteAddr()) ```    Listing 4-13: Sending the string `"hello world"` over the connection    Since you might receive a transient error when writing to a network connection, you might need to retry a write operation. One way to account for this is to encapsulate the code in a `for` loop 1. This makes it easy to retry the write operation, if necessary.    To write to the connection, you pass a byte slice 3 to the connection’s `Write` method 2 as you would to any other `io.Writer`. This returns the number of bytes written and an `error` interface. If the `error` interface is not `nil`, you check whether the error implements the `net.Error` interface by using a type assertion 4 and check whether the error is temporary 5. If the `net.Error`’s `Temporary` method returns `true`, the code makes another write attempt by iterating around the `for` loop. If the error is permanent, the code returns the error 6. A successful write breaks out of the loop.    ## Creating Robust Network Applications by Using the io Package    In addition to interfaces common in Go code, such as `io.Reader` and `io.Writer`, the `io` package provides several useful functions and utilities that make the creation of robust network applications easy. In this section, you’ll learn how to use the `io.Copy`, `io.MultiWriter`, and `io.TeeReader` functions to proxy data between connections, log network traffic, and ping hosts when firewalls attempt to keep you from doing so.    ### Proxying Data Between Connections    One of the most useful functions from the `io` package, the `io.Copy` function reads data from an `io.Reader` and writes it to an `io.Writer`. This is useful for creating a *proxy*, which, in this context, is an intermediary that transfers data between two nodes. Since `net.Conn` includes both `io.Reader` and `io.Writer` interfaces, and `io.Copy` writes whatever it reads from an `io.Reader` to an `io.Writer`, you can easily create a proxy between network connections, such as the one you define in the `proxyConn` function in Listing 4-14. This function copies any data sent from the source node to the destination node, and vice versa.    ``` package main    import (      "io"      "net"  )    func proxyConn(source, destination string) error {      connSource, err := 1net.Dial("tcp", source)      if err != nil {          return err      }      defer connSource.Close()        connDestination, err := 2net.Dial("tcp", destination)      if err != nil {          return err      }      defer connDestination.Close()        // connDestination replies to connSource      3 go func() { _, _ = io.Copy(connSource, connDestination) }()        // connSource messages to connDestination      4 _, err = io.Copy(connDestination, connSource)        return err  } ```    Listing 4-14: Proxying data between two network connections (*proxy_conn.go*)    The `io.Copy` function does all the heavy input/output (I/O) lifting for you. It takes an `io.Writer` as its first argument and an `io.Reader` as its second argument. It then writes, to the writer, everything it reads from the reader until the reader returns an `io.EOF`, or, alternately, either the reader or writer returns an error. The `io.Copy` function returns an error only if a non-`io.EOF` error occurred during the copy, because `io.EOF` means it has read all the data from the reader.    You start by creating a connection to the `source` node 1 and a connection to the `destination` node 2. Next, you run `io.Copy` in a goroutine, reading from `connDestination` and writing to `connSource`3 to handle any replies. You don’t need to worry about leaking this goroutine, since `io.Copy` will return when either connection is closed. Then, you make another call to `io.Copy`, reading from `connSource` and writing to `connDestination`4. Once this call returns and the function returns, each connection’s `Close` method runs, which causes `io.Copy` to return, terminating its goroutine 3. As a result, the data is proxied between network connections as if they had a direct connection to one another.    Listing 4-15 illustrates how to use a slight variation of the `proxyConn` function. Whereas Listing 4-14’s `proxyConn` function established network connections and proxied traffic between them, Listing 4-15’s `proxy` function proxies data between an `io.Reader` and an `io.Writer`, making it applicable to more than just network connections and much easier to test.    ``` package main    import (      "io"      "net"      "sync"      "testing"  )    1 func proxy(from io.Reader, to io.Writer) error {      fromWriter, fromIsWriter := from.(io.Writer)      toReader, toIsReader := to.(io.Reader)        if toIsReader && fromIsWriter {          // Send replies since "from" and "to" implement the          // necessary interfaces.          go func() { _, _ = io.Copy(fromWriter, toReader) }()      }        _, err := io.Copy(to, from)        return err  } ```    Listing 4-15: Proxy data between a reader and writer (*proxy_test.go*)    This `proxy` function 1 is a bit more useful in that it accepts the ubiquitous `io.Reader` and `io.Writer` interfaces instead of `net.Conn`. Because of this change, you could proxy data from a network connection to `os.Stdout`, `*bytes.Buffer`, `*os.File`, or any number of objects that implement the `io.Writer` interface. Likewise, you could read bytes from any object that implements the `io.Reader` interface and send them to the writer. This implementation of `proxy` supports replies if the *from* reader implements the `io.Writer` interface and the *to* writer implements the `io.Reader` interface.    Listing 4-16 creates a test to make sure the proxy functions as you expect.   ``` `--snip--`    func TestProxy(t *testing.T) {      var wg sync.WaitGroup        // server listens for a "ping" message and responds with a      // "pong" message. All other messages are echoed back to the client.      1 server, err := net.Listen("tcp", "127.0.0.1:")      if err != nil {          t.Fatal(err)      }        wg.Add(1)        go func() {          defer wg.Done()            for {              conn, err := server.Accept()              if err != nil {                  return              }                go func(c net.Conn) {                  defer c.Close()                    for {                      buf := make([]byte, 1024)                      n, err := c.Read(buf)                      if err != nil {                          if err != io.EOF {                              t.Error(err)                          }                            return                      }                        switch msg := string(buf[:n]); msg {                      case "ping":                          _, err = c.Write([]byte("pong"))                      default:                          _, err = c.Write(buf[:n])                      }                        if err != nil {                          if err != io.EOF {                              t.Error(err)                          }                            return                      }                  }              }(conn)          }   }()    `--snip--` ```    Listing 4-16: Creating the listener (*proxy_test.go*)    You start by initializing a server 1 that listens for incoming connections. It reads bytes from each connection, replies with the string `"pong"` when it receives the string `"ping`,`"` and echoes any other message it receives.    Listing 4-17 continues the test implementation.    ``` `--snip--`        // proxyServer proxies messages from client connections to the      // destinationServer. Replies from the destinationServer are proxied      // back to the clients.      1 proxyServer, err := net.Listen("tcp", "127.0.0.1:")      if err != nil {          t.Fatal(err)      }        wg.Add(1)        go func() {          defer wg.Done()            for {              conn, err := 2proxyServer.Accept()              if err != nil {                  return              }                go func(from net.Conn) {                  defer from.Close()                    to, err := 3net.Dial("tcp",                      server.Addr().String())                  if err != nil {                      t.Error(err)                      return                  }                    defer to.Close()                    err = 4proxy(from, to)                  if err != nil && err != io.EOF {                      t.Error(err)                  }              }(conn)          }      }()    `--snip--` ```    Listing 4-17: Set up the proxy between the client and server (*proxy_test.go*)    You then set up a proxy server 1 that handles the message passing between the client and the destination server. The proxy server listens for incoming client connections. Once a client connection accepts 2, the proxy establishes a connection to the destination server 3 and starts proxying messages 4. Since the proxy server passes two `net.Conn` objects to `proxy`, and `net.Conn` implements the `io.ReadWriter` interface, the server proxies replies automatically. Then `io.Copy` writes to the `Write` method of the destination `net.Conn` everything it reads from the `Read` method of the origin `net.Conn`, and vice versa for replies from the destination to the origin.    Listing 4-18 implements the client portion of the test.    ``` `--snip--`        conn, err := net.Dial("tcp", proxyServer.Addr().String())      if err != nil {          t.Fatal(err)      }        1 msgs := []struct{ Message, Reply string }{          {"ping", "pong"},          {"pong", "pong"},          {"echo", "echo"},          {"ping", "pong"},      }        for i, m := range msgs {          _, err = conn.Write([]byte(m.Message))          if err != nil {              t.Fatal(err)          }            buf := make([]byte, 1024)            n, err := conn.Read(buf)          if err != nil {              t.Fatal(err)          }            actual := string(buf[:n])          t.Logf("%q -> proxy -> %q", m.Message, actual)            if actual != m.Reply {              t.Errorf("%d: expected reply: %q; actual: %q",                  i, m.Reply, actual)          }      }        _ = conn.Close()      _ = proxyServer.Close()      _ = server.Close()     wg.Wait()  } ```    Listing 4-18: Proxying data from an upstream server to a downstream server (*proxy_test.go*)    You run the proxy through a series of tests 1 to verify that your ping messages result in pong replies and that the destination echoes anything else you send. The output should look like the following:    ``` $ **go test** 1**-race -v proxy_test.go**  === RUN   TestProxy  --- PASS: TestProxy (0.00s)      proxy_test.go:138: "ping" -> proxy -> "pong"      proxy_test.go:138: "pong" -> proxy -> "pong"      proxy_test.go:138: "echo" -> proxy -> "echo"      proxy_test.go:138: "ping" -> proxy -> "pong"  PASS  ok      command-line-arguments  1.018s ```    I’m in the habit of running my tests with the `-race` flag 1 to enable the race detector. The race detector can help alert you to data races that need your attention. Although not necessary for this test, enabling it is a good habit.    ### Monitoring a Network Connection    The `io` package includes useful tools that allow you to do more with network data than just send and receive it using connection objects. For example, you could use `io.MultiWriter` to write a single payload to multiple network connections. You could also use `io.TeeReader` to log data read from a network connection. Listing 4-19 gives an example of using the `io.TeeReader` and `io.MultiWriter` to log all network traffic on a TCP listener.    ``` package main    import (      "io"      "log"      "net"      "os"  )    // Monitor embeds a log.Logger meant for logging network traffic.  type Monitor struct {      *log.Logger  }    // Write implements the io.Writer interface.  func (m *Monitor) 1Write(p []byte) (int, error) {      return len(p), m.Output(2, string(p))  }   func ExampleMonitor() {      2 monitor := &Monitor{Logger: log.New(os.Stdout, "monitor: ", 0)}        listener, err := net.Listen("tcp", "127.0.0.1:")      if err != nil {          monitor.Fatal(err)      }        done := make(chan struct{})        go func() {          defer close(done)            conn, err := listener.Accept()          if err != nil {              return          }          defer conn.Close()            b := make([]byte, 1024)          3 r := io.TeeReader(conn, monitor)            n, err := r.Read(b)          if err != nil && err != io.EOF {              monitor.Println(err)              return          }            4 w := io.MultiWriter(conn, monitor)            _, err = w.Write(b[:n]) // echo the message          if err != nil && err != io.EOF {              monitor.Println(err)              return          }      }()    `--snip--` ```    Listing 4-19: Using `io.TeeReader` and `io.MultiWriter` to capture a network connection’s input and output (*monitor_test.go*)    You create a new struct named `Monitor` that embeds a `log.Logger` for the purposes of logging the server’s network traffic. Since the `io.TeeReader` and the `io.MultiWriter` expect an `io.Writer`, the monitor implements the `io.Writer` interface 1.    You start by creating an instance of `Monitor`2 that writes to `os.Stdout`. You use the monitor in conjunction with the connection object in an `io.TeeReader`3. This results in an `io.Reader` that will read from the network connection and write all input to the monitor before passing along the input to the caller. Likewise, you log server output by creating an `io.MultiWriter`4, writing to the network connection and the monitor.    Listing 4-20 details the client portion of the example and its output.    ``` `--snip--`        conn, err := net.Dial("tcp", listener.Addr().String())      if err != nil {          monitor.Fatal(err)      }        _, err = 1conn.Write([]byte("Test\n"))      if err != nil {          monitor.Fatal(err)      }        _ = conn.Close()      <-done        // 2Output:      // monitor: Test      // monitor: Test  } ```    Listing 4-20: The client implementation and example output (*monitor_test.go*)    When you send the message `Test\n`1, it’s logged to `os.Stdout` twice 2: once when you read the message from the connection, and again when you echo the message back to the client. If you want to get fancy, you could decorate the log entries to differentiate between incoming and outgoing data. One way to do this would be to create an object that implements the `io.Writer` interface and embeds the monitor. When its `Write` method is called, it prepends the data with the prefix before passing the data along to the monitor’s `Write` method.    Although using the `io.TeeReader` and the `io.MultiWriter` in this fashion is powerful, it isn’t without a few caveats. First, both the `io.TeeReader` and the `io.MultiWriter` will block while writing to your writer. Your writer will add latency to the network connection, so be mindful not to block too long. Second, an error returned by your writer will cause the `io.TeeReader` or `io.MultiWriter` to return an error as well, halting the flow of network data. If you don’t want your use of these objects to potentially interrupt network data flow, I strongly recommend you implement a reader that always returns a `nil` error and logs its underlying error in a manner that’s actionable.    For example, you can modify `Monitor`’s `Write` method to always return a `nil` error:    ``` func (m *Monitor) Write(p []byte) (int, error) {      err := m.Output(2, string(p))      if err != nil {          log.Println(err) // use the log package’s default Logger      }        return len(p), nil  } ```    The `Monitor` attempts to write the byte slice to its embedded logger. Failing that, it writes the error to the `log` package’s default logger and returns a `nil` error to `io.TeeReader` and `io.MultiWriter` in Listing 4-19 so as not to interrupt the flow of data.    ### Pinging a Host in ICMP-Filtered Environments    In “The Internet Control Message Protocol” on page 31, you learned that ICMP is a protocol that gives you feedback about local network conditions. One of its most common uses is to determine whether a host is online by issuing a ping request and receiving a pong reply from the host. Most operating systems have a built-in `ping` command that sends an ICMP echo request to a destination IP address. Once the host responds with an ICMP echo reply, `ping` prints the duration between sending the ping and receiving the pong.    Unfortunately, many internet hosts filter or block ICMP echo replies. If a host filters `pongs`, the `ping` erroneously reports that the remote system is unavailable. One technique you can use instead is to establish a TCP connection with the remote host. If you know that the host listens for incoming TCP connections on a specific port, you can use this knowledge to confirm that the host is available, because you can establish a TCP connection only if the host is up and completes the handshake process.    Listing 4-21 shows a small application that reports the time it takes to establish a TCP connection with a host on a specific port.    ``` package main    import (      "flag"      "fmt"      "net"      "os"      "time"  )    1 var (      count    = flag.Int("c", 3, "number of pings: <= 0 means forever")      interval = flag.Duration("i", time.Second, "interval between pings")      timeout  = flag.Duration("W", 5*time.Second, "time to wait for a reply")  )    func init() {      flag.Usage = func() {          fmt.Printf("Usage: %s [options] host:port\nOptions:\n", os.Args[0])          flag.PrintDefaults()      }  }    `--snip--` ```    Listing 4-21: The command line flags for the `ping` command (*ping.go*)    This example starts by defining a few command line options 1 that mimic a subset of the functionality provided by the `ping` command on Linux.    Listing 4-22 adds the `main` function.    ``` `--snip--`    func main() {      flag.Parse()        if flag.NArg() != 1 {          fmt.Print("host:port is required\n\n")          flag.Usage()          os.Exit(1)      }        target := flag.Arg(0)      fmt.Println("PING", target)        if *count <= 0 {          fmt.Println("CTRL+C to stop.")      }        msg := 0        for (*count <= 0) || (msg < *count) {          msg++          fmt.Print(msg, " ")            start := time.Now()          1 c, err := net.DialTimeout("tcp", target, *timeout)          2 dur := time.Since(start)            if err != nil {              fmt.Printf("fail in %s: %v\n", dur, err)              if nErr, ok := err.(net.Error); !ok || 3!nErr.Temporary() {                  os.Exit(1)              }          } else {              _ = c.Close()              fmt.Println(dur)          }            time.Sleep(*interval)      }  } ```    Listing 4-22: Reporting the time to establish a TCP socket to a given host and port (*ping.go*)    You attempt to establish a connection to a remote host’s TCP port 1, setting a reasonable time-out duration if the remote host doesn’t respond. You keep track of the time it takes to complete the TCP handshake and consider this duration 2 the ping interval between your host and the remote host. If you encounter a temporary error (for example, a time-out), you’ll continue trying, and you’ll exit if the error is permanent 3. This is handy if you restart a TCP service and want to monitor its progress in restarting. Initially, the code in Listing 4-22 will report time-out errors, but it will eventually start printing valid results when the service is again listening on the specific port.    It’s important to understand that system admins could consider the code in Listing 4-22 abusive, especially if you specify a large ping count. That’s because you aren’t simply asking the remote host to send an echo reply using ICMP. Instead, you’re rapidly establishing and tearing down a TCP connection with every interval. Establishing a TCP connection has more overhead than an ICMP echo request and response. I recommend that you use this method only when intermediate firewalls filter ICMP echo messages and, even then, with the permission of the system admin.    ## Exploring Go’s TCPConn Object    For most use cases, the `net.Conn` interface will provide adequate functionality and the best cross-platform support for TCP sessions between nodes. But accessing the underlying `net.TCPConn` object allows fine-grained control over the TCP network connection should you need to do such things as modify the read and write buffers, enable keepalive messages, or change the behavior of pending data upon closing the connection. The `net.TCPConn` object is the concrete object that implements the `net.Conn` interface. Keep in mind that not all the following functionality may be available on your target operating system.    The easiest way to retrieve the `net.TCPConn` object is by using a type assertion. This works for connections where the underlying network is TCP:    ``` tcpConn, ok := conn.(*net.TCPConn) ```    On the server side, you can use the `AcceptTCP` method on a `net.TCPListener`, as shown in Listing 4-23, to retrieve the `net.TCPConn` object.    ``` addr, err := net.ResolveTCPAddr("tcp", "127.0.0.1:")  if err != nil {      return err  }    listener, err := net.ListenTCP("tcp", addr)  if err != nil {      return err  }    tcpConn, err := listener.AcceptTCP() ```    Listing 4-23: Retrieving `net.TCPConn` from the listener    On the client side, use the `net.DialTCP` function, as shown in Listing 4-24.    ``` addr, err := net.ResolveTCPAddr("tcp", "www.google.com:http")  if err != nil {      return err  }    tcpConn, err := net.DialTCP("tcp", nil, addr) ```    Listing 4-24: Using `DialTCP` to retrieve a `net.TCPConn` object    The next few sections cover useful methods on `net.TCPConn` that are unavailable on `net.Conn`. Some of these methods may not be available on your target operating system or may have hard limits imposed by the operating system. My advice is to use the following methods only when necessary. Altering these settings on the connection object from the operating system defaults may lead to network behavior that’s difficult to debug. For example, shrinking the read buffer on a network connection may lead to unexpected zero window issues unexplained by checking the operating system’s default read buffer value.    ### Controlling Keepalive Messages    A *keepalive* is a message sent over a network connection to check the connection’s integrity by prompting an acknowledgment of the message from the receiver. After an operating system–specified number of unacknowledged keepalive messages, the operating system will close the connection.    The operating system configuration dictates whether a connection uses keepalives for TCP sessions by default. If you need to enable keepalives on a `net.TCPConn` object, pass `true` to its `SetKeepAlive` method:    ``` err := tcpConn.SetKeepAlive(true) ```    You also have control over how often the connection sends keepalive messages using the `SetKeepAlivePeriod` method. This method accepts a `time.Duration` that dictates the keepalive message interval:    ``` err := tcpConn.SetKeepAlivePeriod(time.Minute) ```    Using deadlines advanced by a heartbeat is usually the better method for detecting network problems. As mentioned earlier in this chapter, deadlines provide better cross-platform support, traverse firewalls better, and make sure your application is actively managing the network connection.    ### Handling Pending Data on Close    By default, if you’ve written data to `net.Conn` but the data has yet to be sent to or acknowledged by the receiver and you close the network connection, your operating system will complete the delivery in the background. If you don’t want this behavior, the `net.TCPConn` object’s `SetLinger` method allows you to tweak it:    ``` err := tcpConn.SetLinger(-1) // anything < 0 uses the default behavior ```    With the linger disabled, it is possible that the server may receive the last portion of data you send along with your FIN when you close your connection. Since your call to `conn.Close` doesn’t block, you have no way of knowing whether the server received the data you just sent prior to your FIN. It’s possible the data sat in the server’s receive buffer and then the server crashed, taking your unacknowledged data and FIN with it. Lingering on the connection to give the server time to acknowledge the data may seem tempting. But this won’t solve your problem if the server crashes, as in the example. Also, some developers may argue that using linger for this purpose is a code smell. Your application should instead verify that the server received all data before tearing down its connection if this last bit of unacknowledged data is a concern.    If you wish to abruptly discard all unsent data and ignore acknowledgments of sent data upon closing the network connection, set the connection’s linger to zero:    ``` err := tcpConn.SetLinger(0) // immediately discard unsent data on close ```    Setting linger to zero will cause your connection to send an RST packet when your code calls your connection’s `Close` method, aborting the connection and bypassing the normal teardown procedures.    If you’re looking for a happy medium and your operating system supports it, you can pass a positive integer *n* to `SetLinger`. Your operating system will attempt to complete delivery of all outstanding data up to *n* seconds, after which point your operating system will discard any unsent or unacknowledged data:    ``` err := tcpConn.SetLinger(10) // discard unsent data after 10 seconds ```    If you feel compelled to modify your connection’s linger value, please read up on how your operating system handles lingering on network connections. When in doubt, use the default value.    ### Overriding Default Receive and Send Buffers    Your operating system assigns read and write buffers to each network connection you create in your code. For most cases, those values should be enough. But in the event you want greater control over the read or write buffer sizes, you can tweak their value, as demonstrated in Listing 4-25.    ``` if err := tcpConn.SetReadBuffer(212992); err != nil {      return err  }    if err := tcpConn.SetWriteBuffer(212992); err != nil {      return err  } ```    Listing 4-25: Setting read and write buffer sizes on a TCP connection    The `SetReadBuffer` method accepts an integer representing the connection’s read buffer size in bytes. Likewise, the `SetWriteBuffer` method accepts an integer and sets the write buffer size in bytes on the connection. Keep in mind that you can’t exceed your operating system’s maximum value for either buffer size.    ## Solving Common Go TCP Network Problems    Go doesn’t hold your hand when working with TCP network connections. As such, it’s possible to introduce bugs in your code that manifest as network errors. This section presents two common TCP networking issues: zero window errors and sockets stuck in the CLOSE_WAIT state.    ### Zero Window Errors    We spent a bit of time in “Receive Buffers and Window Sizes” on page 48 discussing TCP’s sliding window and how the window size tells the sender how much data the receiver can accept before the next acknowledgment. A common workflow when reading from a network connection is to read some data from the connection, handle the data, read more data from the connection, handle it, and so on.    But what happens if you don’t read data from a network connection quickly enough? Eventually, the sender may fill the receiver’s receive buffer, resulting in a zero-window state. The receiver will not be able to receive data until the application reads data from the buffer. This most often happens when the handling of data read from a network connection blocks and the code never makes its way around to reading from the socket again, as shown in Listing 4-26.    ``` buf := make([]byte, 1024)    for {      1 n, err := conn.Read(buf)      if err != nil {          return err      }        2 handle(buf[:n]) // BLOCKS!  } ```    Listing 4-26: Handling received data blocks preventing iteration around the loop    Reading data from the network connection 1 frees up receive buffer space. If the code blocks for an appreciable amount of time while handling the received data 2, the receive buffer may fill up. A full receive buffer isn’t necessarily bad. Zeroing the window is a way to *throttle*, or slow, the flow of data from the sender by creating backpressure on the sender. But if it’s unintended or prolonged, a zero window may indicate a bug in your code.    ### Sockets Stuck in the CLOSE_WAIT State    In “Gracefully Terminating TCP Sessions” on page 50, I mentioned that the server side of a TCP network connection will enter the CLOSE_WAIT state after it receives and acknowledges the FIN packet from the client. If you see TCP sockets on your server that persist in the CLOSE_WAIT state, it’s likely your code is neglecting to properly call the `Close` method on its network connections, as in Listing 4-27.    ``` for {      conn, err := listener.Accept()      if err != nil {          return err      }        1 go func(c net.Conn) { // we never call c.Close() before returning!          buf := make([]byte, 1024)            for {              n, err := c.Read(buf)              if err != nil {                 2  return              }                handle(buf[:n])          }      }(conn)  } ```    Listing 4-27: Returning from a connection-handling goroutine without properly closing the connection    The listener handles each connection in its own goroutine 1. However, the goroutine fails to call the connection’s `Close` method before fully returning from the goroutine 2. Even a temporary error will cause the goroutine to return. And because you never close the connection, this will leave the TCP socket in the CLOSE_WAIT state. If the server attempted to send anything other than a FIN packet to the client, the client would respond with an RST packet, abruptly tearing down the connection. The solution is to make sure to defer a call to the connection’s `Close` method soon after creating the goroutine 1.    ## What You’ve Learned    In this chapter, you first learned several methods of reading data from and writing data to a network connection, including the type-length-value encoding scheme. You built on this knowledge and learned an efficient way to proxy data between network connections. Next, you used a few `io` tools to monitor network traffic. Then, you used your knowledge of TCP handshakes to ping remote hosts in environments where ICMP echo requests and replies are filtered. Finally, the chapter wrapped up by covering the more platform-specific, yet powerful, methods provided by the `net.TCPConn` object and a few common connection-handling bugs.````
