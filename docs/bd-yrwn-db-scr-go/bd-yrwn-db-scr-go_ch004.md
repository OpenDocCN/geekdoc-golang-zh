# 03. B-树与崩溃恢复

## 3.1 B 树作为平衡 n 叉树

### 高度平衡树

许多实际的二叉树，如[AVL 树](https://build-your-own.org/redis/10_avltree)或 RB 树，被称为*高度平衡树*，这意味着树的高度（从根到叶子）限制为*O*(log(*N*))，因此查找是*O*(log(*N*))。

B 树也是高度平衡的；所有叶子节点的高度相同。

### 通用二叉树

n 叉树可以从二叉树（反之亦然）泛化。一个例子是 2-3-4 树，它是一种每个节点可以有 2、3 或 4 个子节点的 B 树。2-3-4 树与 RB 树等价。然而，我们不会深入探讨细节，因为它们对于理解 B 树不是必要的。

可视化一个排序序列[1, 2, 3, 4, 6, 9, 11, 12]的 2 级 B+树。

```go
 [1,   4,   9]
     /     |     \
    v      v      v
[1, 2, 3] [4, 6] [9, 11, 12]
```

在 B+树中，只有叶子节点包含值，键在内部节点中重复以指示子树的关键范围。在这个例子中，节点[1, 4, 9]表示其 3 个子树位于区间[1, 4)，[4, 9)，和[9, +∞)内。然而，对于 3 个区间只需要 2 个键，所以第一个键（1）可以省略，3 个区间变为(-∞, 4)，[4, 9)，和(9, +∞)。

## 3.2 B 树作为嵌套数组

### 两级嵌套数组

在不知道 RB 树或 2-3-4 树的具体细节的情况下，可以从排序数组理解 B 树。

排序数组的问题在于*O*(N)更新。如果我们把数组分成*m*个更小的非重叠数组，更新变为*O*(N/*m*)。但我们必须首先找出哪个小数组需要更新/查询。因此，我们需要另一个指向较小数组的引用的排序数组，这就是 B+树中的内部节点。

```go
[[1,2,3], [4,6], [9,11,12]]
```

查找成本仍然是*O*(log(*N*))，使用两次二分搜索。如果我们选择*m*为√*N*，更新变为*O*(√*N*)，这和 2 级排序数组一样好。

### 多级嵌套数组

*O*(√*N*)对于数据库是不可接受的，但如果我们通过进一步分割数组来添加更多层级，成本会进一步降低。

假设我们继续分割层级，直到所有数组都不大于一个常数*s*，我们最终会有 log(*N*/*s*)个层级，查找成本是*O*(log(*N*/*s*) + log(*s*))，这仍然是*O*(log(*N*))。

对于插入和删除，在找到叶子节点后，更新叶子节点大多数情况下是常数*O*(s*)。剩下的问题是维护节点不大于*s*且不为空的不变量。

## 3.3 维护 B+树

更新 B+树时需要保持的 3 个不变量：

1.  所有叶子节点具有相同的高度。

1.  节点大小由一个常数限制。

1.  节点不为空。

### 通过分割节点来增长 B 树

在插入到叶子节点时违反了第二个不变量，通过将节点分割成更小的节点来恢复。

```go
 parent              parent
   /  |  \     =>      /  | |  \
L1   L2   L6         L1  L3 L4  L6
     *                   *  *
```

在分割一个叶子节点后，其父节点会得到一个新的分支，这个分支也可能超过大小限制，因此它可能也需要分割。节点分割可以传播到根节点，增加 1 的高度。

```go
 new_root
                          / \
    root                 N1 N2
   /  |  \     =>      /  | |  \
L1   L2   L6         L1  L3 L4  L6
```

这保留了第 1 个不变量，因为所有叶子同时增加高度 1。

### 通过合并节点缩小 B 树

删除可能会导致空节点。第 3 个不变量通过将空节点合并到兄弟节点中得以恢复。合并是分割的反义词。它也可以传播到根节点，因此树的高度可以降低。

当编码 B 树时，可以在减少浪费空间之前进行合并：可以在节点大小达到下限时合并非空节点。

## 3.4 磁盘上的 B 树

您可以使用这些原则编码内存中的 B 树。但磁盘上的 B 树需要额外的考虑。

### 基于块的分配

一个缺失的细节是如何限制节点大小。对于内存中的 B+树，您可以限制节点中的最大键数，节点大小以字节为单位不是问题，因为您可以分配所需的任何字节。

对于基于磁盘的数据结构，没有`malloc/free`或垃圾回收器可以依赖；空间分配和重用完全取决于我们。

如果所有分配都是**相同大小**的，可以使用*空闲列表*来重用空间，我们将在稍后实现。目前，所有 B 树节点都是相同大小。

### 写时复制 B 树的安全更新

我们已经看到了 3 种抗崩溃的磁盘数据更新方法：重命名文件、日志、LSM 树。教训是**在更新过程中不要破坏任何旧数据**。这个想法可以应用于树：复制节点并修改副本。

插入或删除从叶节点开始；在修改后制作副本后，其父节点必须更新以指向新节点，这也在其副本上完成。复制会传播到根节点，导致新的树根。

+   原始树保持完整，并且可以从旧根访问。

+   新根，从更新的副本到叶子，与原始树共享所有其他节点。

```go
 d           d         D*
   / \         / \       / \
  b   e  ==>  b   e  +  B*  e
 / \         / \       / \
a   c       a   c     a   C*
            original  updated
```

这是更新叶节点 c 的可视化。复制的节点为大写（D，B，C），而共享的子树为小写（a，e）。

这被称为*写时复制*数据结构。它也被描述为*不可变*、*追加-only*（不是字面意思）、或*持久*（与耐用性无关）。请注意，数据库术语没有一致的含义。

写时复制 B 树还有 2 个问题待解决

1.  如何找到树根，因为它在每次更新后都会改变？崩溃安全性问题简化为单个指针更新，我们将在稍后解决。

1.  如何重用旧版本的节点？这是空闲列表的工作。

### 写时复制 B 树的优点

保留旧版本的一个优点是我们可以免费获得*快照隔离*。事务从一个树版本开始，不会看到其他版本的变化。

并且崩溃恢复毫不费力；只需使用最后一个旧版本。

另一个优点是它适合多读单写并发模型，并且读者不会阻塞写者。我们将在稍后探讨这些。

### 替代方案：使用双重写入的就地更新

在基于写时复制的数据结构中，虽然崩溃恢复是显而易见的，但由于写放大率高，它们可能并不理想。每次更新都会复制整个路径（*O*(log *N*）），而大多数就地更新只需触及一个叶子节点。

可以在不使用写时复制的情况下进行就地更新并实现崩溃恢复：

1.  在某处保存整个更新节点的副本。这类似于写时复制，但不需要复制父节点。

1.  对保存的副本执行`fsync`。（此时可以响应用户。）

1.  实际上就地更新数据结构。

1.  对更新执行`fsync`。

崩溃后，数据结构可能只更新了一半，但我们实际上并不知道。我们做的事情是盲目地应用保存的副本，这样数据结构最终会以更新状态结束，而不管当前状态如何。

```go
| a=1 b=2 |
    ||  1\. Save a copy of the entire updated nodes.
    \/
| a=1 b=2 |   +   | a=2 b=4 |
   data           updated copy
    ||  2\. fsync the saved copies.
    \/
| a=1 b=2 |   +   | a=2 b=4 |
   data           updated copy (fsync'ed)
    ||  3\. Update the data structure in-place. But we crashed here!
    \/
| ??????? |   +   | a=2 b=4 |
   data (bad)     updated copy (good)
    ||  Recovery: apply the saved copy.
    \/
| a=2 b=4 |   +   | a=2 b=4 |
   data (new)     useless now
```

在 MySQL 术语中，保存的更新副本被称为[双重写入](https://www.percona.com/blog/innodb-double-write/)。但如果双重写入被损坏怎么办？它将以与日志相同的方式处理：校验和。

+   如果校验和检测到不良的双重写入，则忽略它。因为它在第一次`fsync`之前，所以主要数据处于良好且古老的状态。

+   如果双重写入是好的，应用它将始终产生良好的主要数据。

一些数据库实际上将双重写入存储在日志中，称为[物理日志](https://wiki.postgresql.org/wiki/Full_page_writes)。有两种类型的日志：*逻辑*和*物理*。逻辑日志描述了高级操作，如插入键，这些操作只能在数据库处于良好状态时应用于数据库，因此只有物理日志（低级磁盘页面更新）对恢复有用。

### 崩溃恢复原则

让我们比较双重写入和写时复制：

+   双重写入使更新*幂等*；数据库可以通过应用保存的副本来重试更新，因为它们是完整节点。

+   写时复制*原子性地*将所有内容切换到新版本。

它们基于不同的理念：

+   双重写入确保有足够的信息来生成新版本。

+   写时复制确保旧版本被保留。

如果我们保存原始节点而不是带有双重写入的更新节点会怎样？这是从损坏中恢复的第三种方法，它像写时复制一样恢复到旧版本。我们可以将这三种方法结合成一个想法：**在任何时刻都有足够的信息来表示旧状态或新状态**。

此外，一些复制始终是必需的，因此较大的树节点更新较慢。

我们将使用写时复制，因为它更简单，但你可以在这里偏离。

## 3.5 我们学到了什么

B+树原则：

+   n-叉树，节点大小受一个常数的限制。

+   所有叶子的高度相同。

+   插入和删除时的拆分和合并。

基于磁盘的数据结构：

+   写时复制数据结构。

+   基于双重写入的崩溃恢复。

我们现在可以开始编码了。基于 B+树创建持久化 KV 的 3 个步骤：

1.  编码 B+树数据结构。

1.  将 B+树移动到磁盘。

1.  添加一个空闲列表。
