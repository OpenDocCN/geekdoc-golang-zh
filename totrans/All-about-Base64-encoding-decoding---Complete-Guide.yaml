- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-10-13 06:33:36'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: All about Base64 encoding/decoding – Complete Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://golangbyexample.com/base64-complete-guide/](https://golangbyexample.com/base64-complete-guide/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '**   [Overview](#Overview "Overview")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why Base64 encoding is needed](#Why_Base64_encoding_is_needed "Why Base64
    encoding is needed")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Base64 encoding/decoding works](#How_Base64_encodingdecoding_works "How
    Base64 encoding/decoding works")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Base64 Decoding](#Base64_Decoding "Base64 Decoding")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Is Padding Necessary](#Is_Padding_Necessary "Is Padding Necessary")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Size](#Size "Size")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Base64 Alternatives](#Base64_Alternatives "Base64 Alternatives")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Base64 Other Implementations](#Base64_Other_Implementations "Base64 Other
    Implementations")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Base64 Applications](#Base64_Applications "Base64 Applications")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")*  *# **Overview**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64 is also known as Base64 Content-Transfer-Encoding. Base64 is the encoding
    of binary data into ASCII text. But it uses only 64 characters and plus one padding
    character which are present in the most character set. So it is a way of representing
    binary data using only printable characters.  These printable characters are
  prefs: []
  type: TYPE_NORMAL
- en: Lowercase Alphabets **a-z**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UpperCase Alphabets **A-Z**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers **0-9**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characters **+** an **/**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**=** is used as a padding character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64 encoding is used for transferring data over a medium that doesn’t handle
    binary data correctly. So Base64 encoding of data is done to make sure that the
    data remains intact without any modification through this media. A base 64 encoding
    will look like as below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Why Base64 encoding is needed**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s talk about history to know why base64 was needed.  Initially, when the
    mailing system was started it was only text which was transferred through email.
    Later on, the email also started supporting attachments which including video
    and audio. Video and audio are binary data and when binary data is transferred
    over the internet there are good chances of it being corrupt. The question is
    why. Some media such as email support only textual data. They are only meant for
    streaming text and as such these protocols might interpret your binary data as
    control characters or some special characters in the binary data may be interpreted
    differently. The problem with binary data is that some characters in the binary
    data might have special meaning in some media. In other words, these media are
    not 8 bit clean and are only meant to handle textual data.
  prefs: []
  type: TYPE_NORMAL
- en: So base64 was meant for media that does not support binary data and which work
    with only textual characters. As it is guaranteed that data won’t be corrupted.
    It is mostly needed for legacy systems that work with only ASCII data.
  prefs: []
  type: TYPE_NORMAL
- en: But why 64 characters and not more. These 64 characters are present in most
    character sets so you can be reasonably confident that your data will the other
    end without any corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is encoding and not encryption. What’s the difference between encoding
    and encryption?
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding**'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding means transforming data into another format so that it can be properly
    consumed by a system that only understands the converted format. Encoding is just
    an algorithm that is publicly available. There is no secret key involved and is
    reversible. So anyone knowing the algorithm can simply reverse and get the original
    data. Now the question is why it is needed. Some of the transfer media only understand
    textual data or a certain number of characters. Your binary data cannot be transferred
    through such a medium as there are chances of data being getting corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding doesn’t provide any kind of security, instead, it is only meant for
    compatibility across different media which understand different format
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is meant for confidentiality. It is always protected by a key and
    it meant to be decrypted by anyone who knows the key. So in the case of encryption,
    the data can only be reversed by someone who possesses the key.
  prefs: []
  type: TYPE_NORMAL
- en: For eg sending a password over the network. In this case, we encrypt the password
    so that any unintended person cannot read it. Example HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: So essentially encoding is meant for compatibility and not for encryption.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Base64 encoding/decoding works**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Base64 encoding is described in [https://tools.ietf.org/html/rfc4648](https://tools.ietf.org/html/rfc4648)
  prefs: []
  type: TYPE_NORMAL
- en: Base64 encoding will translate every 3 bytes of data into 4 encoded characters.
    It will start scanning from left to right, and then it will select the first 3
    bytes of data representing 3 characters. These 3 bytes will be 24 bits. Now it
    will divide these 24 bits into four parts of 6 bits each. Then each 6-bit group
    will be indexed in the below table to get the mapped character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s understand it with an example. Let’s say we have the below string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The bits representation of the above string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These total 24 bits will be grouped into 4 groups of 6 bits each
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The numeric representation of the above bits is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Use the above numbers to index into the base64 table. Below will the mapping
  prefs: []
  type: TYPE_NORMAL
- en: '| 24 | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | W |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | J |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | A |'
  prefs: []
  type: TYPE_TB
- en: So the base64 encoded string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What if the input string is not in multiples of 3? In this case padding character
    **=** will come in the picture
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say the input string has 4 characters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The bits representation of the above string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first three bytes will be group together. The last bytes will be padded
    with 4 extra zero to make the overall bits divisible by 6.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Use the above numbers to index into the above table. Below will the mapping
  prefs: []
  type: TYPE_NORMAL
- en: '| 24 | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | W |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | J |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 48 | w |'
  prefs: []
  type: TYPE_TB
- en: This will become
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each two extra zero is represented by = character. And since we added 4 extra
    zero, Hence two = at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see another example in which the input string has 5 characters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The bits representation of the above string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first three bytes will be group together. The last two bytes will be grouped
    together and padded with 2 extra zero to make the overall bits divisible by 6.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Use the above numbers to index into the above table. Below will the mapping
  prefs: []
  type: TYPE_NORMAL
- en: '| 24 | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | W |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | J |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 54 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | Q |'
  prefs: []
  type: TYPE_TB
- en: This will become
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each two extra zero is represented by = character. And since we added 2 extra
    zero, Hence one single = at the end. Also, note that each of the base encoded
    string length with padding is multiple of four
  prefs: []
  type: TYPE_NORMAL
- en: '| **Actual String** | **Base64** **Encoded** **String** | **Length** |'
  prefs: []
  type: TYPE_TB
- en: '| ab@ | YWJA | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| ab@c | YWJAYw== | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| ab@cd | YWJAY2Q= | 8 |'
  prefs: []
  type: TYPE_TB
- en: For encoding, we have only three cases that we had discussed above
  prefs: []
  type: TYPE_NORMAL
- en: The number of bits in the input string is divisible by 6\. No padding is added.
    Eg ab@
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of bits in the input string is not divisible by 6 and the remainder
    is 4\. A double == padding will be added.Eg ab@c
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of bits is not divisible 6 by and the remainder is 2\. A single =
    padding will be added.  Eg ab@cd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now the question which comes to mind is whether padding necessary. The answer
    is that it depends. We will discuss it after we have seen how decoding works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Base64 Decoding**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now decode the base64 encoded string into the original string. Decoding
    is the opposite of encoding. Let’s take the example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Group into multiple of 4 characters each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now remove the trailing = characters from each of the groups. For the remaining
    string convert it into their corresponding bit representation from the above table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now do grouping into a group of 8 bits. Leave the trailing zeros. This is to
    account for trailing = added. The trailing zero will be either 00 or 0000
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now for each of the byte above, assign the character as per the ASCII table
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Hence the final string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Why did we group the Base64 encoded string into groups of 4 for decoding? The
    reason is because of padding and it will get clear in the next section
  prefs: []
  type: TYPE_NORMAL
- en: '**Is Padding Necessary**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering now whether the padding of = is necessary for base64
    encoding or not, since we simply discarded the padding while decoding. The answer
    is that it depends
  prefs: []
  type: TYPE_NORMAL
- en: Padding is not necessary when you are sending a single string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding is important when you are concatenating base64 encodings of multiple
    strings. If unpadded strings are concatenated then it will be impossible to get
    the original string as information about the bytes added will be lost. As an illustration,
    consider below
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Actual String** | **Base64 Encoded with Padding** | **Base64 Encoded without
    Padding** |'
  prefs: []
  type: TYPE_TB
- en: '| a | YQ== | YQ |'
  prefs: []
  type: TYPE_TB
- en: '| bc | YmM= | YmM |'
  prefs: []
  type: TYPE_TB
- en: '| def | ZGVm | ZGVm |'
  prefs: []
  type: TYPE_TB
- en: Now let’s consider both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**When the concatenation is sent without padding**'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the concatenated Base64 string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Try decoding it and you will get the final string as below which is incorrect
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**When the concatenation is sent with padding**'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the concatenated Base64 string will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Try decoding it in groups of 4 characters and you will get the final string
    as below which is correct
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now again the question that comes to mind is why do you need to concatenate
    multiple base64 encoded strings. The answer is that it is always good in cases
    where there is streaming data and you want to send the base64 encoded data as
    it comes. For example, buffering of video.
  prefs: []
  type: TYPE_NORMAL
- en: So that is why padding is encouraged though not absolutely not necessary in
    all cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since essentially Base64 encodes 3 bytes to 4 ASCII characters in case of padding.
    Each of the four ASCII characters will send as 1 byte each over the network. Hence
    the resultant size will always be 33.33% more than the original. So if the original
    size of the string  is n bytes then size, after base64 encode, will be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Base64 Alternatives**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other options available for encoding as well, but some of them
    are significantly harder while others take too much space. For example, there
    is Base 80 which takes less space but is significantly harder as anything to the
    power two are natural bases for binary. Also there is hexadecimal encoding. It
    is simple but takes more space.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal – It has a character set of 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base36 – Case insensitive encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other alternatives as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Base64 Other Implementations**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two other base64 implementations exist
  prefs: []
  type: TYPE_NORMAL
- en: Base64 for URL. In this, the **‘+’** and **‘\’** sign is replaced with **‘+’**
    and **‘-‘**. This is because **‘+’** and **‘\’**  are further encoded into hexadecimal
    sequences due to URL encoding thereby further increasing the length of the URL.
    For eg **‘+’** will be converted to ‘%2B’ and **‘\’** will be encoded to ‘%2F’
    in the URL encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64 for filenames. In this ‘\’ is replaced with **‘-‘**. This is because
    the **‘\’** is used in file paths in both Unix and Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base64 Applications**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary data transfer in emails for eg sending video and audio as email attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Auth is sent as Base64 encoded in the HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other Base64 applications as well
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is all about Base64 encoding. Hope you have liked this article. Please
    share feedback in the comments*
  prefs: []
  type: TYPE_NORMAL
