["```go\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n    \"time\"\n)\n\nfunc resolveWithTracing(ctx context.Context, hostname string) ([]string, error) {\n    start := time.Now()\n    ips, err := net.DefaultResolver.LookupHost(ctx, hostname)\n    elapsed := time.Since(start)\n\n    log.Printf(\"dns: host=%s duration=%s ips=%v err=%v\", hostname, elapsed, ips, err)\n    return ips, err\n} \n```", "```go\nfunc dialWithTracing(ctx context.Context, network, addr string) (net.Conn, error) {\n    var d net.Dialer\n    start := time.Now()\n    conn, err := d.DialContext(ctx, network, addr)\n    elapsed := time.Since(start)\n\n    log.Printf(\"dial: addr=%s duration=%s err=%v\", addr, elapsed, err)\n    return conn, err\n} \n```", "```go\nimport (\n    \"crypto/tls\"\n)\n\nfunc handshakeWithTracing(conn net.Conn, config *tls.Config) (*tls.Conn, error) {\n    tlsConn := tls.Client(conn, config)\n    start := time.Now()\n    err := tlsConn.Handshake()\n    elapsed := time.Since(start)\n\n    log.Printf(\"handshake: duration=%s err=%v\", elapsed, err)\n    return tlsConn, err\n} \n```", "```go\ntype tracedConn struct {\n    net.Conn\n}\n\nfunc (c *tracedConn) Read(b []byte) (int, error) {\n    start := time.Now()\n    n, err := c.Conn.Read(b)\n    elapsed := time.Since(start)\n\n    log.Printf(\"read: bytes=%d duration=%s err=%v\", n, elapsed, err)\n    return n, err\n}\n\nfunc (c *tracedConn) Write(b []byte) (int, error) {\n    start := time.Now()\n    n, err := c.Conn.Write(b)\n    elapsed := time.Since(start)\n\n    log.Printf(\"write: bytes=%d duration=%s err=%v\", n, elapsed, err)\n    return n, err\n} \n```", "```go\nfunc closeWithTracing(c net.Conn) error {\n    start := time.Now()\n    err := c.Close()\n    elapsed := time.Since(start)\n\n    log.Printf(\"close: duration=%s err=%v\", elapsed, err)\n    return err\n} \n```", "```go\nimport (\n    \"go.opentelemetry.io/otel/trace\"\n)\n\nfunc tracePhase(ctx context.Context, tracer trace.Tracer, phase string, fn func() error) error {\n    ctx, span := tracer.Start(ctx, phase)\n    defer span.End()\n    return fn()\n} \n```", "```go\natomicLevel := zap.NewAtomicLevel()\nlogger := zap.New(zapcore.NewCore(\n    zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),\n    zapcore.AddSync(os.Stdout),\n    atomicLevel,\n))\n\n// Adjust at runtime\natomicLevel.SetLevel(zap.WarnLevel) \n```", "```go\ncore := zapcore.NewSamplerWithOptions(\n    logger.Core(),\n    time.Second,\n    100, // first 100 per second\n    10,  // thereafter\n)\nlogger := zap.New(core) \n```", "```go\nphases := map[string]time.Duration{\n    \"dns\": 10 * time.Millisecond,\n    \"dial\": 40 * time.Millisecond,\n    \"handshake\": 50 * time.Millisecond,\n}\nlogger.Info(\"connection completed\", zap.Any(\"phases\", phases)) \n```", "```go\nimport (\n    \"go.uber.org/zap\"\n)\n\nvar logger, _ = zap.NewProduction()\n\nlogger.Info(\"dns\",\n    zap.String(\"host\", hostname),\n    zap.Duration(\"duration\", elapsed),\n    zap.Strings(\"ips\", ips),\n    zap.Error(err),\n) \n```"]