# 关于 Base64 编码/解码的全部内容——完整指南

> 原文：<https://golangbyexample.com/base64-complete-guide/>

# **概述**

Base64 也称为 Base64 内容传输编码。Base64 是将二进制数据编码成 ASCII 文本。但是它只使用了 64 个字符和一个填充字符，这在大多数字符集中都存在。因此，这是一种仅使用可打印字符来表示二进制数据的方式。这些可打印字符是

*   小写字母 **a-z**
*   大写字母 **A-Z**
*   数字 **0-9**
*   人物 **+** 一 **/**
*   **=** 用作填充字符

Base64 编码用于在不能正确处理二进制数据的介质上传输数据。所以对数据进行 Base64 编码是为了确保数据保持完整，不通过该介质进行任何修改。基本 64 编码如下所示

```go
OWRjNGJjMDY5MzVmNGViMGExZTdkMzNjOGMwZTI3ZWI==
```

# **为什么需要 Base64 编码**

让我们谈谈历史，了解为什么需要 base64。最初，当邮件系统启动时，只有文本通过电子邮件传输。后来，电子邮件也开始支持附件，包括视频和音频。视频和音频是二进制数据，当二进制数据通过互联网传输时，很有可能被破坏。问题是为什么。电子邮件等一些媒体仅支持文本数据。它们仅用于流文本，因此这些协议可能会将您的二进制数据解释为控制字符，或者二进制数据中的某些特殊字符可能会有不同的解释。二进制数据的问题在于，二进制数据中的某些字符在某些媒体中可能有特殊的含义。换句话说，这些介质不是 8 位干净的，只是用来处理文本数据的。

所以 base64 是为不支持二进制数据的媒体设计的，并且只支持文本字符。因为可以保证数据不会被破坏。它主要用于只处理 ASCII 数据的遗留系统。

但是为什么是 64 个字符而不是更多。这 64 个字符出现在大多数字符集中，因此您可以有理由相信您的数据会在没有任何损坏的情况下到达另一端。

请注意，它是编码而不是加密。编码和加密有什么区别？

**编码**

编码意味着将数据转换成另一种格式，以便仅理解转换格式的系统能够正确使用。编码只是一种公开可用的算法。不涉及任何密钥，并且是可逆的。因此，任何知道算法的人都可以简单地反转并获得原始数据。现在的问题是为什么需要它。一些传输介质只理解文本数据或一定数量的字符。您的二进制数据不能通过这样的介质传输，因为数据有可能被损坏。

编码不提供任何种类的安全性，相反，它只是为了在理解不同格式的不同媒体之间的兼容性

**加密**

加密是为了保密。它总是受到密钥的保护，任何知道密钥的人都可以解密。所以在加密的情况下，数据只能由拥有密钥的人来反转。

例如通过网络发送密码。在这种情况下，我们对密码进行加密，这样任何非预期的人都无法读取它。HTTPS 的例子

所以编码本质上是为了兼容性，而不是为了加密。

# **Base64 编码/解码如何工作**

Base64 编码描述于[https://tools.ietf.org/html/rfc4648](https://tools.ietf.org/html/rfc4648)

Base64 编码将每 3 个字节的数据转换为 4 个编码字符。它将从左到右开始扫描，然后选择代表 3 个字符的前 3 个字节的数据。这 3 个字节将是 24 位。现在，它将把这 24 位分成 4 个部分，每个部分 6 位。然后每个 6 位组将在下表中被索引以获得映射的字符。

```go
 Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (pad) =
        15 P            32 g            49 x
        16 Q            33 h            50 y
```

我们用一个例子来理解。假设我们有下面的字符串

```go
[[email protected]](/cdn-cgi/l/email-protection)
```

上述字符串的位表示将为

```go
 a          b        @
01100001  01100010  01000000
```

这总共 24 位将被分成 4 组，每组 6 位

```go
011000 010110 001001 000000
```

上述位的数字表示为

```go
 24    22     9      0
011000 010110 001001 000000
```

使用上面的数字来索引 base64 表。下面将映射

<figure class="wp-block-table">

| Twenty-four | Y |
| Twenty-two | W |
| nine | J |
| Zero | A |

</figure>

所以 base64 编码的字符串将是

```go
YWJA
```

如果输入字符串不是 3 的倍数呢？在这种情况下，图片中将出现填充字符 **=**

假设输入字符串有 4 个字符

```go
[[email protected]](/cdn-cgi/l/email-protection)
```

上述字符串的位表示将为

```go
 a          b        @        c
01100001  01100010  01000000 01100011
```

前三个字节将被分组在一起。最后一个字节将被 4 个额外的零填充，以使所有的位能被 6 整除。

```go
011000 010110 001001 000000 011000 110000
  24     22     9      0      24     48
```

用上面的数字来索引上表。下面将映射

<figure class="wp-block-table">

| Twenty-four | Y |
| Twenty-two | W |
| nine | J |
| Zero | A |
| Twenty-four | Y |
| Forty-eight | w |

</figure>

这将成为

```go
YWJAYw==
```

每两个额外的零由=字符表示。因为我们加了 4 个额外的零，所以最后是 2。

现在让我们看另一个例子，其中输入字符串有 5 个字符

```go
[[email protected]](/cdn-cgi/l/email-protection)
```

上述字符串的位表示将为

```go
 a          b        @        c       d
01100001  01100010  01000000 01100011 01100100
```

前三个字节将被分组在一起。最后两个字节将被分组在一起，并用两个额外的零填充，以使总的位可被 6 整除。

```go
011000 010110 001001 000000 011000 110110 010000
  24     22     9      0      24     54     16
```

用上面的数字来索引上表。下面将映射

<figure class="wp-block-table">

| Twenty-four | Y |
| Twenty-two | W |
| nine | J |
| Zero | A |
| Twenty-four | Y |
| Fifty-four | Two |
| Sixteen | Q |

</figure>

这将成为

```go
YWJAY2Q=
```

每两个额外的零由=字符表示。因为我们加了两个额外的零，所以最后有一个单= 0。此外，请注意，每个带有填充的基本编码字符串长度都是 4 的倍数

<figure class="wp-block-table">

| **实际字符串** | **Base64**T2 编码**字符串** | **长度** |
| [【邮件保护】](/cdn-cgi/l/email-protection) | 是啊 | four |
| [【邮件保护】](/cdn-cgi/l/email-protection) | YWJAYw== | eight |
| [【邮件保护】](/cdn-cgi/l/email-protection) | yjay 2q = | eight |

</figure>

对于编码，我们只有上面讨论过的三种情况

*   输入字符串中的位数可被 6 整除。不添加填充。例如[【电子邮件保护】](/cdn-cgi/l/email-protection)

*   输入字符串中的位数不能被 6 整除，余数是 4。将添加一个 double ==填充。例如[【电子邮件保护】](/cdn-cgi/l/email-protection)

*   位数不能被 6 整除，余数是 2。将添加一个 single =填充。例如[【电子邮件保护】](/cdn-cgi/l/email-protection)

现在想到的问题是填充是否必要。答案是视情况而定。我们将在了解解码工作原理后讨论它。

# **Base64 解码**

现在让我们将 base64 编码的字符串解码为原始字符串。解码与编码相反。让我们举个例子

```go
YWJAY2Q=
```

每组 4 个字符。

```go
YWJA 
```

和

```go
Y2Q=
```

现在从每个组中删除尾部=字符。对于剩余的字符串，将其转换为上表中相应的位表示形式。

```go
 Y      W       J      A     
011000 010110 001001 000000
```

和

```go
 Y      2      Q
011000 110110 010000
```

现在分组为一组 8 位。留下尾随零。这是考虑到尾随=添加。尾随零将是 00 或 0000

```go
01100001  01100010  01000000 
```

和

```go
01100011 01100100
```

现在，对于上面的每个字节，按照 ASCII 表分配字符

```go
 01100001  01100010  01000000
   a          b        @ 
```

和

```go
01100011 01100100
  c       d
```

因此最后的字符串将是

```go
[[email protected]](/cdn-cgi/l/email-protection)
```

为什么我们把 Base64 编码的字符串分成 4 组进行解码？原因是因为填充，它将在下一节中变得清晰

# **填充有必要吗**

您现在可能想知道=的填充对于 base64 编码是否有必要，因为我们只是在解码时丢弃了填充。答案是视情况而定

*   发送单个字符串时不需要填充。

*   当您串联多个字符串的 base64 编码时，填充很重要。如果未添加的字符串连接在一起，那么就不可能获得原始字符串，因为关于添加的字节的信息将会丢失。举例来说，考虑以下内容

<figure class="wp-block-table">

| **实际字符串** | **以填充编码的 Base64** | **无填充编码的 Base64** |
| a | YQ== | y 长臂 |
| 公元前 | YmM= | 横向补偿量 |
| 极好的 | ZGVm | ZGVm |

</figure>

现在让我们考虑两种情况。

**在没有填充的情况下发送连接时**

在这种情况下，串联的 Base64 字符串将是

```go
YQYmMZGVm
```

试着解码它，你会得到如下不正确的最终字符串

```go
a&1
```

**当用填充发送连接时**

在这种情况下，串联的 Base64 字符串将是

```go
YQ==YmM=ZGVm
```

尝试以 4 个字符为一组对其进行解码，您将获得如下正确的最终字符串

```go
abcdef
```

现在再次想到的问题是为什么需要连接多个 base64 编码的字符串。答案是，在有流数据的情况下，当 base64 编码数据到来时，它总是好的。例如，视频的缓冲。

所以这就是为什么鼓励填充，虽然不是在所有情况下都绝对没有必要。

# **大小**

因为基本上 Base64 在填充的情况下编码 3 字节到 4 个 ASCII 字符。四个 ASCII 字符中的每一个都将作为一个字节通过网络发送。因此，最终的尺寸将总是比原始尺寸大 33.33%。因此，如果字符串的原始大小是 n 字节，那么在 base64 编码之后，大小将是

```go
n*4/3
```

# **Base64 替代品**

还有许多其他的编码选项，但是其中一些明显更难，而另一些占用太多空间。例如，Base 80 占用的空间更少，但明显更硬，因为二的幂是二进制的自然基数。还有十六进制编码。它很简单，但需要更多的空间。

*   十六进制–字符集为 16

*   base36–不区分大小写的编码

*   Base80

*   Base58

*   …

还有其他选择。

# **Base64 其他实现**

存在另外两种 base64 实现

*   网址的 Base64。在此，将**'+'****' \ '**符号替换为 **'+'** 和 **'-'** 。这是因为**“+”**和**“\”**由于 URL 编码而被进一步编码成十六进制序列，从而进一步增加了 URL 的长度。例如 **'+'** 将被转换为“%2B”，而 **'\'** 将在 URL 编码中被编码为“%2F”。

*   Base64 代表文件名。在本例中，' \ '被替换为 **'-'** 。这是因为在 Unix 和 Windows 的文件路径中都使用了**\ '**。

# **Base64 应用程序**

*   电子邮件中的二进制数据传输，例如作为电子邮件附件发送视频和音频

*   基本身份验证以编码在 HTTP 协议中的 Base64 形式发送

还有其他 Base64 应用程序

# **结论**

这都是关于 Base64 编码。希望你喜欢这篇文章。请在评论中分享反馈