["```go\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: ClientHello (supported ciphers, random)\n    Server->>Client: ServerHello (chosen cipher, random)\n    Server->>Client: Certificate\n    Server->>Client: ServerKeyExchange\n    Client->>Server: ClientKeyExchange\n    Client->>Server: ChangeCipherSpec\n    Server->>Client: ChangeCipherSpec\n    Note over Client,Server: Handshake Complete â€“ Encrypted communication begins\n```", "```go\ntlsConfig := &tls.Config{\n    SessionTicketsDisabled: false, // Enable session tickets explicitly\n    SessionTicketKey: [32]byte{...}, // Persist securely and rotate periodically\n} \n```", "```go\ntlsConfig := &tls.Config{\n    CipherSuites: []uint16{\n        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n    },\n    PreferServerCipherSuites: true,\n} \n```", "```go\ntlsConfig := &tls.Config{\n    NextProtos: []string{\"h2\", \"http/1.1\"},\n} \n```", "```go\ntlsConfig := &tls.Config{\n    ClientAuth: tls.RequireAndVerifyClientCert,\n    ClientCAs: certPool, // pre-verified CA pool\n    VerifyPeerCertificate: cachedCertVerifier, // custom verifier with caching\n} \n```", "```go\n// Cache to avoid re-verifying the same certificate repeatedly\nvar verificationCache sync.Map\n\n// cachedCertVerifier verifies a peer certificate chain and caches successful leaf fingerprints\nfunc cachedCertVerifier(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {\n    // Compute SHA-256 fingerprint of the leaf certificate\n    fingerprint := sha256.Sum256(rawCerts[0])\n    if _, exists := verificationCache.Load(fingerprint); exists {\n        // Already verified earlier; skip full verification\n        return nil\n    }\n\n    // Parse the leaf certificate\n    leafCert, err := x509.ParseCertificate(rawCerts[0])\n    if err != nil {\n        return fmt.Errorf(\"failed to parse leaf certificate: %w\", err)\n    }\n\n    // Build pool of intermediate certificates provided by peer\n    intermediatePool := x509.NewCertPool()\n    for _, raw := range rawCerts[1:] {\n        intermediateCert, err := x509.ParseCertificate(raw)\n        if err != nil {\n            return fmt.Errorf(\"failed to parse intermediate certificate: %w\", err)\n        }\n        intermediatePool.AddCert(intermediateCert)\n    }\n\n    // Prepare verification options with trusted roots & intermediates\n    opts := x509.VerifyOptions{\n        Roots:         certPool,                            // trusted root CAs\n        Intermediates: intermediatePool,                    // peer-provided intermediates\n        KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n    }\n\n    // Verify the full chain starting from leaf\n    chains, err := leafCert.Verify(opts)\n    if err == nil {\n        // Store successful verification in cache\n        verificationCache.Store(fingerprint, struct{}{})\n    }\n    return err\n} \n```", "```go\ntlsConfig := &tls.Config{\n    SessionTicketsDisabled: false,\n    SessionTicketKey: [32]byte{...},\n    CipherSuites: []uint16{\n        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n        tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n        tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n    },\n    PreferServerCipherSuites: true,\n    NextProtos: []string{\"h2\", \"http/1.1\"},\n    ClientAuth: tls.RequireAndVerifyClientCert,\n    ClientCAs: certPool,\n    VerifyPeerCertificate: cachedCertVerifier,\n    MinVersion: tls.VersionTLS12,\n    CurvePreferences: []tls.CurveID{tls.CurveP256, tls.X25519},\n} \n```"]