- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2024-10-13 06:30:58'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-10-13 06:30:58
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: All basic data types in Go (Golang)
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go（Golang）中的所有基本数据类型
- en: 来源：[https://golangbyexample.com/all-basic-data-types-golang/](https://golangbyexample.com/all-basic-data-types-golang/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://golangbyexample.com/all-basic-data-types-golang/](https://golangbyexample.com/all-basic-data-types-golang/)
- en: This is the  chapter 7 of the golang comprehensive tutorial series. Refer to
    this link for other chapters of the series – [Golang Comprehensive Tutorial Series](https://golangbyexample.com/golang-comprehensive-tutorial/)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Golang综合教程系列的第7章。有关该系列其他章节的信息，请参阅此链接 – [Golang综合教程系列](https://golangbyexample.com/golang-comprehensive-tutorial/)
- en: '**Next Tutorial** – [Functions](https://golangbyexample.com/function-golang-complete-guide/)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一教程** – [函数](https://golangbyexample.com/function-golang-complete-guide/)'
- en: '**Previous Tutorial** –[Variables](https://golangbyexample.com/variables-in-golang-complete-guide/)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**前一教程** –[变量](https://golangbyexample.com/variables-in-golang-complete-guide/)'
- en: Now let’s check out the current tutorial. Below is the table of contents for
    current tutorial.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们查看当前教程。以下是当前教程的目录。
- en: Table of Contents
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: '**   [Overview](#Overview "Overview")'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**[概述](#Overview "Overview")**'
- en: '[Basic Types](#Basic_Types "Basic Types")'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[基本类型](#Basic_Types "Basic Types")'
- en: '[Integers ](#Integers "Integers ")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[整数](#Integers "Integers")'
- en: '[Signed Integers](#Signed_Integers "Signed Integers")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[有符号整数](#Signed_Integers "Signed Integers")'
- en: '[UnSigned](#UnSigned "UnSigned")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无符号](#UnSigned "UnSigned")'
- en: '[Floats](#Floats "Floats")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浮点数](#Floats "Floats")'
- en: '[Complex Numbers](#Complex_Numbers "Complex Numbers")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[复数](#Complex_Numbers "Complex Numbers")'
- en: '[Byte](#Byte "Byte")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字节](#Byte "Byte")'
- en: '[Rune](#Rune "Rune")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符](#Rune "Rune")'
- en: '[String](#String "String")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串](#String "String")'
- en: '[Booleans](#Booleans "Booleans")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[布尔值](#Booleans "Booleans")'
- en: '[Conclusion](#Conclusion "Conclusion")*  *# **Overview**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#Conclusion "Conclusion")*  *# **概述**'
- en: Golang is a statically typed programming language meaning that each variable
    has a type. Go has several built-in types. Data types in Go can be categorized
    into two types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Golang是一种静态类型的编程语言，意味着每个变量都有一个类型。Go有几种内置类型。Go中的数据类型可以分为两种类型。
- en: Basic Types
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本类型
- en: Composite Types
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复合类型
- en: Basic Types
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型
- en: Integers
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: Signed
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号
- en: int
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int
- en: int8
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int8
- en: int16
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int16
- en: int32
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int32
- en: int64
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: int64
- en: Unsigned
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无符号
- en: uint
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint
- en: uint8
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint8
- en: uint16
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint16
- en: uint32
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint32
- en: uint64
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uint64
- en: uintptr
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: uintptr
- en: Floats
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: float32
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: float32
- en: float64
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: float64
- en: Complex Numbers
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复数
- en: complex64
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: complex64
- en: complex128
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: complex128
- en: Byte
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节
- en: Rune
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符
- en: String
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Composite Types
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合类型
- en: Collection/Aggregation or Non-Reference Types
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合/聚合或非引用类型
- en: Arrays
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Structs
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Reference Types
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: Slices
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Maps
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Channels
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Pointers
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针
- en: Function/Methods
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数/方法
- en: Interface
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Special case of empty Interface
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空接口的特殊情况
- en: '**Basic Types**'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**基本类型**'
- en: In this article we are going to discuss basic types only.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将仅讨论基本类型。
- en: '**Integers**'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**整数**'
- en: Integers can be signed or unsigned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以是有符号或无符号。
- en: '**Signed Integers**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**有符号整数**'
- en: Signed integers are of 5 types as below
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号整数有5种类型，如下所示
- en: '| **Type** | **Size** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** |'
- en: '| int | Platform Dependent |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| int | 依赖于平台 |'
- en: '| int8 | 8 bits/1 byte |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| int8 | 8位/1字节 |'
- en: '| int16 | 16 bits/2 byte |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| int16 | 16位/2字节 |'
- en: '| int32 | 32 bits/4 byte |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| int32 | 32位/4字节 |'
- en: '| int64 | 64 bits/8 byte |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| int64 | 64位/8字节 |'
- en: '**int**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**int**'
- en: '**Size:** Platform Dependent.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 依赖于平台。'
- en: On 32 bit machines, the size of int will be 32 bits or 4 byte.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位机器上，int的大小将为32位或4字节。
- en: On 64 bit machines, the size of int will be 64 bits or 8 byte
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的大小将为64位或8字节。
- en: '**Range**: Again Platform dependent'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：再次取决于平台'
- en: On 32 bit machines, the size of int will be 32 bits or 4 bytes.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位机器上，int的大小将为32位或4字节。
- en: On 64 bit machines, the size of int will be 64 bits or 8 bytes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在64位机器上，int的大小将为64位或8字节。
- en: '**When to Use:**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用时机：**'
- en: It is a good idea to use int whenever using signed Integer other than the cases
    mentioned below
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用有符号整数时，建议使用int，除了下面提到的情况。
- en: When the machine is a 32 bit and the range needed is greater than -231 to 231 -1,
    then use int64 instead of int. Note that in this case for int64,  2 32-bit memory
    addresses to form a 64-bit number together.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当机器是32位且所需范围大于-231到231-1时，则使用int64而不是int。请注意，在这种情况下，int64需要两个32位内存地址来共同形成一个64位数字。
- en: When the range is less then use the appropriate integer type.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当范围较小时，使用适当的整数类型。
- en: '**Properties:**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: Declare a int
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个int
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: int is default type for **integer.** When you don’t specify a type the default
    will be int
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int是**整数**的默认类型。当你没有指定类型时，默认类型为int。
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**bits** package of golang can help know the size of an **int** on your system'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bits**包可以帮助了解系统上**int**的大小'
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**unsafe.Sizeof()** function can also be used to see the size of int in bytes'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unsafe.Sizeof()** 函数也可以用于查看 int 的字节大小。'
- en: '**Full Working Code**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整工作代码**'
- en: Below is the full working code of the above properties
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是上述属性的完整工作代码
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Output:**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**int8**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**int8**'
- en: '**Size:** 8 bits or 1 byte'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 8 位或 1 字节'
- en: '**Range**: -2⁷ to 2⁷ -1.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**： -2⁷ 到 2⁷ - 1。'
- en: '**When to Use:**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: Use int8 when there it is known that the int range will be between -2⁷ to 2⁷ -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知整数范围在 -2⁷ 到 2⁷ - 1 之间时，使用 int8。对于临时值，如循环不变量，尽管可能占用更多空间，仍建议使用 int，因为在某些操作或库调用中它可能会被提升为
    int。
- en: For array values which lies between -27 to 27 -1, is a good use case for using
    int8\. For eg if you are storing ASCII index for lowercase letters then int8 can
    be used.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于范围在 -27 到 27 - 1 之间的数组值，使用 int8 是一个好的用例。例如，如果你要存储小写字母的 ASCII 索引，则可以使用 int8。
- en: It is a good idea to use int8 for data values.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据值，使用 int8 是个好主意。
- en: '**int16**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**int16**'
- en: '**Size:** 16 bits or 2 byte'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 16 位或 2 字节'
- en: '**Range**: -2^(15) to 2^(15) -1.**When to Use:**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**： -2^(15) 到 2^(15) - 1。**何时使用：**'
- en: Use int16 when there it is known that the int range will be between -2^(15) to
    2^(15) -1.  For temporary values such as loop invariants, it is still advisable
    to use int even though it might take more space because it is likely to be promoted
    to int in some operations or library calls.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知整数范围在 -2^(15) 到 2^(15) - 1 之间时，使用 int16。对于临时值，如循环不变量，尽管可能占用更多空间，仍建议使用 int，因为在某些操作或库调用中它可能会被提升为
    int。
- en: For array values which lie between -215 to 215 -1, is a good use case for using
    int8\. For eg if you are storing ASCII index for lowercase letters then int16
    can be used.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于范围在 -215 到 215 - 1 之间的数组值，使用 int8 是一个好的用例。例如，如果你要存储小写字母的 ASCII 索引，则可以使用 int16。
- en: '**int32**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**int32**'
- en: '**Size:** 32 bits or 4 byte'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 32 位或 4 字节'
- en: '**Range**: -2^(31) to 2^(31) -1.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**： -2^(31) 到 2^(31) - 1。'
- en: '**int64**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**int64**'
- en: '**Size:** 64 bits or 8 byte'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 64 位或 8 字节'
- en: '**Range**: -2^(63) to 2^(63) -1.**When to Use:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**： -2^(63) 到 2^(63) - 1。**何时使用：**'
- en: '**int64** is used when range is higher. For eg **time.Duration** is of type
    **int64**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**int64** 在范围更高时使用。例如，**time.Duration** 是 **int64** 类型。'
- en: '**UnSigned**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无符号**'
- en: UnSigned integers are of 5 types as below
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数有 5 种类型，如下所示。
- en: '| **Type** | **Size** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** |'
- en: '| uint | Platform Dependent |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| uint | 平台相关 |'
- en: '| uint8 | 8 bits/1 byte |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| uint8 | 8 位/1 字节 |'
- en: '| uint16 | 16 bits/2 byte |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| uint16 | 16 位/2 字节 |'
- en: '| uint32 | 32 bits/4 byte |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 32 位/4 字节 |'
- en: '| uint64 | 64 bits/8 byte |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 64 位/8 字节 |'
- en: '**uint**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint**'
- en: '**Size:** Platform Dependent.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 平台相关。'
- en: On 32 bit machines the size of int will be 32 bits or 4 byte.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位机器上，int 的大小将是 32 位或 4 字节。
- en: On 64 bit machines the size of int will be 64 bits or 8 byte
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 64 位机器上，int 的大小将是 64 位或 8 字节。
- en: '**Range**: Again Platform dependent'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：再次平台相关。'
- en: On 32 bit machines the range of int will be -2^(31) to 2^(31) -1.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位机器上，int 的范围将是 -2^(31) 到 2^(31) - 1。
- en: On 64 bit machines the range of int will be -2^(63) to 2^(63) -1
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 64 位机器上，int 的范围将是 -2^(63) 到 2^(63) - 1
- en: '**When to Use:**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: It is a good idea to use uint  whenever using signed Integer other than the
    cases mention below
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当使用带符号整数时，除了以下提到的情况，使用 uint 是个好主意。
- en: When machine is a 32 bit and range needed is greater than -2^(31) to 2^(31) -1,
    then use **int64** instead **int**. Note that in this case for int64,  2 32-bit
    memory addresses to form a 64-bit number together.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当机器为 32 位且所需范围大于 -2^(31) 到 2^(31) - 1 时，使用 **int64** 而不是 **int**。请注意，在这种情况下，int64
    由 2 个 32 位内存地址组合而成一个 64 位数字。
- en: When the range is less then use the appropriate int type
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当范围较小时，使用适当的 int 类型。
- en: '**Properties:**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: Declare a uint
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 uint
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**bits** package of golang can help know the size of an **uint** on your system'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: golang 的 **bits** 包可以帮助了解系统中 **uint** 的大小。
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**unsafe.Sizeof()** function can also be used to see the size of uint in bytes'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unsafe.Sizeof()** 函数也可以用于查看 uint 的字节大小。'
- en: '**Full Working Code**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整工作代码**'
- en: Below is the full working code of the above properties
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是上述属性的完整工作代码
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Output:**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**uintptr**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**uintptr**'
- en: This is an unsigned integer type that is large enough to hold any pointer address.
    Therefore is size and range are platform dependent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种无符号整数类型，足够大以容纳任何指针地址。因此其大小和范围与平台相关。
- en: '**Size:** Platform Dependent'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 平台相关。'
- en: On 32 bit machines, the size of an int will be 32 bits or 4 bytes.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位机器上，int 的大小将是 32 位或 4 字节。
- en: On 64 bit machines, the size of an int will be 64 bits or 8 bytes.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 64 位机器上，int 的大小将是 64 位或 8 字节。
- en: '**Range**: Again Platform dependent'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：再次取决于平台'
- en: On 32 bit machines the range of int will be -2^(31) to 2^(31) -1.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位机器上，int 的范围将是 -2^(31) 到 2^(31) - 1。
- en: On 64 bit machines the range of int will be -2^(63) to 2^(63) -1
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 64 位机器上，int 的范围将是 -2^(63) 到 2^(63) - 1。
- en: '**Properties:**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: A uintptr can be converted to unsafe.Pointer and vice versa
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uintptr 可以转换为 unsafe.Pointer，反之亦然。
- en: Arithmetic can be performed on the uintptr
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对 uintptr 执行算术运算
- en: uintptr even though it holds a pointer address, is just a value, and does not
    reference any object. Therefore
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uintptr 尽管它持有指针地址，但仅仅是一个值，并不引用任何对象。因此
- en: Its value will not be updated if the corresponding object moves. For Eg When
    goroutine stack changes
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果相应的对象移动，其值不会被更新。例如，当 goroutine 堆栈改变时。
- en: The corresponding object can be garbage collected.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应的对象可以被垃圾回收。
- en: '****When to Use:****'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '****何时使用：****'
- en: '***   Its purpose is to be used along with unsafe.Pointer mainly used for unsafe
    memory access.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*** 其目的主要是与 unsafe.Pointer 一起使用，用于不安全的内存访问。'
- en: When you want to save the pointer address value for printing it or storing it.
    Since the address is just stored and does not reference anything, the corresponding
    object can be garbage collected.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想保存指针地址值以进行打印或存储时。由于地址仅被存储并不引用任何对象，相应的对象可以被垃圾回收。
- en: '**Full Working Code**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整工作代码**'
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Output**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**uint8**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint8**'
- en: '**Size:** 8 bits or 1 byte'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 8 位或 1 字节'
- en: '**Range**:  0 to 255 or 0 to 2⁸ -1.**When to Use:**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0 到 255 或 0 到 2⁸ - 1。**何时使用：**'
- en: Use uint8 when there it is known that the int range will be between 2⁸ -1. 
    For temporary values such as loop invariants, it is still advisable to use int
    even though it might take more space because it is likely to be promoted to int
    in some operations or library calls.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知 int 的范围将介于 2⁸ - 1 之间时使用 uint8。对于临时值，如循环不变量，尽管可能占用更多空间，仍建议使用 int，因为它在某些操作或库调用中可能会提升为
    int。
- en: For array values which lies between  2⁸ -1\. is a good use case for using uint8\.
    For eg if you are storing ascii index in an array then **uint8** can be used.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于值在 2⁸ - 1 之间的数组，使用 uint8 是一个不错的选择。例如，如果你在数组中存储 ASCII 索引，则可以使用 **uint8**。
- en: '**uint16**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint16**'
- en: '**Size:** 16 bits or 2 byte'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 16 位或 2 字节'
- en: '**Range**: 0 to 2^(16) -1**When to Use:**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0 到 2^(16) - 1。**何时使用：**'
- en: Use int16 when there it is known that the int range will be between 0 to 2^(16) -1. 
    For temporary values such as loop invariants it is still advisable to use int
    even though it might take more space, because it is likely to be promoted to int
    in some operations or library calls.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知 int 的范围将介于 0 到 2^(16) - 1 之间时使用 int16。对于临时值，如循环不变量，尽管可能占用更多空间，仍建议使用 int，因为它在某些操作或库调用中可能会提升为
    int。
- en: For array values which lies between -0 to 2^(16) -1, is a good use case for
    using int8.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于值在 -0 到 2^(16) - 1 之间的数组，使用 int8 是一个不错的选择。
- en: '**uint32**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint32**'
- en: '**Size:** 32 bits or 4 byte'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 32 位或 4 字节'
- en: '**Range**: 0 to 2^(32) -1'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0 到 2^(32) - 1'
- en: '**uint64**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**uint64**'
- en: '**Size:** 64 bits or 8 byte'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小：** 64 位或 8 字节'
- en: '**Range**: 0 to 2^(64) -1**When to Use:**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：0 到 2^(64) - 1。**何时使用：**'
- en: uint64 is used when the range is higher.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当范围较高时使用 uint64。
- en: '**Floats**'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**浮点数**'
- en: Floats are numbers with decimals. It is of two types
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是带有小数的数字。它有两种类型。
- en: '| **Type** | **Size** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** |'
- en: '| float32 | 32 bits or 4 bytes |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| float32 | 32 位或 4 字节 |'
- en: '| float64 | 64 bits or 8 bytes |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| float64 | 64 位或 8 字节 |'
- en: '**float64** is the default float type. When you initialize a variable with
    a decimal value and don’t specify the float type, the default type inferred will
    be **float64**.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**float64** 是默认的浮点类型。当你用小数值初始化一个变量且未指定浮点类型时，推断出的默认类型将是 **float64**。'
- en: '**float32**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**float32**'
- en: '**float32** uses a single-precision floating-point format to store values.
    Basically, it is the set of all IEEE-754 32-bit floating-point numbers. The 32
    bits are divided into – 1 bit sign, 8 bits exponent, and 23 bits mantissa. float
    32 take half much size as float 64 and are comparatively faster on some machine
    architectures.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**float32** 使用单精度浮点格式来存储值。基本上，它是所有 IEEE-754 32 位浮点数的集合。32 位被分为：1 位符号位、8 位指数位和
    23 位尾数。float 32 的大小是 float 64 的一半，并且在某些机器架构上速度相对更快。'
- en: '**Size**: 32 bits or 4 bytes'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：32 位或 4 字节'
- en: '**Range**: 1.2E-38 to 3.4E+38'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：1.2E-38 到 3.4E+38'
- en: '**DefaultValue**: 0.0'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**：0.0'
- en: '**When to Use:**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: If in your system memory is a bottleneck and range is less, then **float32**
    can be used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的系统中内存是瓶颈且范围较小，则可以使用 **float32**。
- en: '**Example:**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点。
- en: Declare a float32
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个float32。
- en: Print size of float32 in bytes
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印float32的大小（字节）。
- en: '**Code:**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Output:**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE12]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**float64**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**float64**'
- en: float64 uses a double-precision floating-point format to store values. Basically
    it is the set of all IEEE-754 64-bit floating-point numbers. The 64 bits are divided
    into – 1-bit sign, 11 bits exponent, 52 bits mantissa. float64 takes twice as
    much size compared to float32 but can represent numbers more accurately than float32.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: float64使用双精度浮点格式来存储值。基本上它是所有IEEE-754 64位浮点数的集合。这64位分为1位符号、11位指数和52位尾数。float64的大小是float32的两倍，但能比float32更准确地表示数字。
- en: '**Size**: 32 bits or 4 bytes'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：32位或4字节。'
- en: '**Range**: 1.2E-38 to 3.4E+38'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：1.2E-38到3.4E+38。'
- en: '**DefaultValue**: 0.0'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**：0.0。'
- en: '**When to Use:**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用：**'
- en: When the precision needed is high
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当所需精度很高时。
- en: '**Example:**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例：**'
- en: The below code example illustrates below points
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了以下几点。
- en: Declare a float64
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个float64。
- en: Print size of float64 in bytes
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印float64的大小（字节）。
- en: Default is float64 when you don’t specify a type
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认是float64，当你不指定类型时。
- en: '**Code:**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE13]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Output:**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE14]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Complex Numbers**'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**复数**'
- en: Complex Numbers are of two types
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 复数有两种类型。
- en: '| **Type** | **Property** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **属性** |'
- en: '| complex64 | Both real and imaginary part are float32 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| complex64 | 实部和虚部均为float32 |'
- en: '| complex128 | Both real and imaginary part are float64 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| complex128 | 实部和虚部均为float64 |'
- en: The default complex type is complex128
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 默认复数类型是complex128。
- en: '**Initialization**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化**'
- en: Complex Numbers can be initialized in two ways
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 复数可以通过两种方式初始化。
- en: Using complex function. It has below signature. Do make sure that both a and
    b should be of same type , meaning either they both should be float32 or both
    should be float64
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用complex函数。它具有以下签名。确保a和b的类型相同，即它们都应为float32或都应为float64。
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the shorthand syntax. This is used when creating a complex number with
    direct numbers. The complex type created using below method will be of type **complex128**
    if type is not specified
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简写语法。这在使用直接数字创建复数时使用。如果未指定类型，使用以下方法创建的复数类型将为**complex128**。
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**complex64**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**complex64**'
- en: For complex 64 both real and imaginary part are float32
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于complex64，实部和虚部均为float32。
- en: '**Size**: Both real and imaginary part are of same size as float32\. It is
    of size 32 bits or 4 bytes'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：实部和虚部的大小与float32相同。它的大小为32位或4字节。'
- en: '**Range**: Both real and imaginary part range is same as float32 i.e 1.2E-38
    to 3.4E+38'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：实部和虚部的范围与float32相同，即1.2E-38到3.4E+38。'
- en: '**Example**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: Below is a sample code that shows
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码，显示了。
- en: How to create a complex64 number using the above two method
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用上述两种方法创建一个complex64数字。
- en: Print size of a complex64 number. Size will be  8 bytes(4 +4) which is equivalent
    to two float32 numbers
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个complex64数字的大小。大小将是8字节（4 + 4），相当于两个float32数字。
- en: Print type of a complex64 number
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个complex64数字的类型。
- en: + operation on complex number
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对复数进行+操作。
- en: '**Code:**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE17]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Output:**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**complex128**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**complex128**'
- en: For complex128 both **real** and **imaginary** part are **float64**
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于complex128，**实部**和**虚部**均为**float64**。
- en: '**Size**: Both **real** and **imaginary** part are of same size as float64\.
    It is of size 64 bits or 8 bytes'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小**：**实部**和**虚部**的大小与float64相同。它的大小为64位或8字节。'
- en: '**Range**: Both **real** and **imaginary** part range is same as **float64**
    i.e -1.7E+308 to +1.7E+308'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：**实部**和**虚部**的范围与**float64**相同，即-1.7E+308到+1.7E+308。'
- en: '**Example**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: Below is a sample code that shows
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码，显示了。
- en: How to create a complex128 number using above two method. It also shows when
    type is not specified, the default type will be **complex128**
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用上述两种方法创建一个complex128数字。当未指定类型时，默认类型将是**complex128**。
- en: Print size of a complex128 number. Size will be  16 bytes(8 +8) which is equivalent
    to two float64 numbers
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个complex128数字的大小。大小将是16字节（8 + 8），相当于两个float64数字。
- en: Print type of a complex128 number
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个complex128数字的类型。
- en: Different operations on complex number
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对复数进行不同操作。
- en: '**Code:**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Output:**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Byte**'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**字节**'
- en: byte in Go is an alias for **uint8** meaning it is an integer value. This integer
    value is of 8 bits and it represents one byte i.e number between 0-255). A single
    byte therefore can represent ASCII characters. Golang does not have any data type
    of ‘char’. Therefore
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的byte是**uint8**的别名，意味着它是一个整数值。这个整数值为8位，表示一个字节（即0-255之间的数字）。因此，一个字节可以表示ASCII字符。Golang没有‘char’的数据类型。因此。
- en: byte is used to represent the ASCII character
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节用于表示 ASCII 字符
- en: rune is used to represent all UNICODE characters which include every character
    that exists. We will study about rune later in this tutorial.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rune 用于表示所有 UNICODE 字符，包括所有存在的字符。我们将在本教程后面研究 rune。
- en: '**Define Byte**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义字节**'
- en: '[PRE21]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While declaring byte we have specify the type, as we have in the program above.
    If we don’t specify the type, then the default type is meant as a **rune.**
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明字节时，我们必须指定类型，就像我们在上面的程序中那样。如果不指定类型，则默认类型为 **rune**。
- en: '**Example**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'In below code example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中：
- en: How to define a byte
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义字节
- en: Print the byte type
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字节类型
- en: Print size of byte
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字节大小
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Output:**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE23]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Rune**'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Rune**'
- en: rune in Go is  an alias for **int32** meaning it is an integer value. This integer
    value is meant to represent a Unicode Code Point. To understand rune you have
    to know what Unicode is. Below is short description but you can refer to famous
    blog post about it – [The Absolute Minimum Every Software Developer Absolutely,
    Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 rune 是 **int32** 的别名，意味着它是一个整数值。这个整数值用于表示一个 Unicode 码点。要理解 rune，你必须知道
    Unicode 是什么。下面是简短的描述，但你可以参考著名的博文 – [每个软件开发者绝对、肯定必须了解的关于 Unicode 和字符集的最低限度知识（无借口！）](http://www.joelonsoftware.com/articles/Unicode.html)
- en: '**What is UniCode**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 Unicode**'
- en: Unicode is a superset of ASCII characters which assigns a unique number to every
    character that exists. This unique number is called Unicode Code Point.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 是 ASCII 字符的超集，为每个存在的字符分配一个唯一的数字。这个唯一的数字称为 Unicode 码点。
- en: For eg
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: Digit **0** is represented as Unicode Point **U+0030 (Decimal Value – 48)**
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 **0** 被表示为 Unicode 点 **U+0030 (十进制值 – 48)**
- en: Small Case **b** is represented as Unicode Point  **U+0062 (Decimal Value –
    98)**
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写 **b** 被表示为 Unicode 点 **U+0062 (十进制值 – 98)**
- en: A pound symbol **£ **is represented as Unicode Point **U+00A3 (Decimal Value
    – 163)**
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英镑符号 **£** 被表示为 Unicode 点 **U+00A3 (十进制值 – 163)**
- en: Visit [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)
    to know about Unicode Point of other characters. But Unicode doesn’t talk about
    how these code points will be saved in memory. This is where **utf-8** comes into
    picture
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters)
    以了解其他字符的 Unicode 点。但是 Unicode 不会说明这些码点将如何在内存中保存。这就是 **utf-8** 进入的地方。
- en: '**UTF-8**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-8**'
- en: utf-8 saves every Unicode Point either using 1, 2, 3 or 4 bytes. ASCII points
    are stored using 1 byte. That is why rune is an alias for int32 because a Unicode
    Point can be of max 4 bytes in Go as in GO every string is encoded using utf-8.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: utf-8 使用 1、2、3 或 4 个字节保存每个 Unicode 点。ASCII 点使用 1 个字节存储。这就是为什么 rune 是 int32 的别名，因为在
    Go 语言中，Unicode 点最多可以占用 4 个字节，且每个字符串都使用 utf-8 编码。
- en: Every rune is intended to refer to one Unicode Point.  For eg if you print a
    string after typecasting it to a rune array then it will print the Unicode Point
    for each of character. For for below string **“0b£”** output will be – **[U+0030
    U+0062 U+00A3]**
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 rune 旨在指代一个 Unicode 点。例如，如果你将一个字符串类型转换为 rune 数组并打印它，那么它将打印出每个字符的 Unicode
    点。对于下面的字符串 **“0b£”**，输出将是 – **[U+0030 U+0062 U+00A3]**
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Declare Rune**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明 Rune**'
- en: A rune is declared using a character between single quotes like below declaring
    a variable named **‘rPound’**
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: rune 使用单引号声明，如下所示，声明一个名为 **‘rPound’** 的变量。
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After declaring Rune you can perform below things as well
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 Rune 后，你还可以执行以下操作：
- en: '**Print Type –** Output will be **int32**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印类型 –** 输出将是 **int32**'
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Print Unicode Code Point –** Output will be **U+00A3**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印 Unicode 码点 –** 输出将是 **U+00A3**'
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Print Character –** Output will be **£**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印字符 –** 输出将是 **£**'
- en: '[PRE28]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**When to Use**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用**'
- en: You should use a rune when you intend to save Unicode Code Point in the value.
    A rune array should be used when all values in the array are meant to be a Unicode
    Code Point.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打算在值中保存 Unicode 码点时，应该使用 rune。当数组中的所有值都表示一个 Unicode 码点时，应该使用 rune 数组。
- en: '**Code:**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: Below is the code illustrating each point we discussed
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是说明我们讨论的每个点的代码
- en: '[PRE29]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Output:**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE30]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**String**'
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: string is a read only slice of bytes in golang. String can be initialized in
    two ways
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 golang 中只读的字节切片。字符串可以通过两种方式初始化。
- en: using double quotes “” eg “this”
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双引号 “” 例如 “this”
- en: string in double quotes honors the escape sequences. For eg if the string contains
    a \n then while printing there will be a new line
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号中的字符串尊重转义序列。例如，如果字符串包含 \n，则打印时会有新行。
- en: using back quotes ` eg  \`this`
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反引号 ` eg \`this`
- en: String in back quotes is just a raw string and it does not honor any kind of
    escape sequences.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号中的字符串只是一个原始字符串，它不遵循任何类型的转义序列。
- en: Each character in a string will occupy some bytes depending upon encoding used.
    For eg in utf-8 encoded string, each character will occupy between 1-4 bytes.
    You can read about utf-8 in this must read famous blog-[The Absolute Minimum Every
    Software Developer Absolutely, Positively Must Know About Unicode and Character
    Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html).   In
    utf-8 , the characters **a** or **b** are encoded using 1  byte while the character
    pound sign **£** is encoded using two bytes . Therefore the string “ab£” will
    output 4 bytes when you will convert the string to byte array and print it like
    below
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的每个字符将根据所使用的编码占用一些字节。例如，在 utf-8 编码的字符串中，每个字符将占用 1 到 4 个字节。你可以在这篇必读的著名博客中阅读关于
    utf-8 的内容——[每个软件开发者绝对、肯定必须了解的 Unicode 和字符集的绝对最少知识（没有借口！）](http://www.joelonsoftware.com/articles/Unicode.html)。在
    utf-8 中，字符 **a** 或 **b** 使用 1 个字节编码，而字符英镑符号 **£** 使用 2 个字节编码。因此，当你将字符串“ab£”转换为字节数组并像下面那样打印时，将输出
    4 个字节。
- en: '[PRE31]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Output**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '[PRE32]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Also when you try to print the length of the above string using **len(“ab£”),**
    it will output 4 and not 3 because it contains 4 bytes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用 **len(“ab£”)** 打印上面字符串的长度时，它将输出 4 而不是 3，因为它包含 4 个字节。
- en: Also note that **range** loops over sequences of byte which form each character,
    therefore for the below range loop
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，**range** 循环遍历每个字符形成的字节序列，因此对于下面的 range 循环
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Output will be
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是
- en: '[PRE34]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are many operations that can be performed on a string. One such operation
    is concatenation which combines two string. The sign ‘+’ is used for concatenation.
    Let’s see full working  code for all above things that we discussed
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串可以执行许多操作。其中一种操作是连接，它将两个字符串结合在一起。连接使用符号‘+’。让我们看看我们讨论过的所有内容的完整工作代码。
- en: '**Code:**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Output:**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Booleans**'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**布尔值**'
- en: The data type is **bool** and has two possible values true or false.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是 **bool**，并且有两个可能的值 true 或 false。
- en: 'Default Value: false'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值：false
- en: 'Operations:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 操作：
- en: AND – &&
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且 – &&
- en: OR  – ||
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者 – ||
- en: Negation – !
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取反 – !
- en: '**Example**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: The below code example shows
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了
- en: If not initialized the default value is **false**
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未初始化，默认值是 **false**
- en: All the above operations on the bool
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述所有操作在布尔值上
- en: '**Code**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Output:**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '[PRE38]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Conclusion
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This is all about basic types in golang. Hope you have liked this article. Please
    share feedback or improvement or mistakes in comments
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于 golang 的基本类型。希望你喜欢这篇文章。请在评论中分享反馈、改进意见或错误。
- en: '**Next Tutorial** – [Functions](https://golangbyexample.com/function-golang-complete-guide/)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一个教程** – [函数](https://golangbyexample.com/function-golang-complete-guide/)'
- en: '**Previous Tutorial** –[Variables](https://golangbyexample.com/variables-in-golang-complete-guide/)***'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**上一个教程** – [变量](https://golangbyexample.com/variables-in-golang-complete-guide/)***'
