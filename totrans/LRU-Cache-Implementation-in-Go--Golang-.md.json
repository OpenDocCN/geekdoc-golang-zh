["```\npackage main\n\nimport \"fmt\"\n\ntype node struct {\n\tkey   string\n\tvalue string\n\tprev  *node\n\tnext  *node\n}\n\ntype doublyLinkedList struct {\n\tlen  int\n\ttail *node\n\thead *node\n}\n\nfunc initDoublyList() *doublyLinkedList {\n\treturn &doublyLinkedList{}\n}\n\nfunc (d *doublyLinkedList) AddToFront(key, value string) {\n\tnewNode := &node{\n\t\tkey:   key,\n\t\tvalue: value,\n\t}\n\tif d.head == nil {\n\t\td.head = newNode\n\t\td.tail = newNode\n\t} else {\n\t\tnewNode.next = d.head\n\t\td.head.prev = newNode\n\t\td.head = newNode\n\t}\n\td.len++\n\treturn\n}\n\nfunc (d *doublyLinkedList) RemoveFromFront() {\n\tif d.head == nil {\n\t\treturn\n\t} else if d.head == d.tail {\n\t\td.head = nil\n\t\td.tail = nil\n\t} else {\n\t\td.head = d.head.next\n\t}\n\td.len--\n}\n\nfunc (d *doublyLinkedList) AddToEnd(node *node) {\n\tnewNode := node\n\tif d.head == nil {\n\t\td.head = newNode\n\t\td.tail = newNode\n\t} else {\n\t\tcurrentNode := d.head\n\t\tfor currentNode.next != nil {\n\t\t\tcurrentNode = currentNode.next\n\t\t}\n\t\tnewNode.prev = currentNode\n\t\tcurrentNode.next = newNode\n\t\td.tail = newNode\n\t}\n\td.len++\n}\nfunc (d *doublyLinkedList) Front() *node {\n\treturn d.head\n}\n\nfunc (d *doublyLinkedList) MoveNodeToEnd(node *node) {\n\tprev := node.prev\n\tnext := node.next\n\n\tif prev != nil {\n\t\tprev.next = next\n\t}\n\n\tif next != nil {\n\t\tnext.prev = prev\n\t}\n\tif d.tail == node {\n\t\td.tail = prev\n\t}\n\tif d.head == node {\n\t\td.head = next\n\t}\n\tnode.next = nil\n\tnode.prev = nil\n\td.len--\n\td.AddToEnd(node)\n}\n\nfunc (d *doublyLinkedList) TraverseForward() error {\n\tif d.head == nil {\n\t\treturn fmt.Errorf(\"TraverseError: List is empty\")\n\t}\n\ttemp := d.head\n\tfor temp != nil {\n\t\tfmt.Printf(\"key = %v, value = %v, prev = %v, next = %v\\n\", temp.key, temp.value, temp.prev, temp.next)\n\t\ttemp = temp.next\n\t}\n\tfmt.Println()\n\treturn nil\n}\n\nfunc (d *doublyLinkedList) Size() int {\n\treturn d.len\n}\n```", "```\npackage main\n\ntype evictionAlgo interface {\n\tevict(c *Cache) string\n\tget(node *node, c *Cache)\n\tset(node *node, c *Cache)\n\tset_overwrite(node *node, value string, c *Cache)\n}\n\nfunc createEvictioAlgo(algoType string) evictionAlgo {\n\tif algoType == \"fifo\" {\n\t\treturn &fifo{}\n\t} else if algoType == \"lru\" {\n\t\treturn &lru{}\n\t}\n\n\treturn nil\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype lru struct {\n}\n\nfunc (l *lru) evict(c *Cache) string {\n\tkey := c.doublyLinkedList.Front().key\n\tfmt.Printf(\"Evicting by lru strtegy. Evicted Node Key: %s: \", key)\n\tc.doublyLinkedList.RemoveFromFront()\n\treturn key\n}\n\nfunc (l *lru) get(node *node, c *Cache) {\n\tfmt.Println(\"Shuffling doubly linked list due to get operation\")\n\tc.doublyLinkedList.MoveNodeToEnd(node)\n}\n\nfunc (l *lru) set(node *node, c *Cache) {\n\tfmt.Println(\"Shuffling doubly linked list due to set operation\")\n\tc.doublyLinkedList.AddToEnd(node)\n}\n\nfunc (l *lru) set_overwrite(node *node, value string, c *Cache) {\n\tfmt.Println(\"Shuffling doubly linked list due to set_overwrite operation\")\n\tnode.value = value\n\tc.doublyLinkedList.MoveNodeToEnd(node)\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype fifo struct {\n}\n\nfunc (l *fifo) evict(c *Cache) string {\n\tfmt.Println(\"Evicting by fifo strtegy\")\n\tkey := c.doublyLinkedList.Front().key\n\tc.doublyLinkedList.RemoveFromFront()\n\treturn key\n}\n\nfunc (l *fifo) get(node *node, c *Cache) {\n\tfmt.Println(\"Shuffling doubly linked list due to get operation\")\n}\n\nfunc (l *fifo) set(node *node, c *Cache) {\n\tfmt.Println(\"Shuffling doubly linked list due to set operation\")\n\tc.doublyLinkedList.AddToEnd(node)\n}\n\nfunc (l *fifo) set_overwrite(node *node, value string, c *Cache) {\n\tfmt.Println(\"Shuffling doubly linked list due to set_overwrite operation\")\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\ntype Cache struct {\n\tdoublyLinkedList *doublyLinkedList\n\tstorage          map[string]*node\n\tevictionAlgo     evictionAlgo\n\tcapacity         int\n\tmaxCapacity      int\n}\n\nfunc initCache(evictionAlgo evictionAlgo, maxCapacity int) Cache {\n\tstorage := make(map[string]*node)\n\treturn Cache{\n\t\tdoublyLinkedList: &doublyLinkedList{},\n\t\tstorage:          storage,\n\t\tevictionAlgo:     evictionAlgo,\n\t\tcapacity:         0,\n\t\tmaxCapacity:      maxCapacity,\n\t}\n}\n\nfunc (this *Cache) setEvictionAlgo(e evictionAlgo) {\n\tthis.evictionAlgo = e\n}\n\nfunc (this *Cache) set(key, value string) {\n\tnode_ptr, ok := this.storage[key]\n\tif ok {\n\t\tthis.evictionAlgo.set_overwrite(node_ptr, value, this)\n\t\treturn\n\t}\n\tif this.capacity == this.maxCapacity {\n\t\tevictedKey := this.evict()\n\t\tdelete(this.storage, evictedKey)\n\t}\n\tnode := &node{key: key, value: value}\n\tthis.storage[key] = node\n\tthis.evictionAlgo.set(node, this)\n\tthis.capacity++\n}\n\nfunc (this *Cache) get(key string) string {\n\tnode_ptr, ok := this.storage[key]\n\tif ok {\n\t\tthis.evictionAlgo.get(node_ptr, this)\n\t\treturn (*node_ptr).value\n\t}\n\treturn \"\"\n}\n\nfunc (this *Cache) evict() string {\n\tkey := this.evictionAlgo.evict(this)\n\tthis.capacity--\n\treturn key\n}\n\nfunc (this *Cache) print() {\n\tfor k, v := range this.storage {\n\t\tfmt.Printf(\"key :%s value: %s\\n\", k, (*v).value)\n\t}\n\tthis.doublyLinkedList.TraverseForward()\n}\n```", "```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tlru := createEvictioAlgo(\"lru\")\n\tcache := initCache(lru, 3)\n\tcache.set(\"a\", \"1\")\n\tcache.print()\n\n\tcache.set(\"b\", \"2\")\n\tcache.print()\n\n\tcache.set(\"c\", \"3\")\n\tcache.print()\n\n\tvalue := cache.get(\"a\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tcache.set(\"d\", \"4\")\n\tcache.print()\n\n\tcache.set(\"e\", \"5\")\n\tcache.print()\n}\n```", "```\nShuffling doubly linked list due to set operation\nkey :a value: 1\nkey = a, value = 1, prev = <nil>, next = <nil>Shuffling doubly linked list due to set operation\nkey :a value: 1\nkey :b value: 2\nkey = a, value = 1, prev = <nil>, next = &{b 2 0xc00007e1e0 <nil>}\nkey = b, value = 2, prev = &{a 1 <nil>0xc00007e210}, next = <nil>Shuffling doubly linked list due to set operation\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nkey = a, value = 1, prev = <nil>, next = &{b 2 0xc00007e1e0 0xc00007e2a0}\nkey = b, value = 2, prev = &{a 1 <nil>0xc00007e210}, next = &{c 3 0xc00007e210 <nil>}\nkey = c, value = 3, prev = &{b 2 0xc00007e1e0 0xc00007e2a0}, next = <nil>Shuffling doubly linked list due to get operation\nkey: a, value: 1\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nkey = b, value = 2, prev = <nil>, next = &{c 3 0xc00007e210 0xc00007e1e0}\nkey = c, value = 3, prev = &{b 2 <nil>0xc00007e2a0}, next = &{a 1 0xc00007e2a0 <nil>}\nkey = a, value = 1, prev = &{c 3 0xc00007e210 0xc00007e1e0}, next = <nil>Evicting by lru strtegy. Evicted Node Key: %s:  b\nShuffling doubly linked list due to set operation\nkey :d value: 4\nkey :c value: 3\nkey :a value: 1\nkey = c, value = 3, prev = &{b 2 <nil>0xc00007e2a0}, next = &{a 1 0xc00007e2a0 0xc00007e450}\nkey = a, value = 1, prev = &{c 3 0xc00007e210 0xc00007e1e0}, next = &{d 4 0xc00007e1e0 <nil>}\nkey = d, value = 4, prev = &{a 1 0xc00007e2a0 0xc00007e450}, next = <nil>Evicting by lru strtegy. Evicted Node Key: %s:  c\nShuffling doubly linked list due to set operation\nkey :a value: 1\nkey :d value: 4\nkey :e value: 5\nkey = a, value = 1, prev = &{c 3 0xc00007e210 0xc00007e1e0}, next = &{d 4 0xc00007e1e0 0xc00007e570}\nkey = d, value = 4, prev = &{a 1 0xc00007e2a0 0xc00007e450}, next = &{e 5 0xc00007e450 <nil>}\nkey = e, value = 5, prev = &{d 4 0xc00007e1e0 0xc00007e570}, next =</nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil> \n```"]